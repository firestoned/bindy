<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/firestoned/bindy/actions/workflows/main.yaml"><img src="https://github.com/firestoned/bindy/actions/workflows/main.yaml/badge.svg" alt="Main Branch CI/CD" /></a>
<a href="https://github.com/firestoned/bindy/actions/workflows/pr.yaml"><img src="https://github.com/firestoned/bindy/actions/workflows/pr.yaml/badge.svg" alt="PR CI" /></a>
<a href="https://github.com/firestoned/bindy/actions/workflows/integration.yaml"><img src="https://github.com/firestoned/bindy/actions/workflows/integration.yaml/badge.svg" alt="Integration Tests" /></a>
<a href="https://codecov.io/gh/firestoned/bindy"><img src="https://codecov.io/gh/firestoned/bindy/branch/main/graph/badge.svg" alt="codecov" /></a></p>
<p><strong>Bindy</strong> is a high-performance Kubernetes controller written in Rust that manages BIND9 DNS infrastructure through Custom Resource Definitions (CRDs). It enables you to manage DNS zones and records as native Kubernetes resources, bringing the declarative Kubernetes paradigm to DNS management.</p>
<h2 id="what-is-bindy"><a class="header" href="#what-is-bindy">What is Bindy?</a></h2>
<p>Bindy watches for DNS-related Custom Resources in your Kubernetes cluster and automatically generates and manages BIND9 zone configurations. It replaces traditional manual DNS management with a declarative, GitOps-friendly approach.</p>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<ul>
<li><strong>High Performance</strong> - Native Rust implementation with async/await and zero-copy operations</li>
<li><strong>RNDC Protocol</strong> - Native BIND9 management via Remote Name Daemon Control (RNDC) with TSIG authentication</li>
<li><strong>Label Selectors</strong> - Target specific BIND9 instances using Kubernetes label selectors</li>
<li><strong>Dynamic Zone Management</strong> - Automatically create and manage DNS zones using RNDC commands</li>
<li><strong>Multi-Record Types</strong> - Support for A, AAAA, CNAME, MX, TXT, NS, SRV, and CAA records</li>
<li><strong>Declarative DNS</strong> - Manage DNS as Kubernetes resources with full GitOps support</li>
<li><strong>Security First</strong> - TSIG-authenticated RNDC communication, non-root containers, RBAC-ready</li>
<li><strong>Status Tracking</strong> - Complete status subresources for all resources</li>
<li><strong>Primary/Secondary Support</strong> - Built-in support for primary and secondary DNS architectures with zone transfers</li>
</ul>
<h2 id="why-bindy"><a class="header" href="#why-bindy">Why Bindy?</a></h2>
<p>Traditional DNS management involves:</p>
<ul>
<li>Manual editing of zone files</li>
<li>SSH access to DNS servers</li>
<li>No audit trail or version control</li>
<li>Difficult disaster recovery</li>
<li>Complex multi-region setups</li>
</ul>
<p>Bindy transforms this by:</p>
<ul>
<li>Managing DNS as Kubernetes resources</li>
<li>Full GitOps workflow support</li>
<li>Native RNDC protocol for direct BIND9 control</li>
<li>Built-in audit trail via Kubernetes events</li>
<li>Simple disaster recovery (backup your CRDs)</li>
<li>Seamless multi-region DNS distribution with zone transfers</li>
</ul>
<h2 id="who-should-use-bindy"><a class="header" href="#who-should-use-bindy">Who Should Use Bindy?</a></h2>
<p>Bindy is ideal for:</p>
<ul>
<li><strong>Platform Engineers</strong> building internal DNS infrastructure</li>
<li><strong>DevOps Teams</strong> managing DNS alongside their Kubernetes workloads</li>
<li><strong>SREs</strong> requiring automated, auditable DNS management</li>
<li><strong>Organizations</strong> running self-hosted BIND9 DNS servers</li>
<li><strong>Multi-region Deployments</strong> needing distributed DNS infrastructure</li>
</ul>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<p>Here's how simple it is to create a DNS zone with records:</p>
<pre><code class="language-yaml"># Create a DNS zone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
spec:
  zoneName: example.com
  instanceSelector:
    matchLabels:
      dns-role: primary
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin@example.com
    serial: 2024010101
  ttl: 3600

---
# Add an A record
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-example
spec:
  zone: example-com
  name: www
  ipv4Address: "192.0.2.1"
  ttl: 300
</code></pre>
<p>Apply it to your cluster:</p>
<pre><code class="language-bash">kubectl apply -f dns-config.yaml
</code></pre>
<p>Bindy automatically:</p>
<ol>
<li>Finds matching BIND9 instances using pod discovery</li>
<li>Connects to BIND9 via RNDC protocol (port 953)</li>
<li>Creates zones and records using native RNDC commands</li>
<li>Tracks status and conditions in real-time</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="./installation/installation.html">Installation</a> - Get started with Bindy</li>
<li><a href="./installation/quickstart.html">Quick Start</a> - Deploy your first DNS zone</li>
<li><a href="./concepts/architecture-rndc.html">RNDC-Based Architecture</a> - Learn about the RNDC protocol architecture</li>
<li><a href="./concepts/architecture.html">Architecture Overview</a> - Understand how Bindy works</li>
<li><a href="./reference/api.html">API Reference</a> - Complete API documentation</li>
</ul>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<ul>
<li><strong>Startup Time</strong>: &lt;1 second</li>
<li><strong>Memory Usage</strong>: ~50MB baseline</li>
<li><strong>Zone Creation Latency</strong>: &lt;500ms per zone (via RNDC)</li>
<li><strong>Record Addition Latency</strong>: &lt;200ms per record (via RNDC)</li>
<li><strong>RNDC Command Execution</strong>: &lt;100ms typical</li>
<li><strong>Controller Overhead</strong>: Negligible CPU when idle</li>
</ul>
<h2 id="project-status"><a class="header" href="#project-status">Project Status</a></h2>
<p>Bindy is actively developed and used in production environments. The project follows semantic versioning and maintains backward compatibility within major versions.</p>
<p>Current version: <strong>v0.1.0</strong></p>
<h2 id="support--community"><a class="header" href="#support--community">Support &amp; Community</a></h2>
<ul>
<li><strong>GitHub Issues</strong>: <a href="https://github.com/firestoned/bindy/issues">Report bugs or request features</a></li>
<li><strong>GitHub Discussions</strong>: <a href="https://github.com/firestoned/bindy/discussions">Ask questions and share ideas</a></li>
<li><strong>Documentation</strong>: You're reading it!</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Bindy is open-source software licensed under the <a href="./license.html">MIT License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This section guides you through installing Bindy in your Kubernetes cluster.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Installing Bindy involves these steps:</p>
<ol>
<li><strong>Prerequisites</strong> - Ensure your environment meets the requirements</li>
<li><strong>Install CRDs</strong> - Deploy Custom Resource Definitions</li>
<li><strong>Create RBAC</strong> - Set up service accounts and permissions</li>
<li><strong>Deploy Controller</strong> - Install the Bindy controller</li>
<li><strong>Create BIND9 Instances</strong> - Deploy your DNS servers</li>
</ol>
<h2 id="installation-methods"><a class="header" href="#installation-methods">Installation Methods</a></h2>
<h3 id="standard-installation"><a class="header" href="#standard-installation">Standard Installation</a></h3>
<p>The standard installation uses kubectl to apply YAML manifests:</p>
<pre><code class="language-bash"># Create namespace
kubectl create namespace dns-system

# Install CRDs
kubectl apply -k https://raw.githubusercontent.com/firestoned/bindy/main/deploy/crds/

# Install RBAC
kubectl apply -f https://raw.githubusercontent.com/firestoned/bindy/main/deploy/rbac/

# Deploy controller
kubectl apply -f https://raw.githubusercontent.com/firestoned/bindy/main/deploy/controller/deployment.yaml
</code></pre>
<h3 id="development-installation"><a class="header" href="#development-installation">Development Installation</a></h3>
<p>For development or testing, you can build and deploy from source:</p>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/firestoned/bindy.git
cd bindy

# Build the controller
cargo build --release

# Build Docker image
docker build -t bindy:dev .

# Deploy with your custom image
kubectl apply -f deploy/
</code></pre>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>After installation, verify that all components are running:</p>
<pre><code class="language-bash"># Check CRDs are installed
kubectl get crd | grep bindy.firestoned.io

# Check controller is running
kubectl get pods -n dns-system

# Check controller logs
kubectl logs -n dns-system -l app=bind9-controller
</code></pre>
<p>You should see output similar to:</p>
<pre><code>NAME                                READY   STATUS    RESTARTS   AGE
bind9-controller-7d4b8c4f9b-x7k2m   1/1     Running   0          1m
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="installation/./quickstart.html">Quick Start</a> - Deploy your first DNS zone</li>
<li><a href="installation/./prerequisites.html">Prerequisites</a> - Detailed system requirements</li>
<li><a href="installation/./crds.html">Installing CRDs</a> - Understanding the Custom Resources</li>
<li><a href="installation/./controller.html">Deploying the Controller</a> - Controller configuration options</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>Before installing Bindy, ensure your environment meets these requirements.</p>
<h2 id="kubernetes-cluster"><a class="header" href="#kubernetes-cluster">Kubernetes Cluster</a></h2>
<ul>
<li><strong>Kubernetes Version</strong>: 1.24 or later</li>
<li><strong>Access Level</strong>: Cluster admin access (for CRD and RBAC installation)</li>
<li><strong>Namespace</strong>: Ability to create namespaces (recommended: <code>dns-system</code>)</li>
</ul>
<h3 id="supported-kubernetes-distributions"><a class="header" href="#supported-kubernetes-distributions">Supported Kubernetes Distributions</a></h3>
<p>Bindy has been tested on:</p>
<ul>
<li>Kubernetes (vanilla)</li>
<li>k0s</li>
<li>MKE</li>
<li>k0RDENT</li>
<li>Amazon EKS</li>
<li>Google GKE</li>
<li>Azure AKS</li>
<li>Red Hat OpenShift</li>
<li>k3s</li>
<li>kind (for development/testing)</li>
</ul>
<h2 id="client-tools"><a class="header" href="#client-tools">Client Tools</a></h2>
<h3 id="required"><a class="header" href="#required">Required</a></h3>
<ul>
<li><strong>kubectl</strong>: 1.24+ - <a href="https://kubernetes.io/docs/tasks/tools/">Install kubectl</a></li>
</ul>
<h3 id="optional-for-development"><a class="header" href="#optional-for-development">Optional (for development)</a></h3>
<ul>
<li><strong>Rust</strong>: 1.70+ - <a href="https://rustup.rs/">Install Rust</a></li>
<li><strong>Cargo</strong>: Included with Rust</li>
<li><strong>Docker</strong>: For building images - <a href="https://docs.docker.com/get-docker/">Install Docker</a></li>
</ul>
<h2 id="cluster-resources"><a class="header" href="#cluster-resources">Cluster Resources</a></h2>
<h3 id="minimum-requirements"><a class="header" href="#minimum-requirements">Minimum Requirements</a></h3>
<ul>
<li><strong>CPU</strong>: 100m per controller pod</li>
<li><strong>Memory</strong>: 128Mi per controller pod</li>
<li><strong>Storage</strong>: Minimal (for configuration only)</li>
</ul>
<h3 id="recommended-for-production"><a class="header" href="#recommended-for-production">Recommended for Production</a></h3>
<ul>
<li><strong>CPU</strong>: 500m per controller pod (2 replicas)</li>
<li><strong>Memory</strong>: 512Mi per controller pod</li>
<li><strong>High Availability</strong>: 3 controller replicas across different nodes</li>
</ul>
<h2 id="bind9-infrastructure"><a class="header" href="#bind9-infrastructure">BIND9 Infrastructure</a></h2>
<p>Bindy manages existing BIND9 servers. You'll need:</p>
<ul>
<li>BIND9 version 9.16 or later (9.18+ recommended)</li>
<li>Network connectivity from Bindy controller to BIND9 pods</li>
<li>Shared volume for zone files (ConfigMap, PVC, or similar)</li>
</ul>
<h2 id="network-requirements"><a class="header" href="#network-requirements">Network Requirements</a></h2>
<h3 id="controller-to-api-server"><a class="header" href="#controller-to-api-server">Controller to API Server</a></h3>
<ul>
<li>Outbound HTTPS (443) to Kubernetes API server</li>
<li>Required for watching resources and updating status</li>
</ul>
<h3 id="controller-to-bind9-pods"><a class="header" href="#controller-to-bind9-pods">Controller to BIND9 Pods</a></h3>
<ul>
<li>Access to BIND9 configuration volumes</li>
<li>Typical setup uses Kubernetes ConfigMaps or PersistentVolumes</li>
</ul>
<h3 id="bind9-to-network"><a class="header" href="#bind9-to-network">BIND9 to Network</a></h3>
<ul>
<li>UDP/TCP port 53 for DNS queries</li>
<li>Port 953 for RNDC (if using remote name daemon control)</li>
<li>Zone transfer ports (configured in BIND9)</li>
</ul>
<h2 id="permissions"><a class="header" href="#permissions">Permissions</a></h2>
<h3 id="cluster-level-permissions-required"><a class="header" href="#cluster-level-permissions-required">Cluster-Level Permissions Required</a></h3>
<p>The person installing Bindy needs:</p>
<pre><code class="language-yaml"># Ability to create CRDs
- apiGroups: ["apiextensions.k8s.io"]
  resources: ["customresourcedefinitions"]
  verbs: ["create", "get", "list"]

# Ability to create ClusterRoles and ClusterRoleBindings
- apiGroups: ["rbac.authorization.k8s.io"]
  resources: ["clusterroles", "clusterrolebindings"]
  verbs: ["create", "get", "list"]
</code></pre>
<h3 id="namespace-permissions-required"><a class="header" href="#namespace-permissions-required">Namespace Permissions Required</a></h3>
<p>For the DNS system namespace:</p>
<ul>
<li>Create ServiceAccounts</li>
<li>Create Deployments</li>
<li>Create ConfigMaps</li>
<li>Create Services</li>
</ul>
<h2 id="optional-components"><a class="header" href="#optional-components">Optional Components</a></h2>
<h3 id="for-production-deployments"><a class="header" href="#for-production-deployments">For Production Deployments</a></h3>
<ul>
<li><strong>Monitoring</strong>: Prometheus for metrics collection</li>
<li><strong>Logging</strong>: Elasticsearch/Loki for log aggregation</li>
<li><strong>GitOps</strong>: ArgoCD or Flux for declarative management</li>
<li><strong>Backup</strong>: Velero for disaster recovery</li>
</ul>
<h3 id="for-development"><a class="header" href="#for-development">For Development</a></h3>
<ul>
<li><strong>kind</strong>: Local Kubernetes for testing</li>
<li><strong>tilt</strong>: For rapid development cycles</li>
<li><strong>k9s</strong>: Terminal UI for Kubernetes</li>
</ul>
<h2 id="verification-1"><a class="header" href="#verification-1">Verification</a></h2>
<p>Check your cluster meets the requirements:</p>
<pre><code class="language-bash"># Check Kubernetes version
kubectl version --short

# Check you have cluster-admin access
kubectl auth can-i create customresourcedefinitions

# Check available resources
kubectl top nodes

# Verify connectivity
kubectl cluster-info
</code></pre>
<p>Expected output:</p>
<pre><code>Client Version: v1.28.0
Server Version: v1.27.3
</code></pre>
<pre><code>yes
</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Once your environment meets these prerequisites:</p>
<ol>
<li><a href="installation/./crds.html">Install CRDs</a></li>
<li><a href="installation/./controller.html">Deploy the Controller</a></li>
<li><a href="installation/./quickstart.html">Quick Start Guide</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Get Bindy running in 5 minutes with this quick start guide.</p>
<h2 id="step-1-install-bindy"><a class="header" href="#step-1-install-bindy">Step 1: Install Bindy</a></h2>
<pre><code class="language-bash"># Create namespace
kubectl create namespace dns-system

# Install CRDs
kubectl apply -k https://raw.githubusercontent.com/firestoned/bindy/main/deploy/crds/

# Install RBAC
kubectl apply -f https://raw.githubusercontent.com/firestoned/bindy/main/deploy/rbac/

# Deploy controller
kubectl apply -f https://raw.githubusercontent.com/firestoned/bindy/main/deploy/controller/deployment.yaml

# Wait for controller to be ready
kubectl wait --for=condition=available --timeout=300s \
  deployment/bind9-controller -n dns-system
</code></pre>
<h2 id="step-2-create-a-bind9-cluster"><a class="header" href="#step-2-create-a-bind9-cluster">Step 2: Create a BIND9 Cluster</a></h2>
<p>First, create a cluster configuration that defines shared settings:</p>
<p>Create a file <code>bind9-cluster.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: production-dns
  namespace: dns-system
spec:
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.0.0/8"
</code></pre>
<p>Apply it:</p>
<pre><code class="language-bash">kubectl apply -f bind9-cluster.yaml
</code></pre>
<h2 id="step-3-create-a-bind9-instance"><a class="header" href="#step-3-create-a-bind9-instance">Step 3: Create a BIND9 Instance</a></h2>
<p>Now create an instance that references the cluster:</p>
<p>Create a file <code>bind9-instance.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  namespace: dns-system
spec:
  clusterRef: production-dns  # References the Bind9Cluster
  replicas: 1
</code></pre>
<p>Apply it:</p>
<pre><code class="language-bash">kubectl apply -f bind9-instance.yaml
</code></pre>
<h2 id="step-4-create-a-dns-zone"><a class="header" href="#step-4-create-a-dns-zone">Step 4: Create a DNS Zone</a></h2>
<p>Create a file <code>dns-zone.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: primary-dns  # References the Bind9Instance
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin.example.com.  # Note: @ replaced with .
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
  ttl: 3600
</code></pre>
<p>Apply it:</p>
<pre><code class="language-bash">kubectl apply -f dns-zone.yaml
</code></pre>
<h2 id="step-5-add-dns-records"><a class="header" href="#step-5-add-dns-records">Step 5: Add DNS Records</a></h2>
<p>Create a file <code>dns-records.yaml</code>:</p>
<pre><code class="language-yaml"># Web server A record
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-example
  namespace: dns-system
spec:
  zone: example-com
  name: www
  ipv4Address: "192.0.2.1"
  ttl: 300

---
# Blog CNAME record
apiVersion: bindy.firestoned.io/v1alpha1
kind: CNAMERecord
metadata:
  name: blog-example
  namespace: dns-system
spec:
  zone: example-com
  name: blog
  target: www.example.com.
  ttl: 300

---
# Mail server MX record
apiVersion: bindy.firestoned.io/v1alpha1
kind: MXRecord
metadata:
  name: mail-example
  namespace: dns-system
spec:
  zone: example-com
  name: "@"
  priority: 10
  mailServer: mail.example.com.
  ttl: 3600

---
# SPF TXT record
apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: spf-example
  namespace: dns-system
spec:
  zone: example-com
  name: "@"
  text:
    - "v=spf1 include:_spf.example.com ~all"
  ttl: 3600
</code></pre>
<p>Apply them:</p>
<pre><code class="language-bash">kubectl apply -f dns-records.yaml
</code></pre>
<h2 id="step-6-verify-your-dns-configuration"><a class="header" href="#step-6-verify-your-dns-configuration">Step 6: Verify Your DNS Configuration</a></h2>
<p>Check the status of your resources:</p>
<pre><code class="language-bash"># Check BIND9 cluster
kubectl get bind9clusters -n dns-system

# Check BIND9 instance
kubectl get bind9instances -n dns-system

# Check DNS zone
kubectl get dnszones -n dns-system

# Check DNS records
kubectl get arecords,cnamerecords,mxrecords,txtrecords -n dns-system

# View detailed status
kubectl describe dnszone example-com -n dns-system
</code></pre>
<p>You should see output like:</p>
<pre><code>NAME          ZONE          STATUS   AGE
example-com   example.com   Ready    1m
</code></pre>
<h2 id="step-7-test-dns-resolution"><a class="header" href="#step-7-test-dns-resolution">Step 7: Test DNS Resolution</a></h2>
<p>If your BIND9 instance is exposed (via LoadBalancer or NodePort):</p>
<pre><code class="language-bash"># Get the BIND9 service IP
kubectl get svc -n dns-system

# Test DNS query (replace &lt;BIND9-IP&gt; with actual IP)
dig @&lt;BIND9-IP&gt; www.example.com
dig @&lt;BIND9-IP&gt; blog.example.com
dig @&lt;BIND9-IP&gt; example.com MX
dig @&lt;BIND9-IP&gt; example.com TXT
</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>You've successfully deployed Bindy and created your first DNS zone with records!</p>
<h3 id="learn-more"><a class="header" href="#learn-more">Learn More</a></h3>
<ul>
<li><a href="installation/../concepts/architecture-rndc.html">RNDC-Based Architecture</a> - Understand the RNDC protocol architecture</li>
<li><a href="installation/../concepts/architecture.html">Architecture Overview</a> - Understand how Bindy works</li>
<li><a href="installation/../guide/multi-region.html">Multi-Region Setup</a> - Deploy across multiple regions</li>
<li><a href="installation/../operations/status.html">Status Conditions</a> - Monitor resource health</li>
</ul>
<h3 id="common-next-steps"><a class="header" href="#common-next-steps">Common Next Steps</a></h3>
<ol>
<li><strong>Add Secondary DNS Instances</strong> for high availability</li>
<li><strong>Configure Zone Transfers</strong> between primary and secondary</li>
<li><strong>Set up Monitoring</strong> to track DNS performance</li>
<li><strong>Integrate with GitOps</strong> for automated deployments</li>
<li><strong>Configure DNSSEC</strong> for enhanced security</li>
</ol>
<h3 id="production-checklist"><a class="header" href="#production-checklist">Production Checklist</a></h3>
<p>Before going to production:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Deploy multiple controller replicas for HA</li>
<li><input disabled="" type="checkbox"/>
Set up primary and secondary DNS instances</li>
<li><input disabled="" type="checkbox"/>
Configure resource limits and requests</li>
<li><input disabled="" type="checkbox"/>
Enable monitoring and alerting</li>
<li><input disabled="" type="checkbox"/>
Set up backup for CRD definitions</li>
<li><input disabled="" type="checkbox"/>
Configure RBAC properly</li>
<li><input disabled="" type="checkbox"/>
Review security settings</li>
<li><input disabled="" type="checkbox"/>
Test disaster recovery procedures</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>If something doesn't work:</p>
<ol>
<li>
<p><strong>Check controller logs</strong>:</p>
<pre><code class="language-bash">kubectl logs -n dns-system -l app=bind9-controller -f
</code></pre>
</li>
<li>
<p><strong>Check resource status</strong>:</p>
<pre><code class="language-bash">kubectl describe dnszone example-com -n dns-system
</code></pre>
</li>
<li>
<p><strong>Verify CRDs are installed</strong>:</p>
<pre><code class="language-bash">kubectl get crd | grep bindy.firestoned.io
</code></pre>
</li>
</ol>
<p>See the <a href="installation/../operations/troubleshooting.html">Troubleshooting Guide</a> for more help.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-crds"><a class="header" href="#installing-crds">Installing CRDs</a></h1>
<p>Custom Resource Definitions (CRDs) extend Kubernetes with new resource types for DNS management.</p>
<h2 id="what-are-crds"><a class="header" href="#what-are-crds">What are CRDs?</a></h2>
<p>CRDs define the schema for custom resources in Kubernetes. Bindy uses CRDs to represent:</p>
<ul>
<li>BIND9 clusters (cluster-level configuration)</li>
<li>BIND9 instances (individual DNS server deployments)</li>
<li>DNS zones</li>
<li>DNS records (A, AAAA, CNAME, MX, TXT, NS, SRV, CAA)</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Install all Bindy CRDs:</p>
<pre><code class="language-bash">kubectl apply -k https://raw.githubusercontent.com/firestoned/bindy/main/deploy/crds/
</code></pre>
<p>Or install from local files:</p>
<pre><code class="language-bash">cd bindy
kubectl apply -k deploy/crds
</code></pre>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h2>
<p>Check that all CRDs are installed:</p>
<pre><code class="language-bash">kubectl get crd | grep bindy.firestoned.io
</code></pre>
<p>Expected output:</p>
<pre><code>aaaarecords.bindy.firestoned.io         2024-01-01T00:00:00Z
arecords.bindy.firestoned.io            2024-01-01T00:00:00Z
bind9clusters.bindy.firestoned.io       2024-01-01T00:00:00Z
bind9instances.bindy.firestoned.io      2024-01-01T00:00:00Z
caarecords.bindy.firestoned.io          2024-01-01T00:00:00Z
cnamerecords.bindy.firestoned.io        2024-01-01T00:00:00Z
dnszones.bindy.firestoned.io            2024-01-01T00:00:00Z
mxrecords.bindy.firestoned.io           2024-01-01T00:00:00Z
nsrecords.bindy.firestoned.io           2024-01-01T00:00:00Z
srvrecords.bindy.firestoned.io          2024-01-01T00:00:00Z
txtrecords.bindy.firestoned.io          2024-01-01T00:00:00Z
</code></pre>
<h2 id="crd-details"><a class="header" href="#crd-details">CRD Details</a></h2>
<p>For detailed specifications of each CRD, see:</p>
<ul>
<li><a href="installation/../reference/bind9instance-spec.html">Bind9Instance Spec</a></li>
<li><a href="installation/../reference/dnszone-spec.html">DNSZone Spec</a></li>
<li><a href="installation/../reference/record-specs.html">Record Specs</a></li>
</ul>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><a href="installation/./controller.html">Deploy the Controller</a></li>
<li><a href="installation/./quickstart.html">Quick Start Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-the-controller"><a class="header" href="#deploying-the-controller">Deploying the Controller</a></h1>
<p>The Bindy controller watches for DNS resources and manages BIND9 configurations.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before deploying the controller:</p>
<ol>
<li><a href="installation/./crds.html">CRDs must be installed</a></li>
<li>RBAC must be configured</li>
<li>Namespace must exist (<code>dns-system</code> recommended)</li>
</ol>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<h3 id="create-namespace"><a class="header" href="#create-namespace">Create Namespace</a></h3>
<pre><code class="language-bash">kubectl create namespace dns-system
</code></pre>
<h3 id="install-rbac"><a class="header" href="#install-rbac">Install RBAC</a></h3>
<pre><code class="language-bash">kubectl apply -f https://raw.githubusercontent.com/firestoned/bindy/main/deploy/rbac/
</code></pre>
<p>This creates:</p>
<ul>
<li>ServiceAccount for the controller</li>
<li>ClusterRole with required permissions</li>
<li>ClusterRoleBinding to bind them together</li>
</ul>
<h3 id="deploy-controller"><a class="header" href="#deploy-controller">Deploy Controller</a></h3>
<pre><code class="language-bash">kubectl apply -f https://raw.githubusercontent.com/firestoned/bindy/main/deploy/controller/deployment.yaml
</code></pre>
<h3 id="wait-for-readiness"><a class="header" href="#wait-for-readiness">Wait for Readiness</a></h3>
<pre><code class="language-bash">kubectl wait --for=condition=available --timeout=300s \
  deployment/bind9-controller -n dns-system
</code></pre>
<h2 id="verify-deployment"><a class="header" href="#verify-deployment">Verify Deployment</a></h2>
<p>Check controller pod status:</p>
<pre><code class="language-bash">kubectl get pods -n dns-system -l app=bind9-controller
</code></pre>
<p>Expected output:</p>
<pre><code>NAME                                READY   STATUS    RESTARTS   AGE
bind9-controller-7d4b8c4f9b-x7k2m   1/1     Running   0          1m
</code></pre>
<p>Check controller logs:</p>
<pre><code class="language-bash">kubectl logs -n dns-system -l app=bind9-controller -f
</code></pre>
<p>You should see:</p>
<pre><code>{"timestamp":"2024-01-01T00:00:00Z","level":"INFO","message":"Starting Bindy controller"}
{"timestamp":"2024-01-01T00:00:01Z","level":"INFO","message":"Watching DNSZone resources"}
{"timestamp":"2024-01-01T00:00:01Z","level":"INFO","message":"Watching DNS record resources"}
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>Configure the controller via environment variables:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RUST_LOG</code></td><td><code>info</code></td><td>Log level (error, warn, info, debug, trace)</td></tr>
<tr><td><code>BIND9_ZONES_DIR</code></td><td><code>/etc/bind/zones</code></td><td>Directory for zone files</td></tr>
<tr><td><code>RECONCILE_INTERVAL</code></td><td><code>300</code></td><td>Reconciliation interval in seconds</td></tr>
</tbody></table>
</div>
<p>Edit the deployment to customize:</p>
<pre><code class="language-yaml">env:
  - name: RUST_LOG
    value: "debug"
  - name: BIND9_ZONES_DIR
    value: "/var/lib/bind/zones"
</code></pre>
<h3 id="resource-limits"><a class="header" href="#resource-limits">Resource Limits</a></h3>
<p>For production, set appropriate resource limits:</p>
<pre><code class="language-yaml">resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi
</code></pre>
<h3 id="high-availability"><a class="header" href="#high-availability">High Availability</a></h3>
<p>Run multiple replicas with leader election:</p>
<pre><code class="language-yaml">spec:
  replicas: 3
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="controller-not-starting"><a class="header" href="#controller-not-starting">Controller Not Starting</a></h3>
<ol>
<li>
<p>Check pod events:</p>
<pre><code class="language-bash">kubectl describe pod -n dns-system -l app=bind9-controller
</code></pre>
</li>
<li>
<p>Check if CRDs are installed:</p>
<pre><code class="language-bash">kubectl get crd | grep bindy.firestoned.io
</code></pre>
</li>
<li>
<p>Check RBAC permissions:</p>
<pre><code class="language-bash">kubectl auth can-i list dnszones --as=system:serviceaccount:dns-system:bind9-controller
</code></pre>
</li>
</ol>
<h3 id="high-memory-usage"><a class="header" href="#high-memory-usage">High Memory Usage</a></h3>
<p>If the controller uses excessive memory:</p>
<ol>
<li>Reduce log level: <code>RUST_LOG=warn</code></li>
<li>Increase resource limits</li>
<li>Check for memory leaks in logs</li>
</ol>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="installation/./quickstart.html">Quick Start Guide</a> - Create your first DNS zone</li>
<li><a href="installation/../operations/configuration.html">Configuration</a> - Advanced configuration</li>
<li><a href="installation/../operations/monitoring.html">Monitoring</a> - Set up monitoring</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic Concepts</a></h1>
<p>This section introduces the core concepts behind Bindy and how it manages DNS infrastructure in Kubernetes.</p>
<h2 id="the-kubernetes-way"><a class="header" href="#the-kubernetes-way">The Kubernetes Way</a></h2>
<p>Bindy follows Kubernetes patterns and idioms:</p>
<ul>
<li><strong>Declarative Configuration</strong> - You declare what DNS records should exist, Bindy makes it happen</li>
<li><strong>Custom Resources</strong> - DNS zones and records are Kubernetes resources</li>
<li><strong>Controllers</strong> - Bindy watches resources and reconciles state</li>
<li><strong>Labels and Selectors</strong> - Target specific BIND9 instances using labels</li>
<li><strong>Status Subresources</strong> - Track the health and state of DNS resources</li>
</ul>
<h2 id="core-resources"><a class="header" href="#core-resources">Core Resources</a></h2>
<p>Bindy introduces these Custom Resource Definitions (CRDs):</p>
<h3 id="infrastructure-resources"><a class="header" href="#infrastructure-resources">Infrastructure Resources</a></h3>
<ul>
<li><strong>Bind9Cluster</strong> - Cluster-level configuration (version, shared config, TSIG keys, ACLs)</li>
<li><strong><a href="concepts/./bind9instance.html">Bind9Instance</a></strong> - Individual BIND9 DNS server deployment (inherits from cluster)</li>
</ul>
<h3 id="dns-resources"><a class="header" href="#dns-resources">DNS Resources</a></h3>
<ul>
<li><strong><a href="concepts/./dnszone.html">DNSZone</a></strong> - Defines a DNS zone with SOA record (references a cluster)</li>
<li><strong><a href="concepts/./records.html">DNS Records</a></strong> - Individual DNS record types:
<ul>
<li>ARecord (IPv4)</li>
<li>AAAARecord (IPv6)</li>
<li>CNAMERecord (Canonical Name)</li>
<li>MXRecord (Mail Exchange)</li>
<li>TXTRecord (Text)</li>
<li>NSRecord (Name Server)</li>
<li>SRVRecord (Service)</li>
<li>CAARecord (Certificate Authority Authorization)</li>
</ul>
</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                     Kubernetes API                          │
│  ┌──────────┐  ┌─────────┐  ┌──────────┐  ┌──────────┐    │
│  │  DNSZone │  │ ARecord │  │ MXRecord │  │ TXTRecord│ ...│
│  └────┬─────┘  └────┬────┘  └────┬─────┘  └────┬─────┘    │
│       │             │            │             │           │
└───────┼─────────────┼────────────┼─────────────┼───────────┘
        │             │            │             │
        └─────────────┴────────────┴─────────────┘
                      │
                      ▼
        ┌─────────────────────────────┐
        │   Bindy Controller          │
        │   • Watches CRDs            │
        │   • Reconciles state        │
        │   • RNDC client             │
        │   • TSIG authentication     │
        └──────────────┬──────────────┘
                       │
                       │ RNDC Protocol
                       │ (Port 953/TCP)
                       │ TSIG/HMAC-SHA256
                       ▼
        ┌─────────────────────────────┐
        │   BIND9 Instances           │
        │   • rndc daemon (port 953)  │
        │   • Primary servers         │
        │   • Secondary servers       │
        │   • Dynamic zones           │
        │   • DNS queries (port 53)   │
        └─────────────────────────────┘
</code></pre>
<h3 id="reconciliation-loop"><a class="header" href="#reconciliation-loop">Reconciliation Loop</a></h3>
<ol>
<li><strong>Watch</strong> - Controller watches for changes to DNS resources</li>
<li><strong>Discover</strong> - Finds BIND9 instance pods via Kubernetes API</li>
<li><strong>Authenticate</strong> - Loads RNDC key from Kubernetes Secret</li>
<li><strong>Execute</strong> - Sends RNDC commands to BIND9 (addzone, reload, etc.)</li>
<li><strong>Verify</strong> - BIND9 executes command and returns success/error</li>
<li><strong>Status</strong> - Reports success or failure via status conditions</li>
</ol>
<h2 id="rndc-protocol"><a class="header" href="#rndc-protocol">RNDC Protocol</a></h2>
<p>Bindy uses the native BIND9 Remote Name Daemon Control (RNDC) protocol for managing DNS zones and servers. This provides:</p>
<ul>
<li><strong>Direct Control</strong> - Native BIND9 management without intermediate files</li>
<li><strong>Real-time Operations</strong> - Immediate feedback on success or failure</li>
<li><strong>Atomic Commands</strong> - Operations succeed or fail atomically</li>
<li><strong>Secure Communication</strong> - TSIG authentication with HMAC-SHA256</li>
</ul>
<h3 id="rndc-commands"><a class="header" href="#rndc-commands">RNDC Commands</a></h3>
<p>Common RNDC operations used by Bindy:</p>
<ul>
<li><code>addzone &lt;zone&gt;</code> - Dynamically add a new zone</li>
<li><code>delzone &lt;zone&gt;</code> - Remove a zone</li>
<li><code>reload &lt;zone&gt;</code> - Reload zone data</li>
<li><code>notify &lt;zone&gt;</code> - Trigger zone transfer to secondaries</li>
<li><code>zonestatus &lt;zone&gt;</code> - Query zone status</li>
<li><code>retransfer &lt;zone&gt;</code> - Force zone transfer from primary</li>
</ul>
<h3 id="tsig-authentication"><a class="header" href="#tsig-authentication">TSIG Authentication</a></h3>
<p>All RNDC communication is secured using TSIG (Transaction Signature):</p>
<ul>
<li><strong>Authentication</strong> - Verifies command source is authorized</li>
<li><strong>Integrity</strong> - Prevents command tampering</li>
<li><strong>Replay Protection</strong> - Timestamp validation prevents replay attacks</li>
<li><strong>Key Storage</strong> - RNDC keys stored in Kubernetes Secrets</li>
<li><strong>Per-Instance Keys</strong> - Each BIND9 instance has unique HMAC-SHA256 key</li>
</ul>
<h2 id="cluster-references"><a class="header" href="#cluster-references">Cluster References</a></h2>
<p>Instead of label selectors, zones now reference a specific BIND9 cluster:</p>
<pre><code class="language-yaml"># DNS Zone references a cluster
spec:
  zoneName: example.com
  clusterRef: my-dns-cluster  # References Bind9Instance name
</code></pre>
<p>This simplifies:</p>
<ul>
<li><strong>Zone placement</strong> - Direct reference to cluster</li>
<li><strong>Pod discovery</strong> - Find instances by cluster name</li>
<li><strong>RNDC key lookup</strong> - Keys named <code>{clusterRef}-rndc-key</code></li>
</ul>
<h2 id="resource-relationships"><a class="header" href="#resource-relationships">Resource Relationships</a></h2>
<pre><code>Bind9Cluster (cluster config)
    ↑
    │ referenced by clusterRef
    │
Bind9Instance (has clusterRef)
    ↑
    │ zone.spec.cluster_ref references instance
    │
DNSZone (has clusterRef)
    ↑
    │ referenced by zone field
    │
DNS Records (A, CNAME, MX, etc.)
</code></pre>
<h3 id="three-tier-hierarchy"><a class="header" href="#three-tier-hierarchy">Three-Tier Hierarchy</a></h3>
<ol>
<li>
<p><strong>Bind9Cluster</strong> - Cluster-level configuration</p>
<ul>
<li>Shared BIND9 version</li>
<li>Common config (recursion, DNSSEC, forwarders)</li>
<li>TSIG keys for zone transfers</li>
<li>ACL definitions</li>
</ul>
</li>
<li>
<p><strong>Bind9Instance</strong> - Instance deployment</p>
<ul>
<li>References a Bind9Cluster via <code>cluster_ref</code></li>
<li>Can override cluster config</li>
<li>Has RNDC key for management</li>
<li>Manages pods and services</li>
</ul>
</li>
<li>
<p><strong>DNSZone</strong> - DNS zone definition</p>
<ul>
<li>References a Bind9Instance via <code>cluster_ref</code></li>
<li>Contains SOA record</li>
<li>Applied to instance via RNDC</li>
</ul>
</li>
<li>
<p><strong>DNS Records</strong> - Individual records</p>
<ul>
<li>Reference a DNSZone by name</li>
<li>Added to zone via RNDC (planned: nsupdate)</li>
</ul>
</li>
</ol>
<h3 id="rndc-key-secret-relationship"><a class="header" href="#rndc-key-secret-relationship">RNDC Key Secret Relationship</a></h3>
<pre><code>Bind9Instance: my-dns-instance
    ↓
    creates/expects
    ↓
Secret: my-dns-instance-rndc-key
    data:
      key-name: my-dns-instance
      algorithm: hmac-sha256
      secret: &lt;base64-encoded-key&gt;
</code></pre>
<p>The controller uses this Secret to authenticate RNDC commands to the BIND9 instance.</p>
<h2 id="status-and-conditions"><a class="header" href="#status-and-conditions">Status and Conditions</a></h2>
<p>All resources report their status:</p>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      reason: Synchronized
      message: Zone created for 2 instances
      lastTransitionTime: 2024-01-01T00:00:00Z
  observedGeneration: 1
  matchedInstances: 2
</code></pre>
<p>Status conditions follow Kubernetes conventions:</p>
<ul>
<li><strong>Type</strong> - What aspect (Ready, Synced, etc.)</li>
<li><strong>Status</strong> - True, False, or Unknown</li>
<li><strong>Reason</strong> - Machine-readable reason code</li>
<li><strong>Message</strong> - Human-readable description</li>
</ul>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="concepts/./architecture-rndc.html">RNDC-Based Architecture</a> - Learn about the RNDC protocol architecture</li>
<li><a href="concepts/./architecture.html">Architecture Overview</a> - Deep dive into Bindy's architecture</li>
<li><a href="concepts/./crds.html">Custom Resource Definitions</a> - Detailed CRD specifications</li>
<li><a href="concepts/./bind9instance.html">Bind9Instance</a> - Learn about BIND9 instance resources</li>
<li><a href="concepts/./dnszone.html">DNSZone</a> - Learn about DNS zone resources</li>
<li><a href="concepts/./records.html">DNS Records</a> - Learn about DNS record types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>This page provides a detailed overview of Bindy's architecture and design principles.</p>
<h2 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-Level Architecture</a></h2>
<pre><code>┌──────────────────────────────────────────────────────────────┐
│                    Kubernetes Cluster                        │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │            Custom Resource Definitions (CRDs)          │ │
│  │  • Bind9Instance  • DNSZone  • ARecord  • MXRecord ... │ │
│  └────────────────────────────────────────────────────────┘ │
│                             │                                │
│                             │ watches                        │
│                             ▼                                │
│  ┌────────────────────────────────────────────────────────┐ │
│  │              Bindy Controller (Rust)                   │ │
│  │                                                        │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐ │ │
│  │  │  Bind9Instance│  │   DNSZone    │  │   Records   │ │ │
│  │  │  Reconciler  │  │  Reconciler  │  │  Reconciler │ │ │
│  │  └──────────────┘  └──────────────┘  └─────────────┘ │ │
│  │                                                        │ │
│  │  ┌──────────────────────────────────────────────────┐ │ │
│  │  │         Zone File Generator                      │ │ │
│  │  └──────────────────────────────────────────────────┘ │ │
│  └────────────────────────────────────────────────────────┘ │
│                             │                                │
│                             │ configures                     │
│                             ▼                                │
│  ┌────────────────────────────────────────────────────────┐ │
│  │              BIND9 Instances                           │ │
│  │                                                        │ │
│  │  ┌──────────┐      ┌──────────┐      ┌──────────┐    │ │
│  │  │ Primary  │ AXFR │Secondary │ AXFR │Secondary │    │ │
│  │  │   DNS    │─────▶│   DNS    │─────▶│   DNS    │    │ │
│  │  │  (us-east)│     │ (us-west)│     │  (eu)    │    │ │
│  │  └──────────┘      └──────────┘      └──────────┘    │ │
│  └────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────┘
                             │
                             │ DNS queries (UDP/TCP 53)
                             ▼
                    ┌─────────────────┐
                    │     Clients     │
                    │  • Apps         │
                    │  • Services     │
                    │  • External     │
                    └─────────────────┘
</code></pre>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<h3 id="bindy-controller"><a class="header" href="#bindy-controller">Bindy Controller</a></h3>
<p>The controller is written in Rust using the kube-rs library. It consists of:</p>
<h4 id="1-reconcilers"><a class="header" href="#1-reconcilers">1. Reconcilers</a></h4>
<p>Each reconciler handles a specific resource type:</p>
<ul>
<li>
<p><strong>Bind9Instance Reconciler</strong> - Manages BIND9 instance lifecycle</p>
<ul>
<li>Creates StatefulSets for BIND9 pods</li>
<li>Configures services and networking</li>
<li>Updates instance status</li>
</ul>
</li>
<li>
<p><strong>DNSZone Reconciler</strong> - Manages DNS zones</p>
<ul>
<li>Evaluates label selectors</li>
<li>Generates zone files</li>
<li>Updates zone configuration</li>
<li>Reports matched instances</li>
</ul>
</li>
<li>
<p><strong>Record Reconcilers</strong> - Manage individual DNS records</p>
<ul>
<li>One reconciler per record type (A, AAAA, CNAME, MX, TXT, NS, SRV, CAA)</li>
<li>Validates record specifications</li>
<li>Appends records to zone files</li>
<li>Updates record status</li>
</ul>
</li>
</ul>
<h4 id="2-zone-file-generator"><a class="header" href="#2-zone-file-generator">2. Zone File Generator</a></h4>
<p>Generates BIND9-compatible zone files from Kubernetes resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simplified example
pub fn generate_zone_file(zone: &amp;DNSZone, records: Vec&lt;DNSRecord&gt;) -&gt; String {
    let mut zone_file = String::new();

    // SOA record
    zone_file.push_str(&amp;format_soa_record(&amp;zone.spec.soa_record));

    // NS records
    for ns in &amp;zone.spec.name_servers {
        zone_file.push_str(&amp;format_ns_record(ns));
    }

    // Individual records
    for record in records {
        zone_file.push_str(&amp;format_record(record));
    }

    zone_file
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-resource-definitions-crds"><a class="header" href="#custom-resource-definitions-crds">Custom Resource Definitions (CRDs)</a></h3>
<p>CRDs define the schema for DNS resources:</p>
<pre><code class="language-yaml">apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: dnszones.bindy.firestoned.io
spec:
  group: bindy.firestoned.io
  names:
    kind: DNSZone
    plural: dnszones
  scope: Namespaced
  versions:
    - name: v1alpha1
      served: true
      storage: true
</code></pre>
<h3 id="bind9-instances"><a class="header" href="#bind9-instances">BIND9 Instances</a></h3>
<p>BIND9 servers managed by Bindy:</p>
<ul>
<li>Deployed as Kubernetes StatefulSets</li>
<li>Configuration via ConfigMaps</li>
<li>Zone files mounted from ConfigMaps or PVCs</li>
<li>Support for primary and secondary architectures</li>
</ul>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<h3 id="zone-creation-flow"><a class="header" href="#zone-creation-flow">Zone Creation Flow</a></h3>
<ol>
<li>
<p><strong>User creates DNSZone resource</strong></p>
<pre><code class="language-bash">kubectl apply -f dnszone.yaml
</code></pre>
</li>
<li>
<p><strong>Controller watches and receives event</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Watch stream receives create event
stream.next().await
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>DNSZone reconciler evaluates selector</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find matching Bind9Instances
let instances = find_matching_instances(&amp;zone.spec.instance_selector).await?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Generate zone file for each instance</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create zone configuration
let zone_file = generate_zone_file(&amp;zone, &amp;records)?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Update BIND9 configuration</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Apply ConfigMap with zone file
update_bind9_config(&amp;instance, &amp;zone_file).await?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Update DNSZone status</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Report success
update_status(&amp;zone, conditions, matched_instances).await?;
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="record-addition-flow"><a class="header" href="#record-addition-flow">Record Addition Flow</a></h3>
<ol>
<li><strong>User creates DNS record resource</strong></li>
<li><strong>Controller receives event</strong></li>
<li><strong>Record reconciler validates zone reference</strong></li>
<li><strong>Append record to existing zone file</strong></li>
<li><strong>Reload BIND9 configuration</strong></li>
<li><strong>Update record status</strong></li>
</ol>
<h2 id="concurrency-model"><a class="header" href="#concurrency-model">Concurrency Model</a></h2>
<p>Bindy uses Rust's async/await with Tokio runtime:</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spawn multiple reconcilers concurrently
    tokio::try_join!(
        run_bind9instance_controller(),
        run_dnszone_controller(),
        run_record_controllers(),
    )?;
    Ok(())
}</code></pre></pre>
<p>Benefits:</p>
<ul>
<li><strong>Concurrent reconciliation</strong> - Multiple resources reconciled simultaneously</li>
<li><strong>Non-blocking I/O</strong> - Efficient API server communication</li>
<li><strong>Low memory footprint</strong> - Async tasks use minimal memory</li>
<li><strong>High throughput</strong> - Handle thousands of DNS records efficiently</li>
</ul>
<h2 id="resource-watching"><a class="header" href="#resource-watching">Resource Watching</a></h2>
<p>The controller uses Kubernetes watch API with reflector caching:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let api: Api&lt;DNSZone&gt; = Api::all(client);
let watcher = watcher(api, ListParams::default());

// Reflector caches resources locally
let store = reflector::store::Writer::default();
let reader = store.as_reader();
let reflector = reflector(store, watcher);

// Process events
while let Some(event) = stream.try_next().await? {
    match event {
        Applied(zone) =&gt; reconcile_zone(zone).await?,
        Deleted(zone) =&gt; cleanup_zone(zone).await?,
        Restarted(_) =&gt; refresh_all().await?,
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>Multi-layer error handling strategy:</p>
<ol>
<li><strong>Validation Errors</strong> - Caught early, reported in status</li>
<li><strong>Reconciliation Errors</strong> - Retried with exponential backoff</li>
<li><strong>Fatal Errors</strong> - Logged and cause controller restart</li>
<li><strong>Status Reporting</strong> - All errors visible in resource status</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match reconcile_zone(&amp;zone).await {
    Ok(_) =&gt; update_status(Ready, "Synchronized"),
    Err(e) =&gt; {
        log::error!("Failed to reconcile zone: {}", e);
        update_status(NotReady, e.to_string());
        // Requeue for retry
        Err(e)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance Optimizations</a></h2>
<h3 id="1-incremental-updates"><a class="header" href="#1-incremental-updates">1. Incremental Updates</a></h3>
<p>Only regenerate zone files when records change, not on every reconciliation.</p>
<h3 id="2-caching"><a class="header" href="#2-caching">2. Caching</a></h3>
<p>Local cache of BIND9 instances to avoid repeated API calls.</p>
<h3 id="3-batch-processing"><a class="header" href="#3-batch-processing">3. Batch Processing</a></h3>
<p>Group related updates to minimize BIND9 reloads.</p>
<h3 id="4-zero-copy-operations"><a class="header" href="#4-zero-copy-operations">4. Zero-Copy Operations</a></h3>
<p>Use string slicing and references to avoid unnecessary allocations.</p>
<h3 id="5-compiled-binary"><a class="header" href="#5-compiled-binary">5. Compiled Binary</a></h3>
<p>Rust compilation produces optimized native code with no runtime overhead.</p>
<h2 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h2>
<h3 id="rbac"><a class="header" href="#rbac">RBAC</a></h3>
<p>Controller uses least-privilege service account:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: bind9-controller
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: bind9-controller
rules:
  - apiGroups: ["bindy.firestoned.io"]
    resources: ["dnszones", "arecords", ...]
    verbs: ["get", "list", "watch", "update"]
</code></pre>
<h3 id="non-root-containers"><a class="header" href="#non-root-containers">Non-Root Containers</a></h3>
<p>Controller runs as non-root user:</p>
<pre><code class="language-dockerfile">USER 65532:65532
</code></pre>
<h3 id="network-policies"><a class="header" href="#network-policies">Network Policies</a></h3>
<p>Limit controller network access:</p>
<pre><code class="language-yaml">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: bind9-controller
spec:
  podSelector:
    matchLabels:
      app: bind9-controller
  policyTypes:
    - Egress
  egress:
    - to:
        - namespaceSelector: {}
      ports:
        - protocol: TCP
          port: 443  # API server only
</code></pre>
<h2 id="scalability"><a class="header" href="#scalability">Scalability</a></h2>
<h3 id="horizontal-scaling"><a class="header" href="#horizontal-scaling">Horizontal Scaling</a></h3>
<p>Multiple controller replicas with leader election:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lease_lock = LeaseLock::new(
    client,
    "dns-system",
    "bind9-controller-leader",
);

run_with_lease(lease_lock, reconcile_loop).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-limits-1"><a class="header" href="#resource-limits-1">Resource Limits</a></h3>
<p>Recommended production configuration:</p>
<pre><code class="language-yaml">resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi
</code></pre>
<p>Can handle:</p>
<ul>
<li><strong>1000+</strong> DNS zones</li>
<li><strong>10,000+</strong> DNS records</li>
<li><strong>&lt;100ms</strong> average reconciliation time</li>
</ul>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><a href="concepts/./crds.html">Custom Resource Definitions</a> - CRD specifications</li>
<li><a href="concepts/../development/controller-design.html">Controller Design</a> - Implementation details</li>
<li><a href="concepts/../advanced/performance.html">Performance Tuning</a> - Optimization strategies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technical-architecture"><a class="header" href="#technical-architecture">Technical Architecture</a></h1>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                     Kubernetes Cluster                       │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │           DNS System Namespace (dns-system)           │   │
│  ├──────────────────────────────────────────────────────┤   │
│  │                                                        │   │
│  │  ┌─────────────────────────────────────────────────┐ │   │
│  │  │    Rust Controller Pod                          │ │   │
│  │  ├─────────────────────────────────────────────────┤ │   │
│  │  │                                                 │ │   │
│  │  │  ┌────────────────────────────────────────┐   │ │   │
│  │  │  │  Main Event Loop                       │   │ │   │
│  │  │  ├────────────────────────────────────────┤   │ │   │
│  │  │  │  • DNSZone Controller                  │   │ │   │
│  │  │  │  • ARecord Controller                  │   │ │   │
│  │  │  │  • TXTRecord Controller                │   │ │   │
│  │  │  │  • CNAMERecord Controller              │   │ │   │
│  │  │  │  (runs concurrently via Tokio)        │   │ │   │
│  │  │  └────────────────────────────────────────┘   │ │   │
│  │  │                                                 │ │   │
│  │  │  ┌────────────────────────────────────────┐   │ │   │
│  │  │  │  Reconcilers                           │   │ │   │
│  │  │  ├────────────────────────────────────────┤   │ │   │
│  │  │  │  • reconcile_dnszone()                 │   │ │   │
│  │  │  │  • reconcile_a_record()                │   │ │   │
│  │  │  │  • reconcile_txt_record()              │   │ │   │
│  │  │  │  • reconcile_cname_record()            │   │ │   │
│  │  │  └────────────────────────────────────────┘   │ │   │
│  │  │                                                 │ │   │
│  │  │  ┌────────────────────────────────────────┐   │ │   │
│  │  │  │  BIND9 Manager                         │   │ │   │
│  │  │  ├────────────────────────────────────────┤   │ │   │
│  │  │  │  • create_zone_file()                  │   │ │   │
│  │  │  │  • add_a_record()                      │   │ │   │
│  │  │  │  • add_txt_record()                    │   │ │   │
│  │  │  │  • delete_zone()                       │   │ │   │
│  │  │  └────────────────────────────────────────┘   │ │   │
│  │  │                                                 │ │   │
│  │  └─────────────────────────────────────────────────┘ │   │
│  │                                                        │   │
│  │  ┌─────────────────────────────────────────────────┐ │   │
│  │  │    BIND9 Instance Pods (scaled)                │ │   │
│  │  ├─────────────────────────────────────────────────┤ │   │
│  │  │  /etc/bind/zones/db.example.com                │ │   │
│  │  │  /etc/bind/zones/db.internal.local             │ │   │
│  │  │  ...                                            │ │   │
│  │  └─────────────────────────────────────────────────┘ │   │
│  │                                                        │   │
│  └────────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │        Custom Resources (in etcd)                     │   │
│  ├──────────────────────────────────────────────────────┤   │
│  │  • Bind9Instance (primary-dns, secondary-dns)       │   │
│  │  • DNSZone (example-com, internal-local)            │   │
│  │  • ARecord (www, api, db, ...)                      │   │
│  │  • TXTRecord (spf, dmarc, ...)                      │   │
│  │  • CNAMERecord (blog, cache, ...)                   │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                               │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<h3 id="1-dnszone-creation-flow"><a class="header" href="#1-dnszone-creation-flow">1. DNSZone Creation Flow</a></h3>
<pre><code>User creates DNSZone
    ↓
Kubernetes API Server stores in etcd
    ↓
Watch event triggered
    ↓
Controller receives event (via kube-rs runtime)
    ↓
reconcile_dnszone_wrapper() called
    ↓
reconcile_dnszone() logic:
  1. Extract DNSZone spec
  2. Evaluate instanceSelector against Bind9Instance labels
  3. Find matching instances (e.g., 2 matching)
  4. Call zone_manager.create_zone_file()
  5. Zone file created in /etc/bind/zones/db.example.com
  6. Update DNSZone status with "Ready" condition
    ↓
Status Update (via API)
    ↓
Done, requeue after 5 minutes
</code></pre>
<h3 id="2-record-creation-flow"><a class="header" href="#2-record-creation-flow">2. Record Creation Flow</a></h3>
<pre><code>User creates ARecord
    ↓
Kubernetes API Server stores in etcd
    ↓
Watch event triggered
    ↓
Controller receives event
    ↓
reconcile_a_record_wrapper() called
    ↓
reconcile_a_record() logic:
  1. Extract ARecord spec (zone, name, ip, ttl)
  2. Call zone_manager.add_a_record()
  3. Record appended to zone file
  4. Update ARecord status with "Ready" condition
    ↓
Status Update (via API)
    ↓
Done, requeue after 5 minutes
</code></pre>
<h2 id="concurrency-model-1"><a class="header" href="#concurrency-model-1">Concurrency Model</a></h2>
<pre><code>┌─────────────────────────────────────┐
│    Main Tokio Runtime                │
├─────────────────────────────────────┤
│                                     │
│  ┌─────────────────────────────┐   │
│  │ DNSZone Controller Task     │   │
│  │ (watches DNSZone resources) │   │
│  └─────────────────────────────┘   │
│              ↓                      │
│          ┌──────────────────────┐  │
│          │ ARecord Controller   │  │
│          │ Task (concurrent)    │  │
│          └──────────────────────┘  │
│              ↓                      │
│          ┌──────────────────────┐  │
│          │ TXTRecord Controller │  │
│          │ Task (concurrent)    │  │
│          └──────────────────────┘  │
│              ↓                      │
│          ┌──────────────────────┐  │
│          │ CNAME Controller     │  │
│          │ Task (concurrent)    │  │
│          └──────────────────────┘  │
│                                     │
└─────────────────────────────────────┘

All tasks run concurrently via Tokio's
thread pool without blocking each other.
</code></pre>
<h2 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h2>
<h3 id="crd-type-hierarchy"><a class="header" href="#crd-type-hierarchy">CRD Type Hierarchy</a></h3>
<pre><code>trait CustomResource (from kube-derive)
    │
    ├─→ Bind9Instance
    │       └─ spec: Bind9InstanceSpec
    │       └─ status: Bind9InstanceStatus
    │
    ├─→ DNSZone
    │       └─ spec: DNSZoneSpec
    │       │        ├─ zone_name: String
    │       │        ├─ instance_selector: LabelSelector
    │       │        └─ soa_record: SOARecord
    │       └─ status: DNSZoneStatus
    │
    ├─→ ARecord
    │       └─ spec: ARecordSpec
    │       └─ status: RecordStatus
    │
    ├─→ TXTRecord
    │       └─ spec: TXTRecordSpec
    │       └─ status: RecordStatus
    │
    └─→ CNAMERecord
            └─ spec: CNAMERecordSpec
            └─ status: RecordStatus
</code></pre>
<h3 id="label-selector"><a class="header" href="#label-selector">Label Selector</a></h3>
<pre><code>LabelSelector
    ├─ match_labels: Option&lt;BTreeMap&lt;String, String&gt;&gt;
    │       └─ "dns-role": "primary"
    │       └─ "environment": "production"
    │
    └─ match_expressions: Option&lt;Vec&lt;LabelSelectorRequirement&gt;&gt;
            ├─ key: "dns-role"
            │  operator: "In"
            │  values: ["primary", "secondary"]
            │
            └─ key: "environment"
               operator: "In"
               values: ["production", "staging"]
</code></pre>
<h2 id="zone-file-generation"><a class="header" href="#zone-file-generation">Zone File Generation</a></h2>
<pre><code>Input: DNSZone resource
    │
    ├─ zone_name: "example.com"
    ├─ soa_record:
    │   ├─ primary_ns: "ns1.example.com."
    │   ├─ admin_email: "admin@example.com"
    │   ├─ serial: 2024010101
    │   ├─ refresh: 3600
    │   ├─ retry: 600
    │   ├─ expire: 604800
    │   └─ negative_ttl: 86400
    │
    └─ ttl: 3600

Processing:
    1. Create file: /etc/bind/zones/db.example.com
    2. Write SOA record header
    3. Add NS record for primary
    4. Set default TTL

Output: /etc/bind/zones/db.example.com
    │
    ├─ $TTL 3600
    ├─ @ IN SOA ns1.example.com. admin.example.com. (
    │       2024010101  ; serial
    │       3600        ; refresh
    │       600         ; retry
    │       604800      ; expire
    │       86400 )     ; minimum
    ├─ @ IN NS ns1.example.com.
    │
    └─ (waiting for record additions)

Then for each ARecord, TXTRecord, etc:
    Append:
    www 300 IN A 192.0.2.1
    @ 3600 IN TXT "v=spf1 include:_spf.example.com ~all"
    blog 300 IN CNAME www.example.com.
</code></pre>
<h2 id="error-handling-strategy"><a class="header" href="#error-handling-strategy">Error Handling Strategy</a></h2>
<pre><code>Reconciliation Error
    │
    ├─→ Log error with context
    ├─→ Update resource status with error condition
    ├─→ Return error to controller
    │
    └─→ Error Policy Handler:
        ├─ If transient (file not found, etc.)
        │   └─ Requeue after 30 seconds (exponential backoff possible)
        │
        └─ If persistent (validation error, etc.)
            └─ Log and skip (manual intervention needed)
</code></pre>
<h2 id="dependencies-flow"><a class="header" href="#dependencies-flow">Dependencies Flow</a></h2>
<pre><code>main.rs
    ├─→ crd.rs (type definitions)
    │   ├─ Bind9Instance
    │   ├─ DNSZone
    │   ├─ ARecord
    │   ├─ TXTRecord
    │   ├─ CNAMERecord
    │   └─ LabelSelector
    │
    ├─→ bind9.rs (zone management)
    │   └─ Bind9Manager
    │
    ├─→ reconcilers/
    │   ├─ dnszone.rs
    │   │   ├─ reconcile_dnszone()
    │   │   ├─ delete_dnszone()
    │   │   └─ update_status()
    │   │
    │   └─ records.rs
    │       ├─ reconcile_a_record()
    │       ├─ reconcile_txt_record()
    │       └─ reconcile_cname_record()
    │
    └─→ Tokio (async runtime)
        └─ kube-rs (Kubernetes client)
</code></pre>
<h2 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h2>
<h3 id="memory-layout"><a class="header" href="#memory-layout">Memory Layout</a></h3>
<pre><code>Rust Controller (typical): ~50MB
    ├─ Binary loaded: ~20MB
    ├─ Tokio runtime: ~10MB
    ├─ In-flight reconciliations: ~5MB
    ├─ Caches/buffers: ~5MB
    └─ Misc overhead: ~10MB

vs Python Operator: ~250MB+
    ├─ Python interpreter: ~50MB
    ├─ Dependencies: ~100MB
    ├─ Kopf framework: ~50MB
    └─ Runtime data: ~50MB+
</code></pre>
<h3 id="latency-profile"><a class="header" href="#latency-profile">Latency Profile</a></h3>
<pre><code>Operation                    Rust         Python
─────────────────────────────────────────────────
Create DNSZone              &lt;100ms       500-1000ms
Add A Record                &lt;50ms        200-500ms
Evaluate label selector     &lt;20ms        100-300ms
Update status              &lt;30ms        150-300ms
Controller startup         &lt;1s          5-10s
Full zone reconciliation   &lt;500ms       2-5s
</code></pre>
<h3 id="scalability-1"><a class="header" href="#scalability-1">Scalability</a></h3>
<pre><code>With Rust Controller:
    • 10 zones: &lt;1s reconciliation
    • 100 zones: &lt;5s reconciliation
    • 1000 records: &lt;10s total reconciliation
    • Handles hundreds of events/sec

vs Python Operator:
    • 10 zones: 5-10s reconciliation
    • 100 zones: 50-100s reconciliation
    • 1000 records: 30-60s total reconciliation
    • Struggles with &gt;10 events/sec
</code></pre>
<h2 id="rbac-requirements"><a class="header" href="#rbac-requirements">RBAC Requirements</a></h2>
<pre><code>cluster-role: bind9-controller
    │
    ├─ [get, list, watch] on dnszones
    ├─ [get, list, watch] on arecords
    ├─ [get, list, watch] on txtrecords
    ├─ [get, list, watch] on cnamerecords
    ├─ [get, list, watch] on bind9instances
    │
    └─ [update, patch] on [*/status]
        └─ (for updating status subresources)
</code></pre>
<h2 id="state-management"><a class="header" href="#state-management">State Management</a></h2>
<pre><code>Kubernetes etcd (Source of Truth)
    │
    ├─→ Store DNSZone resources
    ├─→ Store Record resources
    ├─→ Store status conditions
    │
    └─→ Controller watches via kube-rs
        │
        ├─→ Detects changes
        ├─→ Triggers reconciliation
        ├─→ Generates zone files
        │
        └─→ BIND9 pod reads zone files
            ├─→ Loads into memory
            └─→ Serves DNS queries
</code></pre>
<h2 id="extension-points"><a class="header" href="#extension-points">Extension Points</a></h2>
<pre><code>Current Implementation:
    • DNSZone → Zone file creation
    • ARecord → A record addition
    • TXTRecord → TXT record addition
    • CNAMERecord → CNAME record addition

Future Extensions (easy to add):
    • AAAARecord → IPv6 support
    • MXRecord → Mail record support
    • NSRecord → Nameserver support
    • SRVRecord → Service record support
    • Health endpoints → Liveness/readiness
    • Metrics → Prometheus integration
    • Webhooks → Custom validation
    • Finalizers → Graceful cleanup
</code></pre>
<hr />
<p>This architecture provides a clean, performant, and extensible foundation for managing DNS infrastructure in Kubernetes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rndc-based-architecture"><a class="header" href="#rndc-based-architecture">RNDC-Based Architecture</a></h1>
<p>This page provides a detailed overview of Bindy's new RNDC-based architecture that uses the native BIND9 Remote Name Daemon Control protocol for managing DNS zones and records.</p>
<h2 id="high-level-architecture-1"><a class="header" href="#high-level-architecture-1">High-Level Architecture</a></h2>
<pre><code>┌───────────────────────────────────────────────────────────────────────────┐
│                         Kubernetes Cluster                                │
│                                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐ │
│  │               Custom Resource Definitions (CRDs)                    │ │
│  │                                                                     │ │
│  │  Bind9Cluster (cluster config) → Bind9Instance → DNSZone           │ │
│  │  DNSZone → ARecord, AAAARecord, TXTRecord, MXRecord, etc.          │ │
│  └─────────────────────────────────────────────────────────────────────┘ │
│                                  │                                        │
│                                  │ watches (Kubernetes API)               │
│                                  ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐ │
│  │                    Bindy Controller (Rust)                          │ │
│  │                                                                     │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────────┐ │ │
│  │  │ Bind9Cluster │  │ Bind9Instance│  │      DNSZone             │ │ │
│  │  │  Reconciler  │  │  Reconciler  │  │     Reconciler           │ │ │
│  │  └──────────────┘  └──────────────┘  └──────────────────────────┘ │ │
│  │                                                                     │ │
│  │  ┌──────────────────────────────────────────────────────────────┐  │ │
│  │  │         DNS Record Reconcilers (A, AAAA, TXT, etc.)          │  │ │
│  │  └──────────────────────────────────────────────────────────────┘  │ │
│  │                                                                     │ │
│  │  ┌──────────────────────────────────────────────────────────────┐  │ │
│  │  │              Bind9Manager (RNDC Client)                      │  │ │
│  │  │  • add_zone()     • reload_zone()    • notify_zone()        │  │ │
│  │  │  • delete_zone()  • freeze_zone()    • retransfer_zone()    │  │ │
│  │  │  • zone_status()  • thaw_zone()      • server_status()      │  │ │
│  │  └──────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────┘ │
│                                  │                                        │
│                                  │ RNDC Protocol (TSIG/HMAC-SHA256)       │
│                                  │ Port 953 / TCP                         │
│                                  ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐ │
│  │                    BIND9 Instances (Pods)                           │ │
│  │                                                                     │ │
│  │  ┌────────────────────┐        ┌────────────────────┐              │ │
│  │  │  Primary Instance  │  AXFR  │ Secondary Instance │              │ │
│  │  │  (bind9-primary)   │───────▶│  (bind9-secondary) │              │ │
│  │  │                    │  IXFR  │                    │              │ │
│  │  │  • rndc daemon     │◀───────│  • rndc daemon     │              │ │
│  │  │  • Port 953 (rndc) │        │  • Port 953 (rndc) │              │ │
│  │  │  • Port 53 (DNS)   │        │  • Port 53 (DNS)   │              │ │
│  │  │                    │        │                    │              │ │
│  │  │  Dynamic zones:    │        │  Transferred zones:│              │ │
│  │  │  - example.com     │        │  - example.com     │              │ │
│  │  │  - internal.local  │        │  - internal.local  │              │ │
│  │  └────────────────────┘        └────────────────────┘              │ │
│  │           │                              │                          │ │
│  │           └──────────────┬───────────────┘                          │ │
│  │                          │                                          │ │
│  └──────────────────────────┼──────────────────────────────────────────┘ │
│                             │                                            │
│  ┌──────────────────────────┼──────────────────────────────────────────┐ │
│  │        RNDC Keys (Kubernetes Secrets)                               │ │
│  │  • bind9-primary-rndc-key (HMAC-SHA256)                            │ │
│  │  • bind9-secondary-rndc-key (HMAC-SHA256)                          │ │
│  └─────────────────────────────────────────────────────────────────────┘ │
│                             │                                            │
└─────────────────────────────┼────────────────────────────────────────────┘
                              │
                              │ DNS Queries (UDP/TCP 53)
                              ▼
                   ┌────────────────────┐
                   │   DNS Clients      │
                   │  • Applications    │
                   │  • Services        │
                   │  • External users  │
                   └────────────────────┘
</code></pre>
<h2 id="key-architectural-changes-from-file-based-approach"><a class="header" href="#key-architectural-changes-from-file-based-approach">Key Architectural Changes from File-Based Approach</a></h2>
<h3 id="old-architecture-file-based"><a class="header" href="#old-architecture-file-based">Old Architecture (File-Based)</a></h3>
<ul>
<li>Controller generated zone files</li>
<li>Files written to ConfigMaps</li>
<li>ConfigMaps mounted into BIND9 pods</li>
<li>Manual <code>rndc reload</code> triggered after file changes</li>
<li>Complex synchronization between ConfigMaps and BIND9 state</li>
</ul>
<h3 id="new-architecture-rndc-protocol--cluster-hierarchy"><a class="header" href="#new-architecture-rndc-protocol--cluster-hierarchy">New Architecture (RNDC Protocol + Cluster Hierarchy)</a></h3>
<ul>
<li><strong>Three-tier resource model</strong>: Bind9Cluster → Bind9Instance → DNSZone</li>
<li>Controller uses native RNDC protocol</li>
<li>Direct communication with BIND9 via port 953</li>
<li>Commands executed in real-time: <code>addzone</code>, <code>delzone</code>, <code>reload</code></li>
<li>No file manipulation or ConfigMap management</li>
<li>BIND9 manages zone files internally with dynamic updates</li>
<li>Atomic operations with immediate feedback</li>
<li>Cluster-level config sharing (version, TSIG keys, ACLs)</li>
</ul>
<h2 id="three-tier-resource-model"><a class="header" href="#three-tier-resource-model">Three-Tier Resource Model</a></h2>
<h3 id="1-bind9cluster-cluster-configuration"><a class="header" href="#1-bind9cluster-cluster-configuration">1. Bind9Cluster (Cluster Configuration)</a></h3>
<p>Defines shared configuration for a logical group of BIND9 instances:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: production-dns
spec:
  version: "9.18"
  config:
    recursion: false
    dnssec:
      enabled: true
      validation: true
    allowQuery:
      - any
    allowTransfer:
      - 10.0.0.0/8
  tsigKeys:
    - name: transfer-key
      algorithm: hmac-sha256
      secret: base64-encoded-key
  acls:
    internal:
      - 10.0.0.0/8
      - 172.16.0.0/12
</code></pre>
<h3 id="2-bind9instance-instance-deployment"><a class="header" href="#2-bind9instance-instance-deployment">2. Bind9Instance (Instance Deployment)</a></h3>
<p>References a cluster and deploys BIND9 pods:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: dns-primary
spec:
  clusterRef: production-dns  # References Bind9Cluster
  role: primary
  replicas: 2
</code></pre>
<p>The instance inherits configuration from the cluster but can override specific settings.</p>
<h3 id="3-dnszone-zone-definition"><a class="header" href="#3-dnszone-zone-definition">3. DNSZone (Zone Definition)</a></h3>
<p>References an instance and creates zones via RNDC:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
spec:
  zoneName: example.com
  clusterRef: dns-primary  # References Bind9Instance
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin.example.com.
    serial: 2024010101
</code></pre>
<h2 id="rndc-protocol-communication"><a class="header" href="#rndc-protocol-communication">RNDC Protocol Communication</a></h2>
<pre><code>┌──────────────────────┐                 ┌──────────────────────┐
│  Bindy Controller    │                 │   BIND9 Instance     │
│                      │                 │   (Primary)          │
│  ┌────────────────┐  │                 │                      │
│  │ Bind9Manager   │  │                 │  ┌────────────────┐  │
│  │                │  │   TCP Port 953  │  │  rndc daemon   │  │
│  │ RndcClient     │──┼────────────────▶│  │                │  │
│  │  • Server URL  │  │  TSIG Auth      │  │  Validates:    │  │
│  │  • Algorithm   │  │  HMAC-SHA256    │  │  • Key name    │  │
│  │  • Secret Key  │  │                 │  │  • Signature   │  │
│  │                │  │                 │  │  • Timestamp   │  │
│  └────────────────┘  │                 │  └────────────────┘  │
│         │            │                 │         │            │
│         │ Commands:  │                 │         │            │
│         │            │                 │         ▼            │
│    addzone zone {    │                 │  ┌────────────────┐  │
│      type master;    │                 │  │ BIND9 named    │  │
│      file "x.zone";  │────────────────▶│  │                │  │
│    };                │                 │  │ • Creates zone │  │
│                      │◀────────────────│  │ • Loads into   │  │
│    Success/Error     │    Response     │  │   memory       │  │
│                      │                 │  │ • Writes file  │  │
│                      │                 │  └────────────────┘  │
└──────────────────────┘                 └──────────────────────┘
</code></pre>
<h2 id="rndc-authentication-flow"><a class="header" href="#rndc-authentication-flow">RNDC Authentication Flow</a></h2>
<pre><code>┌────────────────────────────────────────────────────────────────┐
│  1. Controller Retrieves RNDC Key from Kubernetes Secret      │
│                                                                │
│  Secret: bind9-primary-rndc-key                              │
│    data:                                                      │
│      key-name: "bind9-primary"                               │
│      algorithm: "hmac-sha256"                                │
│      secret: "base64-encoded-256-bit-key"                    │
└────────────────────────────────────────────────────────────────┘
                         │
                         ▼
┌────────────────────────────────────────────────────────────────┐
│  2. Create RndcClient Instance                                │
│                                                                │
│  let client = RndcClient::new(                                │
│      "bind9-primary.dns-system.svc.cluster.local:953",       │
│      "hmac-sha256",                                           │
│      "base64-secret-key"                                      │
│  );                                                           │
└────────────────────────────────────────────────────────────────┘
                         │
                         ▼
┌────────────────────────────────────────────────────────────────┐
│  3. Execute RNDC Command with TSIG Authentication             │
│                                                                │
│  TSIG Signature = HMAC-SHA256(                                │
│      key: secret,                                             │
│      data: command + timestamp + nonce                        │
│  )                                                            │
│                                                                │
│  Request packet:                                              │
│    • Command: "addzone example.com { type master; ... }"     │
│    • TSIG record with signature                              │
│    • Timestamp                                                │
└────────────────────────────────────────────────────────────────┘
                         │
                         ▼
┌────────────────────────────────────────────────────────────────┐
│  4. BIND9 Validates Request                                   │
│                                                                │
│  • Looks up key "bind9-primary" in rndc.key file             │
│  • Verifies HMAC-SHA256 signature matches                    │
│  • Checks timestamp is within acceptable window              │
│  • Executes command if valid                                 │
│  • Returns success/error with TSIG-signed response           │
└────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="data-flow-zone-creation"><a class="header" href="#data-flow-zone-creation">Data Flow: Zone Creation</a></h2>
<pre><code>User creates DNSZone resource
    │
    │ kubectl apply -f dnszone.yaml
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Kubernetes API Server stores DNSZone in etcd            │
└─────────────────────────────────────────────────────────┘
    │
    │ Watch event
    ▼
┌─────────────────────────────────────────────────────────┐
│ Bindy Controller receives event                         │
│   • DNSZone watcher triggers                            │
│   • Event: Applied(dnszone)                             │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ reconcile_dnszone() called                              │
│   1. Extract namespace and name                         │
│   2. Get zone spec (zone_name, cluster_ref, etc.)      │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Find PRIMARY pod for cluster                            │
│   • List pods with labels:                              │
│     app=bind9, instance={cluster_ref}                   │
│   • Select first running pod                            │
│   • Build server address:                               │
│     "{cluster_ref}.{namespace}.svc.cluster.local:953"   │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Load RNDC key from Secret                               │
│   • Secret name: "{cluster_ref}-rndc-key"              │
│   • Parse key-name, algorithm, secret                   │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Execute RNDC addzone command                            │
│   zone_manager.add_zone(                                │
│       zone_name: "example.com",                         │
│       zone_type: "master",                              │
│       zone_file: "/var/lib/bind/example.com.zone",     │
│       server: "bind9-primary...:953",                   │
│       key_data: RndcKeyData { ... }                     │
│   )                                                     │
└─────────────────────────────────────────────────────────┘
    │
    │ RNDC Protocol (Port 953)
    ▼
┌─────────────────────────────────────────────────────────┐
│ BIND9 Instance executes command                         │
│   • Creates zone configuration                          │
│   • Allocates memory for zone                           │
│   • Creates zone file /var/lib/bind/example.com.zone   │
│   • Loads zone into memory                              │
│   • Starts serving DNS queries for zone                 │
│   • Returns success response                            │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Update DNSZone status                                   │
│   status:                                               │
│     conditions:                                         │
│       - type: Ready                                     │
│         status: "True"                                  │
│         message: "Zone created for cluster: ..."        │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="data-flow-record-addition"><a class="header" href="#data-flow-record-addition">Data Flow: Record Addition</a></h2>
<pre><code>User creates ARecord resource
    │
    │ kubectl apply -f arecord.yaml
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Kubernetes API Server stores ARecord in etcd            │
└─────────────────────────────────────────────────────────┘
    │
    │ Watch event
    ▼
┌─────────────────────────────────────────────────────────┐
│ Bindy Controller receives event                         │
│   • ARecord watcher triggers                            │
│   • Event: Applied(arecord)                             │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ reconcile_a_record() called                             │
│   1. Extract namespace and name                         │
│   2. Get spec (zone, name, ipv4_address, ttl)          │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Find cluster from zone                                   │
│   • List DNSZone resources in namespace                 │
│   • Find zone matching spec.zone                        │
│   • Extract zone.spec.cluster_ref                       │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Load RNDC key and build server address                  │
│   • Load "{cluster_ref}-rndc-key" Secret               │
│   • Server: "{cluster_ref}.{namespace}.svc:953"        │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Add record via RNDC (PLACEHOLDER - Future nsupdate)     │
│   zone_manager.add_a_record(                            │
│       zone: "example.com",                              │
│       name: "www",                                      │
│       ipv4: "192.0.2.1",                               │
│       ttl: Some(300),                                   │
│       server: "bind9-primary...:953",                   │
│       key_data: RndcKeyData { ... }                     │
│   )                                                     │
│                                                         │
│ NOTE: Currently logs intent. Full implementation will   │
│       use nsupdate protocol for dynamic DNS updates.    │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Update ARecord status                                   │
│   status:                                               │
│     conditions:                                         │
│       - type: Ready                                     │
│         status: "True"                                  │
│         message: "A record created"                     │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="rndc-commands-supported"><a class="header" href="#rndc-commands-supported">RNDC Commands Supported</a></h2>
<p>The Bind9Manager provides the following RNDC operations:</p>
<h3 id="zone-management"><a class="header" href="#zone-management">Zone Management</a></h3>
<pre><code>┌────────────────────┬─────────────────────────────────────────┐
│ Operation          │ RNDC Command                            │
├────────────────────┼─────────────────────────────────────────┤
│ add_zone()         │ addzone &lt;zone&gt; { type &lt;type&gt;;           │
│                    │                   file "&lt;file&gt;"; };     │
│                    │                                         │
│ delete_zone()      │ delzone &lt;zone&gt;                          │
│                    │                                         │
│ reload_zone()      │ reload &lt;zone&gt;                           │
│                    │                                         │
│ reload_all_zones() │ reload                                  │
│                    │                                         │
│ retransfer_zone()  │ retransfer &lt;zone&gt;                       │
│                    │                                         │
│ notify_zone()      │ notify &lt;zone&gt;                           │
│                    │                                         │
│ freeze_zone()      │ freeze &lt;zone&gt;                           │
│                    │                                         │
│ thaw_zone()        │ thaw &lt;zone&gt;                             │
│                    │                                         │
│ zone_status()      │ zonestatus &lt;zone&gt;                       │
│                    │                                         │
│ server_status()    │ status                                  │
└────────────────────┴─────────────────────────────────────────┘
</code></pre>
<h3 id="record-management-planned"><a class="header" href="#record-management-planned">Record Management (Planned)</a></h3>
<pre><code>Currently implemented as placeholders:
  • add_a_record()      (will use nsupdate protocol)
  • add_aaaa_record()   (will use nsupdate protocol)
  • add_txt_record()    (will use nsupdate protocol)
  • add_cname_record()  (will use nsupdate protocol)
  • add_mx_record()     (will use nsupdate protocol)
  • add_ns_record()     (will use nsupdate protocol)
  • add_srv_record()    (will use nsupdate protocol)
  • add_caa_record()    (will use nsupdate protocol)

Note: RNDC protocol doesn't support individual record operations.
These will be implemented using the nsupdate protocol for dynamic
DNS updates, or via zone file manipulation + reload.
</code></pre>
<h2 id="pod-discovery-and-networking"><a class="header" href="#pod-discovery-and-networking">Pod Discovery and Networking</a></h2>
<pre><code>┌────────────────────────────────────────────────────────────┐
│ Controller discovers BIND9 pods using labels:              │
│                                                            │
│   Pod labels:                                             │
│     app: bind9                                            │
│     instance: {cluster_ref}                               │
│                                                            │
│   Controller searches:                                    │
│     List pods where app=bind9 AND instance={cluster_ref}  │
│                                                            │
│   Service DNS:                                            │
│     {cluster_ref}.{namespace}.svc.cluster.local:953      │
│                                                            │
│   Example:                                                │
│     bind9-primary.dns-system.svc.cluster.local:953       │
└────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="zone-transfers-axfrixfr"><a class="header" href="#zone-transfers-axfrixfr">Zone Transfers (AXFR/IXFR)</a></h2>
<pre><code>Primary Instance                    Secondary Instance
┌─────────────────┐                ┌─────────────────┐
│ example.com     │                │                 │
│ Serial: 2024010│                │                 │
│                 │   1. NOTIFY    │                 │
│                 │───────────────▶│                 │
│                 │                │                 │
│                 │   2. SOA Query │                 │
│                 │◀───────────────│  Checks serial  │
│                 │                │                 │
│                 │   3. AXFR/IXFR │                 │
│                 │◀───────────────│  Serial outdated│
│                 │                │                 │
│  Sends full     │   Zone data    │                 │
│  zone (AXFR) or │───────────────▶│  Updates zone   │
│  delta (IXFR)   │                │  Serial: 2024010│
│                 │                │                 │
└─────────────────┘                └─────────────────┘

Triggered by:
  • zone_manager.notify_zone()
  • zone_manager.retransfer_zone()
  • BIND9 automatic refresh timers (SOA refresh value)
</code></pre>
<h2 id="components-deep-dive"><a class="header" href="#components-deep-dive">Components Deep Dive</a></h2>
<h3 id="1-bind9manager"><a class="header" href="#1-bind9manager">1. Bind9Manager</a></h3>
<p>Rust struct that wraps the <code>rndc</code> crate for BIND9 management:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Bind9Manager;

impl Bind9Manager {
    pub fn new() -&gt; Self { Self }

    // RNDC key generation
    pub fn generate_rndc_key() -&gt; RndcKeyData { ... }
    pub fn create_rndc_secret_data(key_data: &amp;RndcKeyData) -&gt; BTreeMap&lt;String, String&gt; { ... }
    pub fn parse_rndc_secret_data(data: &amp;BTreeMap&lt;String, Vec&lt;u8&gt;&gt;) -&gt; Result&lt;RndcKeyData&gt; { ... }

    // Core RNDC operations
    async fn exec_rndc_command(&amp;self, server: &amp;str, key_data: &amp;RndcKeyData, command: &amp;str) -&gt; Result&lt;String&gt; { ... }

    // Zone management
    pub async fn add_zone(&amp;self, zone_name: &amp;str, zone_type: &amp;str, zone_file: &amp;str, server: &amp;str, key_data: &amp;RndcKeyData) -&gt; Result&lt;()&gt; { ... }
    pub async fn delete_zone(&amp;self, zone_name: &amp;str, server: &amp;str, key_data: &amp;RndcKeyData) -&gt; Result&lt;()&gt; { ... }
    pub async fn reload_zone(&amp;self, zone_name: &amp;str, server: &amp;str, key_data: &amp;RndcKeyData) -&gt; Result&lt;()&gt; { ... }
    pub async fn notify_zone(&amp;self, zone_name: &amp;str, server: &amp;str, key_data: &amp;RndcKeyData) -&gt; Result&lt;()&gt; { ... }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-rndckeydata"><a class="header" href="#2-rndckeydata">2. RndcKeyData</a></h3>
<p>Struct for RNDC authentication:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RndcKeyData {
    pub name: String,      // Key name (e.g., "bind9-primary")
    pub algorithm: String, // HMAC algorithm (e.g., "hmac-sha256")
    pub secret: String,    // Base64-encoded secret key
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-reconcilers"><a class="header" href="#3-reconcilers">3. Reconcilers</a></h3>
<p>Zone reconciler using RNDC:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn reconcile_dnszone(
    client: Client,
    dnszone: DNSZone,
    zone_manager: &amp;Bind9Manager,
) -&gt; Result&lt;()&gt; {
    // 1. Find PRIMARY pod
    let primary_pod = find_primary_pod(&amp;client, &amp;namespace, &amp;cluster_ref).await?;

    // 2. Load RNDC key
    let key_data = load_rndc_key(&amp;client, &amp;namespace, &amp;cluster_ref).await?;

    // 3. Build server address
    let server = format!("{}.{}.svc.cluster.local:953", cluster_ref, namespace);

    // 4. Add zone via RNDC
    zone_manager.add_zone(&amp;zone_name, "master", &amp;zone_file, &amp;server, &amp;key_data).await?;

    // 5. Update status
    update_status(&amp;client, &amp;dnszone, "Ready", "True", "Zone created").await?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-architecture-1"><a class="header" href="#security-architecture-1">Security Architecture</a></h2>
<h3 id="tsig-authentication-1"><a class="header" href="#tsig-authentication-1">TSIG Authentication</a></h3>
<pre><code>┌────────────────────────────────────────────────────────────┐
│ TSIG (Transaction Signature) provides:                     │
│                                                            │
│  1. Authentication - Verifies command source               │
│  2. Integrity - Prevents command tampering                 │
│  3. Replay protection - Timestamp validation               │
│                                                            │
│ Algorithm: HMAC-SHA256 (256-bit keys)                     │
│ Key Storage: Kubernetes Secrets (base64-encoded)          │
│ Key Generation: Random 256-bit keys per instance          │
└────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="network-security"><a class="header" href="#network-security">Network Security</a></h3>
<pre><code>┌────────────────────────────────────────────────────────────┐
│ • RNDC traffic on port 953/TCP (not exposed externally)   │
│ • DNS queries on port 53/UDP+TCP (exposed via Service)    │
│ • All RNDC communication within cluster network           │
│ • No external RNDC access (ClusterIP services only)       │
│ • NetworkPolicies can restrict RNDC access to controller  │
└────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="rbac-requirements-1"><a class="header" href="#rbac-requirements-1">RBAC Requirements</a></h3>
<pre><code class="language-yaml"># Controller needs access to:
- Secrets (get, list) - for RNDC keys
- Pods (get, list) - for pod discovery
- Services (get, list) - for DNS resolution
- DNSZone, ARecord, etc. (get, list, watch, update status)
</code></pre>
<h2 id="performance-characteristics-2"><a class="header" href="#performance-characteristics-2">Performance Characteristics</a></h2>
<h3 id="latency"><a class="header" href="#latency">Latency</a></h3>
<pre><code>Operation                    Old (File-based)    New (RNDC)
─────────────────────────────────────────────────────────────
Create DNSZone              2-5 seconds          &lt;500ms
Add DNS Record              1-3 seconds          &lt;200ms
Delete DNSZone              2-4 seconds          &lt;500ms
Zone reload                 1-2 seconds          &lt;300ms
Status check                N/A                  &lt;100ms
</code></pre>
<h3 id="benefits-of-rndc-protocol"><a class="header" href="#benefits-of-rndc-protocol">Benefits of RNDC Protocol</a></h3>
<pre><code>✓ Atomic operations - Commands succeed or fail atomically
✓ Real-time feedback - Immediate success/error responses
✓ No ConfigMap overhead - No intermediate Kubernetes resources
✓ Direct control - Native BIND9 management interface
✓ Better error messages - BIND9 provides detailed errors
✓ Zone status queries - Can check zone state anytime
✓ Freeze/thaw support - Control dynamic updates precisely
✓ Notify support - Trigger zone transfers on demand
</code></pre>
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<h3 id="1-nsupdate-protocol-integration"><a class="header" href="#1-nsupdate-protocol-integration">1. nsupdate Protocol Integration</a></h3>
<pre><code>Implement dynamic DNS updates for individual records:
  • Use nsupdate protocol alongside RNDC
  • Add/update/delete individual A, AAAA, TXT, etc. records
  • No full zone reload needed for record changes
  • Even lower latency for record operations
</code></pre>
<h3 id="2-zone-transfer-monitoring"><a class="header" href="#2-zone-transfer-monitoring">2. Zone Transfer Monitoring</a></h3>
<pre><code>Monitor AXFR/IXFR operations:
  • Track transfer status
  • Report transfer errors
  • Automatic retry on failures
</code></pre>
<h3 id="3-health-checks"><a class="header" href="#3-health-checks">3. Health Checks</a></h3>
<pre><code>Periodic health checks using RNDC:
  • server_status() - overall server health
  • zone_status() - per-zone health
  • Update CRD status with health information
</code></pre>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><a href="concepts/../development/bind9-integration.html">BIND9 Integration Deep Dive</a> - Implementation details</li>
<li><a href="concepts/../reference/dnszone-spec.html">DNSZone Spec</a> - DNSZone resource reference</li>
<li><a href="concepts/../operations/configuration.html">Operations Guide</a> - Production configuration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-resource-definitions"><a class="header" href="#custom-resource-definitions">Custom Resource Definitions</a></h1>
<p>Bindy extends Kubernetes with these Custom Resource Definitions (CRDs).</p>
<h2 id="infrastructure-crds"><a class="header" href="#infrastructure-crds">Infrastructure CRDs</a></h2>
<h3 id="bind9cluster"><a class="header" href="#bind9cluster">Bind9Cluster</a></h3>
<p>Represents cluster-level configuration shared across multiple BIND9 instances.</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: production-dns
  namespace: dns-system
spec:
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.0.0/8"
    dnssec:
      enabled: true
  tsigKeys:
    - name: transfer-key
      algorithm: hmac-sha256
      secret: "base64-encoded-secret"
</code></pre>
<p>Learn more: <a href="concepts/./bind9cluster.html">Bind9Cluster concept documentation</a></p>
<h3 id="bind9instance"><a class="header" href="#bind9instance">Bind9Instance</a></h3>
<p>Represents a BIND9 DNS server instance that references a Bind9Cluster.</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  namespace: dns-system
spec:
  clusterRef: production-dns  # References Bind9Cluster
  replicas: 2
</code></pre>
<p><a href="concepts/./bind9instance.html">Learn more about Bind9Instance</a></p>
<h2 id="dns-crds"><a class="header" href="#dns-crds">DNS CRDs</a></h2>
<h3 id="dnszone"><a class="header" href="#dnszone">DNSZone</a></h3>
<p>Defines a DNS zone with SOA record and references a Bind9Instance.</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: primary-dns  # References Bind9Instance
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin.example.com.  # Note: @ replaced with .
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
  ttl: 3600
</code></pre>
<p><a href="concepts/./dnszone.html">Learn more about DNSZone</a></p>
<h3 id="dns-record-types"><a class="header" href="#dns-record-types">DNS Record Types</a></h3>
<p>Bindy supports all common DNS record types:</p>
<ul>
<li><strong>ARecord</strong> - IPv4 addresses</li>
<li><strong>AAAARecord</strong> - IPv6 addresses</li>
<li><strong>CNAMERecord</strong> - Canonical name aliases</li>
<li><strong>MXRecord</strong> - Mail exchange</li>
<li><strong>TXTRecord</strong> - Text records (SPF, DKIM, etc.)</li>
<li><strong>NSRecord</strong> - Nameserver delegation</li>
<li><strong>SRVRecord</strong> - Service discovery</li>
<li><strong>CAARecord</strong> - Certificate authority authorization</li>
</ul>
<p><a href="concepts/./records.html">Learn more about DNS Records</a></p>
<h2 id="resource-hierarchy"><a class="header" href="#resource-hierarchy">Resource Hierarchy</a></h2>
<p>The three-tier resource model:</p>
<pre><code>Bind9Cluster (cluster config)
    ↑
    │ referenced by clusterRef
    │
Bind9Instance (instance deployment)
    ↑
    │ referenced by clusterRef
    │
DNSZone (zone definition)
    ↑
    │ referenced by zone field
    │
DNS Records (A, CNAME, MX, etc.)
</code></pre>
<h2 id="common-fields"><a class="header" href="#common-fields">Common Fields</a></h2>
<p>All Bindy CRDs share these common fields:</p>
<h3 id="metadata"><a class="header" href="#metadata">Metadata</a></h3>
<pre><code class="language-yaml">metadata:
  name: resource-name
  namespace: dns-system
  labels:
    key: value
  annotations:
    key: value
</code></pre>
<h3 id="status-subresource"><a class="header" href="#status-subresource">Status Subresource</a></h3>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      reason: Synchronized
      message: Resource is synchronized
      lastTransitionTime: "2024-01-01T00:00:00Z"
  observedGeneration: 1
</code></pre>
<h2 id="api-group-and-versions"><a class="header" href="#api-group-and-versions">API Group and Versions</a></h2>
<p>All Bindy CRDs belong to the <code>bindy.firestoned.io</code> API group:</p>
<ul>
<li><strong>Current version</strong>: <code>v1alpha1</code></li>
<li><strong>API stability</strong>: Alpha (subject to breaking changes)</li>
</ul>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li><a href="concepts/./bind9instance.html">Bind9Instance Details</a></li>
<li><a href="concepts/./dnszone.html">DNSZone Details</a></li>
<li><a href="concepts/./records.html">DNS Record Details</a></li>
<li><a href="concepts/./architecture-rndc.html">RNDC-Based Architecture</a></li>
<li><a href="concepts/../reference/api.html">API Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bind9cluster-1"><a class="header" href="#bind9cluster-1">Bind9Cluster</a></h1>
<p>The <code>Bind9Cluster</code> resource represents a logical DNS cluster - a collection of related BIND9 instances with shared configuration.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>A Bind9Cluster defines cluster-level configuration that can be inherited by multiple Bind9Instance resources:</p>
<ul>
<li>Shared BIND9 version and container image</li>
<li>Common configuration (recursion, ACLs, etc.)</li>
<li>Custom ConfigMap references for BIND9 configuration files</li>
<li>TSIG keys for authenticated zone transfers</li>
<li>Access Control Lists (ACLs)</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: production-dns
  namespace: dns-system
spec:
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.0.0/8"
  tsigKeys:
    - name: transfer-key
      algorithm: hmac-sha256
      secret: "base64-encoded-secret"
  acls:
    internal:
      - "10.0.0.0/8"
      - "172.16.0.0/12"
    external:
      - "0.0.0.0/0"
status:
  conditions:
    - type: Ready
      status: "True"
      reason: ClusterConfigured
      message: "Cluster configured successfully"
  instanceCount: 4
  readyInstances: 4
</code></pre>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<h3 id="optional-fields"><a class="header" href="#optional-fields">Optional Fields</a></h3>
<ul>
<li><code>spec.version</code> - BIND9 version for all instances in the cluster</li>
<li><code>spec.image</code> - Container image configuration for all instances
<ul>
<li><code>image</code> - Full container image reference (registry/repo:tag)</li>
<li><code>imagePullPolicy</code> - Image pull policy (Always, IfNotPresent, Never)</li>
<li><code>imagePullSecrets</code> - List of secret names for private registries</li>
</ul>
</li>
<li><code>spec.configMapRefs</code> - Custom ConfigMap references for BIND9 configuration
<ul>
<li><code>namedConf</code> - Name of ConfigMap containing named.conf</li>
<li><code>namedConfOptions</code> - Name of ConfigMap containing named.conf.options</li>
</ul>
</li>
<li><code>spec.config</code> - Shared BIND9 configuration
<ul>
<li><code>recursion</code> - Enable/disable recursion globally</li>
<li><code>allowQuery</code> - List of CIDR ranges allowed to query</li>
<li><code>allowTransfer</code> - List of CIDR ranges allowed zone transfers</li>
<li><code>dnssec</code> - DNSSEC configuration</li>
<li><code>forwarders</code> - DNS forwarders</li>
<li><code>listenOn</code> - IPv4 addresses to listen on</li>
<li><code>listenOnV6</code> - IPv6 addresses to listen on</li>
</ul>
</li>
<li><code>spec.tsigKeys</code> - TSIG keys for authenticated zone transfers
<ul>
<li><code>name</code> - Key name</li>
<li><code>algorithm</code> - HMAC algorithm (hmac-sha256, hmac-sha512, etc.)</li>
<li><code>secret</code> - Base64-encoded shared secret</li>
</ul>
</li>
<li><code>spec.acls</code> - Named ACL definitions that instances can reference</li>
</ul>
<h2 id="cluster-vs-instance"><a class="header" href="#cluster-vs-instance">Cluster vs Instance</a></h2>
<p>The relationship between Bind9Cluster and Bind9Instance:</p>
<pre><code class="language-yaml"># Cluster defines shared configuration
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: prod-cluster
spec:
  version: "9.18"
  config:
    recursion: false
  acls:
    internal:
      - "10.0.0.0/8"

---
# Instance references the cluster
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  labels:
    cluster: prod-cluster
    dns-role: primary
spec:
  clusterRef: prod-cluster
  replicas: 2
  # Instance-specific config can override cluster defaults
  config:
    allowQuery:
      - acl:internal  # Reference the cluster's ACL
</code></pre>
<h2 id="tsig-keys"><a class="header" href="#tsig-keys">TSIG Keys</a></h2>
<p>TSIG (Transaction SIGnature) keys provide authenticated zone transfers:</p>
<pre><code class="language-yaml">spec:
  tsigKeys:
    - name: primary-secondary-key
      algorithm: hmac-sha256
      secret: "K8x...base64...=="
    - name: backup-key
      algorithm: hmac-sha512
      secret: "L9y...base64...=="
</code></pre>
<p>These keys are used by:</p>
<ul>
<li>Primary instances for authenticated zone transfers to secondaries</li>
<li>Secondary instances to authenticate when requesting zone transfers</li>
<li>Dynamic DNS updates (if enabled)</li>
</ul>
<h2 id="access-control-lists-acls"><a class="header" href="#access-control-lists-acls">Access Control Lists (ACLs)</a></h2>
<p>ACLs define reusable network access policies:</p>
<pre><code class="language-yaml">spec:
  acls:
    # Internal networks
    internal:
      - "10.0.0.0/8"
      - "172.16.0.0/12"
      - "192.168.0.0/16"

    # External clients
    external:
      - "0.0.0.0/0"

    # Secondary DNS servers
    secondaries:
      - "10.0.1.10"
      - "10.0.2.10"
      - "10.0.3.10"
</code></pre>
<p>Instances can then reference these ACLs:</p>
<pre><code class="language-yaml"># In Bind9Instance spec
config:
  allowQuery:
    - acl:external
  allowTransfer:
    - acl:secondaries
</code></pre>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>The controller updates status to reflect cluster state:</p>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      reason: ClusterConfigured
      message: "Cluster configured with 4 instances"
  instanceCount: 4      # Total instances in cluster
  readyInstances: 4     # Instances reporting ready
  observedGeneration: 1
</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="multi-region-dns-cluster"><a class="header" href="#multi-region-dns-cluster">Multi-Region DNS Cluster</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: global-dns
spec:
  version: "9.18"
  config:
    recursion: false
    dnssec:
      enabled: true
      validation: true
  tsigKeys:
    - name: region-sync-key
      algorithm: hmac-sha256
      secret: "..."
  acls:
    us-east:
      - "10.1.0.0/16"
    us-west:
      - "10.2.0.0/16"
    eu-west:
      - "10.3.0.0/16"
</code></pre>
<h3 id="development-cluster"><a class="header" href="#development-cluster">Development Cluster</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: dev-dns
  namespace: dns-system
spec:
  version: "9.18"
  config:
    recursion: true  # Allow recursion for dev
    allowQuery:
      - "0.0.0.0/0"
    forwarders:
      - "8.8.8.8"
      - "8.8.4.4"
  acls:
    dev-team:
      - "192.168.1.0/24"
</code></pre>
<h3 id="custom-image-cluster"><a class="header" href="#custom-image-cluster">Custom Image Cluster</a></h3>
<p>Use a custom container image across all instances:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: custom-image-cluster
  namespace: dns-system
spec:
  version: "9.18"
  # Custom image with organization-specific patches
  image:
    image: "my-registry.example.com/bind9:9.18-custom"
    imagePullPolicy: "IfNotPresent"
    imagePullSecrets:
      - docker-registry-secret
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
</code></pre>
<p>All Bind9Instances referencing this cluster will inherit the custom image configuration unless they override it.</p>
<h3 id="custom-configmap-cluster"><a class="header" href="#custom-configmap-cluster">Custom ConfigMap Cluster</a></h3>
<p>Share custom BIND9 configuration files across all instances:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: shared-bind9-options
  namespace: dns-system
data:
  named.conf.options: |
    options {
      directory "/var/cache/bind";
      recursion no;
      allow-query { any; };
      allow-transfer { 10.0.2.0/24; };
      dnssec-validation auto;

      # Custom logging
      querylog yes;

      # Rate limiting
      rate-limit {
        responses-per-second 10;
        window 5;
      };
    };
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: custom-config-cluster
  namespace: dns-system
spec:
  version: "9.18"
  configMapRefs:
    namedConfOptions: "shared-bind9-options"
</code></pre>
<p>All instances in this cluster will use the custom configuration, while named.conf is auto-generated.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>One cluster per environment</strong> - Separate clusters for production, staging, development</li>
<li><strong>Consistent TSIG keys</strong> - Use the same keys across all instances in a cluster</li>
<li><strong>Version pinning</strong> - Specify exact BIND9 versions to avoid unexpected updates</li>
<li><strong>ACL organization</strong> - Define ACLs at cluster level for consistency</li>
<li><strong>DNSSEC</strong> - Enable DNSSEC at the cluster level for all zones</li>
<li><strong>Image management</strong> - Define container images at cluster level for consistency; override at instance level only for canary testing</li>
<li><strong>ConfigMap strategy</strong> - Use cluster-level ConfigMaps for shared configuration; use instance-level ConfigMaps for instance-specific customizations</li>
<li><strong>Image pull secrets</strong> - Configure imagePullSecrets at cluster level to avoid duplicating secrets across instances</li>
</ol>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li><a href="concepts/./bind9instance.html">Bind9Instance</a> - Learn about DNS instances</li>
<li><a href="concepts/./dnszone.html">DNSZone</a> - Learn about DNS zones</li>
<li><a href="concepts/../guide/multi-region.html">Multi-Region Setup</a> - Deploy across multiple regions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bind9instance-1"><a class="header" href="#bind9instance-1">Bind9Instance</a></h1>
<p>The <code>Bind9Instance</code> resource represents a BIND9 DNS server deployment in Kubernetes.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>A Bind9Instance defines:</p>
<ul>
<li>Number of replicas</li>
<li>BIND9 version and container image</li>
<li>Configuration options (or custom ConfigMap references)</li>
<li>Network settings</li>
<li>Labels for targeting</li>
<li>Optional cluster reference for inheriting shared configuration</li>
</ul>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  namespace: dns-system
  labels:
    dns-role: primary
    environment: production
    datacenter: us-east
spec:
  replicas: 2
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.0.0/8"
status:
  conditions:
    - type: Ready
      status: "True"
      reason: Running
      message: "2 replicas running"
  readyReplicas: 2
  currentVersion: "9.18"
</code></pre>
<h2 id="specification-1"><a class="header" href="#specification-1">Specification</a></h2>
<h3 id="optional-fields-1"><a class="header" href="#optional-fields-1">Optional Fields</a></h3>
<p>All fields are optional. If no <code>clusterRef</code> is specified, default values are used.</p>
<ul>
<li><code>spec.clusterRef</code> - Reference to a Bind9Cluster for inheriting shared configuration</li>
<li><code>spec.replicas</code> - Number of BIND9 pods (default: 1)</li>
<li><code>spec.version</code> - BIND9 version to deploy (default: "9.18", or inherit from cluster)</li>
<li><code>spec.image</code> - Container image configuration (inherits from cluster if not specified)
<ul>
<li><code>image</code> - Full container image reference</li>
<li><code>imagePullPolicy</code> - Image pull policy (Always, IfNotPresent, Never)</li>
<li><code>imagePullSecrets</code> - List of secret names for private registries</li>
</ul>
</li>
<li><code>spec.configMapRefs</code> - Custom ConfigMap references (inherits from cluster if not specified)
<ul>
<li><code>namedConf</code> - ConfigMap name containing named.conf</li>
<li><code>namedConfOptions</code> - ConfigMap name containing named.conf.options</li>
</ul>
</li>
<li><code>spec.config</code> - BIND9 configuration options (inherits from cluster if not specified)
<ul>
<li><code>recursion</code> - Enable/disable recursion (default: false)</li>
<li><code>allowQuery</code> - List of CIDR ranges allowed to query</li>
<li><code>allowTransfer</code> - List of CIDR ranges allowed to transfer zones</li>
<li><code>dnssec</code> - DNSSEC configuration</li>
<li><code>forwarders</code> - DNS forwarders</li>
<li><code>listenOn</code> - IPv4 addresses to listen on</li>
<li><code>listenOnV6</code> - IPv6 addresses to listen on</li>
</ul>
</li>
</ul>
<h3 id="configuration-inheritance"><a class="header" href="#configuration-inheritance">Configuration Inheritance</a></h3>
<p>When a Bind9Instance references a Bind9Cluster via <code>clusterRef</code>:</p>
<ol>
<li>Instance-level settings take precedence</li>
<li>If not specified at instance level, cluster settings are used</li>
<li>If not specified at cluster level, defaults are used</li>
</ol>
<h2 id="labels-and-selectors"><a class="header" href="#labels-and-selectors">Labels and Selectors</a></h2>
<p>Labels on Bind9Instance resources are used by DNSZone resources to target specific instances:</p>
<pre><code class="language-yaml"># Instance with labels
metadata:
  labels:
    dns-role: primary
    region: us-east
    environment: production

# Zone selecting this instance
spec:
  instanceSelector:
    matchLabels:
      dns-role: primary
      region: us-east
</code></pre>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>The controller updates status to reflect the instance state:</p>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      reason: Running
  readyReplicas: 2
  currentVersion: "9.18"
</code></pre>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="primary-dns-instance"><a class="header" href="#primary-dns-instance">Primary DNS Instance</a></h3>
<pre><code class="language-yaml">metadata:
  labels:
    dns-role: primary
spec:
  replicas: 2
  config:
    allowTransfer:
      - "10.0.0.0/8"  # Allow secondaries to transfer
</code></pre>
<h3 id="secondary-dns-instance"><a class="header" href="#secondary-dns-instance">Secondary DNS Instance</a></h3>
<pre><code class="language-yaml">metadata:
  labels:
    dns-role: secondary
spec:
  replicas: 2
  config:
    allowTransfer: []  # No transfers from secondary
</code></pre>
<h3 id="instance-with-custom-image"><a class="header" href="#instance-with-custom-image">Instance with Custom Image</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: custom-image-dns
  namespace: dns-system
spec:
  replicas: 2
  image:
    image: "my-registry.example.com/bind9:9.18-patched"
    imagePullPolicy: "Always"
    imagePullSecrets:
      - my-registry-secret
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
</code></pre>
<h3 id="instance-with-custom-configmaps"><a class="header" href="#instance-with-custom-configmaps">Instance with Custom ConfigMaps</a></h3>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: custom-dns-config
  namespace: dns-system
data:
  named.conf.options: |
    options {
      directory "/var/cache/bind";
      recursion no;
      allow-query { any; };

      # Custom rate limiting
      rate-limit {
        responses-per-second 10;
      };
    };
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: custom-config-dns
  namespace: dns-system
spec:
  replicas: 2
  configMapRefs:
    namedConfOptions: "custom-dns-config"
</code></pre>
<h3 id="instance-inheriting-from-cluster"><a class="header" href="#instance-inheriting-from-cluster">Instance Inheriting from Cluster</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: prod-cluster
  namespace: dns-system
spec:
  version: "9.18"
  image:
    image: "internetsystemsconsortium/bind9:9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: prod-instance-1
  namespace: dns-system
spec:
  clusterRef: prod-cluster
  replicas: 2
  # Inherits version, image, and config from cluster
</code></pre>
<h3 id="canary-instance-with-override"><a class="header" href="#canary-instance-with-override">Canary Instance with Override</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: canary-instance
  namespace: dns-system
spec:
  clusterRef: prod-cluster  # Inherits most settings from cluster
  replicas: 1
  # Override image for canary testing
  image:
    image: "internetsystemsconsortium/bind9:9.19-beta"
    imagePullPolicy: "Always"
</code></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<ul>
<li><a href="concepts/./dnszone.html">DNSZone</a> - Learn about DNS zones</li>
<li><a href="concepts/../guide/primary-instance.html">Primary Instances</a> - Deploy primary DNS</li>
<li><a href="concepts/../guide/secondary-instance.html">Secondary Instances</a> - Deploy secondary DNS</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dnszone-1"><a class="header" href="#dnszone-1">DNSZone</a></h1>
<p>The <code>DNSZone</code> resource defines a DNS zone with its SOA record and references a specific BIND9 cluster.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>A DNSZone represents:</p>
<ul>
<li>Zone name (e.g., example.com)</li>
<li>SOA (Start of Authority) record</li>
<li>Cluster reference to a Bind9Instance</li>
<li>Default TTL for records</li>
</ul>
<p>The zone is created on the referenced BIND9 cluster using the RNDC protocol.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: my-dns-cluster  # References Bind9Instance name
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin.example.com.  # Note: @ replaced with .
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
  ttl: 3600
status:
  conditions:
    - type: Ready
      status: "True"
      reason: Synchronized
      message: "Zone created for cluster: my-dns-cluster"
  observedGeneration: 1
</code></pre>
<h2 id="specification-2"><a class="header" href="#specification-2">Specification</a></h2>
<h3 id="required-fields"><a class="header" href="#required-fields">Required Fields</a></h3>
<ul>
<li><code>spec.zoneName</code> - The DNS zone name (e.g., example.com)</li>
<li><code>spec.clusterRef</code> - Name of the Bind9Instance to host this zone</li>
<li><code>spec.soaRecord</code> - Start of Authority record configuration</li>
</ul>
<h3 id="soa-record-fields"><a class="header" href="#soa-record-fields">SOA Record Fields</a></h3>
<ul>
<li><code>primaryNS</code> - Primary nameserver (must end with <code>.</code>)</li>
<li><code>adminEmail</code> - Zone administrator email (@ replaced with <code>.</code>, must end with <code>.</code>)</li>
<li><code>serial</code> - Zone serial number (typically YYYYMMDDNN format)</li>
<li><code>refresh</code> - Refresh interval in seconds (how often secondaries check for updates)</li>
<li><code>retry</code> - Retry interval in seconds (retry delay after failed refresh)</li>
<li><code>expire</code> - Expiry time in seconds (when to stop serving if primary unreachable)</li>
<li><code>negativeTTL</code> - Negative caching TTL (cache duration for NXDOMAIN responses)</li>
</ul>
<h3 id="optional-fields-2"><a class="header" href="#optional-fields-2">Optional Fields</a></h3>
<ul>
<li><code>spec.ttl</code> - Default TTL for records in seconds (default: 3600)</li>
</ul>
<h2 id="how-zones-are-created"><a class="header" href="#how-zones-are-created">How Zones Are Created</a></h2>
<p>When you create a DNSZone resource:</p>
<ol>
<li><strong>Controller discovers pods</strong> - Finds BIND9 pods with label <code>instance={clusterRef}</code></li>
<li><strong>Loads RNDC key</strong> - Retrieves Secret named <code>{clusterRef}-rndc-key</code></li>
<li><strong>Connects via RNDC</strong> - Establishes connection to <code>{clusterRef}.{namespace}.svc.cluster.local:953</code></li>
<li><strong>Executes addzone</strong> - Runs <code>rndc addzone</code> command with zone configuration</li>
<li><strong>BIND9 creates zone</strong> - BIND9 creates the zone file and starts serving the zone</li>
<li><strong>Updates status</strong> - Controller updates DNSZone status to Ready</li>
</ol>
<h2 id="cluster-references-1"><a class="header" href="#cluster-references-1">Cluster References</a></h2>
<p>Zones reference a specific BIND9 cluster by name:</p>
<pre><code class="language-yaml">spec:
  clusterRef: my-dns-cluster
</code></pre>
<p>This references a Bind9Instance resource:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: my-dns-cluster  # Referenced by DNSZone
  namespace: dns-system
spec:
  role: primary
  replicas: 2
</code></pre>
<h3 id="rndc-key-discovery"><a class="header" href="#rndc-key-discovery">RNDC Key Discovery</a></h3>
<p>The controller automatically finds the RNDC key using the cluster reference:</p>
<pre><code>DNSZone.spec.clusterRef = "my-dns-cluster"
    ↓
Secret name = "my-dns-cluster-rndc-key"
    ↓
RNDC authentication to: my-dns-cluster.dns-system.svc.cluster.local:953
</code></pre>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p>The controller reports zone status:</p>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      reason: Synchronized
      message: "Zone created for cluster: my-dns-cluster"
  observedGeneration: 1
  recordCount: 5
</code></pre>
<p>Possible status conditions:</p>
<ul>
<li><strong>Ready/True</strong> - Zone created and serving on BIND9 cluster</li>
<li><strong>Ready/False</strong> - Zone creation failed or RNDC error</li>
<li><strong>Ready/Unknown</strong> - Controller hasn't reconciled yet</li>
</ul>
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<h3 id="simple-zone"><a class="header" href="#simple-zone">Simple Zone</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: simple-com
spec:
  zoneName: simple.com
  clusterRef: primary-dns
  soaRecord:
    primaryNS: ns1.simple.com.
    adminEmail: admin.simple.com.
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
</code></pre>
<h3 id="production-zone-with-custom-ttl"><a class="header" href="#production-zone-with-custom-ttl">Production Zone with Custom TTL</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: api-example-com
spec:
  zoneName: api.example.com
  clusterRef: production-dns
  ttl: 300  # 5 minute default TTL for faster updates
  soaRecord:
    primaryNS: ns1.api.example.com.
    adminEmail: ops.example.com.
    serial: 2024010101
    refresh: 1800   # Check every 30 minutes
    retry: 300      # Retry after 5 minutes
    expire: 604800
    negativeTTL: 300  # Short negative cache
</code></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li><a href="concepts/./records.html">DNS Records</a> - Add records to zones</li>
<li><a href="concepts/./architecture-rndc.html">RNDC-Based Architecture</a> - Learn how RNDC protocol works</li>
<li><a href="concepts/./bind9instance.html">Bind9Instance</a> - Learn about BIND9 instance resources</li>
<li><a href="concepts/../guide/creating-zones.html">Creating Zones</a> - Zone management guide</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dns-records"><a class="header" href="#dns-records">DNS Records</a></h1>
<p>Bindy supports all common DNS record types as Custom Resources.</p>
<h2 id="supported-record-types"><a class="header" href="#supported-record-types">Supported Record Types</a></h2>
<ul>
<li><strong>ARecord</strong> - IPv4 address mapping</li>
<li><strong>AAAARecord</strong> - IPv6 address mapping</li>
<li><strong>CNAMERecord</strong> - Canonical name (alias)</li>
<li><strong>MXRecord</strong> - Mail exchange</li>
<li><strong>TXTRecord</strong> - Text data</li>
<li><strong>NSRecord</strong> - Nameserver delegation</li>
<li><strong>SRVRecord</strong> - Service location</li>
<li><strong>CAARecord</strong> - Certificate authority authorization</li>
</ul>
<h2 id="common-fields-1"><a class="header" href="#common-fields-1">Common Fields</a></h2>
<p>All DNS record types share these fields:</p>
<pre><code class="language-yaml">metadata:
  name: record-name
  namespace: dns-system
spec:
  zone: zone-resource-name  # References DNSZone
  name: record-name          # DNS name (@ for zone apex)
  ttl: 300                   # Time to live (optional)
</code></pre>
<h2 id="arecord-ipv4"><a class="header" href="#arecord-ipv4">ARecord (IPv4)</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-example
spec:
  zone: example-com
  name: www
  ipv4Address: "192.0.2.1"
  ttl: 300
</code></pre>
<p><a href="concepts/../guide/a-records.html">Learn more about A Records</a></p>
<h2 id="aaaarecord-ipv6"><a class="header" href="#aaaarecord-ipv6">AAAARecord (IPv6)</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: AAAARecord
metadata:
  name: www-example-ipv6
spec:
  zone: example-com
  name: www
  ipv6Address: "2001:db8::1"
  ttl: 300
</code></pre>
<p><a href="concepts/../guide/aaaa-records.html">Learn more about AAAA Records</a></p>
<h2 id="cnamerecord-alias"><a class="header" href="#cnamerecord-alias">CNAMERecord (Alias)</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: CNAMERecord
metadata:
  name: blog-example
spec:
  zone: example-com
  name: blog
  target: www.example.com.
  ttl: 300
</code></pre>
<p><a href="concepts/../guide/cname-records.html">Learn more about CNAME Records</a></p>
<h2 id="mxrecord-mail-exchange"><a class="header" href="#mxrecord-mail-exchange">MXRecord (Mail Exchange)</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: MXRecord
metadata:
  name: mail-example
spec:
  zone: example-com
  name: "@"
  priority: 10
  mailServer: mail.example.com.
  ttl: 3600
</code></pre>
<p><a href="concepts/../guide/mx-records.html">Learn more about MX Records</a></p>
<h2 id="txtrecord-text"><a class="header" href="#txtrecord-text">TXTRecord (Text)</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: spf-example
spec:
  zone: example-com
  name: "@"
  text:
    - "v=spf1 include:_spf.example.com ~all"
  ttl: 3600
</code></pre>
<p><a href="concepts/../guide/txt-records.html">Learn more about TXT Records</a></p>
<h2 id="nsrecord-nameserver"><a class="header" href="#nsrecord-nameserver">NSRecord (Nameserver)</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: NSRecord
metadata:
  name: delegate-subdomain
spec:
  zone: example-com
  name: subdomain
  nameserver: ns1.subdomain.example.com.
  ttl: 3600
</code></pre>
<p><a href="concepts/../guide/ns-records.html">Learn more about NS Records</a></p>
<h2 id="srvrecord-service"><a class="header" href="#srvrecord-service">SRVRecord (Service)</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: SRVRecord
metadata:
  name: sip-service
spec:
  zone: example-com
  name: _sip._tcp
  priority: 10
  weight: 60
  port: 5060
  target: sipserver.example.com.
  ttl: 3600
</code></pre>
<p><a href="concepts/../guide/srv-records.html">Learn more about SRV Records</a></p>
<h2 id="caarecord-certificate-authority"><a class="header" href="#caarecord-certificate-authority">CAARecord (Certificate Authority)</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: CAARecord
metadata:
  name: letsencrypt-caa
spec:
  zone: example-com
  name: "@"
  flags: 0
  tag: issue
  value: letsencrypt.org
  ttl: 3600
</code></pre>
<p><a href="concepts/../guide/caa-records.html">Learn more about CAA Records</a></p>
<h2 id="record-management"><a class="header" href="#record-management">Record Management</a></h2>
<h3 id="referencing-zones"><a class="header" href="#referencing-zones">Referencing Zones</a></h3>
<p>All records reference a DNSZone via the <code>zone</code> field:</p>
<pre><code class="language-yaml">spec:
  zone: example-com  # Must match DNSZone metadata.name
</code></pre>
<h3 id="zone-apex-records"><a class="header" href="#zone-apex-records">Zone Apex Records</a></h3>
<p>Use <code>@</code> for zone apex records:</p>
<pre><code class="language-yaml">spec:
  name: "@"  # Represents the zone itself
</code></pre>
<h3 id="subdomain-records"><a class="header" href="#subdomain-records">Subdomain Records</a></h3>
<p>Use the subdomain name:</p>
<pre><code class="language-yaml">spec:
  name: www        # www.example.com
  name: api.v2     # api.v2.example.com
</code></pre>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li><a href="concepts/../guide/records-guide.html">Managing DNS Records</a> - Complete record management guide</li>
<li><a href="concepts/../guide/a-records.html">A Records</a> - IPv4 address records</li>
<li><a href="concepts/../guide/cname-records.html">CNAME Records</a> - Alias records</li>
<li><a href="concepts/../guide/mx-records.html">MX Records</a> - Mail server records</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-dns-infrastructure"><a class="header" href="#creating-dns-infrastructure">Creating DNS Infrastructure</a></h1>
<p>This section guides you through setting up your DNS infrastructure using Bindy. A typical DNS setup consists of:</p>
<ul>
<li><strong>Primary DNS Instances</strong>: Authoritative DNS servers that host the master copies of your zones</li>
<li><strong>Secondary DNS Instances</strong>: Replica servers that receive zone transfers from primaries</li>
<li><strong>Multi-Region Setup</strong>: Geographically distributed DNS servers for redundancy</li>
</ul>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Bindy uses Kubernetes Custom Resources to define DNS infrastructure. The <code>Bind9Instance</code> resource creates and manages BIND9 DNS server deployments, including:</p>
<ul>
<li>BIND9 Deployment pods</li>
<li>ConfigMaps for BIND9 configuration</li>
<li>Services for DNS traffic (TCP/UDP port 53)</li>
</ul>
<h2 id="infrastructure-components"><a class="header" href="#infrastructure-components">Infrastructure Components</a></h2>
<h3 id="bind9instance-2"><a class="header" href="#bind9instance-2">Bind9Instance</a></h3>
<p>A <code>Bind9Instance</code> represents a single BIND9 DNS server deployment. You can create multiple instances for:</p>
<ul>
<li><strong>High availability</strong> - Multiple replicas of the same instance</li>
<li><strong>Role separation</strong> - Separate primary and secondary instances</li>
<li><strong>Geographic distribution</strong> - Instances in different regions or availability zones</li>
</ul>
<h2 id="planning-your-infrastructure"><a class="header" href="#planning-your-infrastructure">Planning Your Infrastructure</a></h2>
<p>Before creating instances, consider:</p>
<ol>
<li>
<p><strong>Zone Hosting Strategy</strong></p>
<ul>
<li>Which zones will be primary vs. secondary?</li>
<li>How will zones be distributed across instances?</li>
</ul>
</li>
<li>
<p><strong>Redundancy Requirements</strong></p>
<ul>
<li>How many replicas per instance?</li>
<li>How many geographic locations?</li>
</ul>
</li>
<li>
<p><strong>Label Strategy</strong></p>
<ul>
<li>How will you select instances for zones?</li>
<li>Common labels: <code>dns-role</code>, <code>region</code>, <code>environment</code></li>
</ul>
</li>
</ol>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<ul>
<li><a href="guide/./primary-instance.html">Create Primary DNS Instances</a></li>
<li><a href="guide/./secondary-instance.html">Create Secondary DNS Instances</a></li>
<li><a href="guide/./multi-region.html">Setup Multi-Region Infrastructure</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primary-dns-instances"><a class="header" href="#primary-dns-instances">Primary DNS Instances</a></h1>
<p>Primary DNS instances are authoritative DNS servers that host the master copies of your DNS zones. They are the source of truth for DNS data and handle zone updates.</p>
<h2 id="creating-a-primary-instance"><a class="header" href="#creating-a-primary-instance">Creating a Primary Instance</a></h2>
<p>Here's a basic example of a primary DNS instance:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  namespace: dns-system
  labels:
    dns-role: primary
    environment: production
spec:
  replicas: 2
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.0.0/8"  # Allow zone transfers to secondary servers
    dnssec:
      enabled: true
      validation: true
</code></pre>
<p>Apply it with:</p>
<pre><code class="language-bash">kubectl apply -f primary-instance.yaml
</code></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="replicas"><a class="header" href="#replicas">Replicas</a></h3>
<p>The <code>replicas</code> field controls how many BIND9 pods to run:</p>
<pre><code class="language-yaml">spec:
  replicas: 2  # Run 2 pods for high availability
</code></pre>
<h3 id="bind9-version"><a class="header" href="#bind9-version">BIND9 Version</a></h3>
<p>Specify the BIND9 version to use:</p>
<pre><code class="language-yaml">spec:
  version: "9.18"  # Use BIND 9.18
</code></pre>
<h3 id="query-access-control"><a class="header" href="#query-access-control">Query Access Control</a></h3>
<p>Control who can query your DNS server:</p>
<pre><code class="language-yaml">spec:
  config:
    allowQuery:
      - "0.0.0.0/0"      # Allow queries from anywhere
      - "10.0.0.0/8"     # Or restrict to specific networks
</code></pre>
<h3 id="zone-transfer-control"><a class="header" href="#zone-transfer-control">Zone Transfer Control</a></h3>
<p>Restrict zone transfers to authorized servers (typically secondaries):</p>
<pre><code class="language-yaml">spec:
  config:
    allowTransfer:
      - "10.0.0.0/8"     # Allow transfers to secondary network
      - "192.168.1.0/24" # Or specific secondary server network
</code></pre>
<h3 id="dnssec-configuration"><a class="header" href="#dnssec-configuration">DNSSEC Configuration</a></h3>
<p>Enable DNSSEC signing and validation:</p>
<pre><code class="language-yaml">spec:
  config:
    dnssec:
      enabled: true      # Enable DNSSEC signing
      validation: true   # Enable DNSSEC validation
</code></pre>
<h3 id="recursion"><a class="header" href="#recursion">Recursion</a></h3>
<p>Primary authoritative servers should disable recursion:</p>
<pre><code class="language-yaml">spec:
  config:
    recursion: false  # Disable recursion for authoritative servers
</code></pre>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>Use labels to organize and select instances:</p>
<pre><code class="language-yaml">metadata:
  labels:
    dns-role: primary        # Indicates this is a primary server
    environment: production  # Environment designation
    region: us-east-1       # Geographic location
</code></pre>
<p>These labels are used by DNSZone resources to select which instances should host their zones.</p>
<h2 id="verifying-deployment"><a class="header" href="#verifying-deployment">Verifying Deployment</a></h2>
<p>Check the instance status:</p>
<pre><code class="language-bash">kubectl get bind9instances -n dns-system
kubectl describe bind9instance primary-dns -n dns-system
</code></pre>
<p>Check the created resources:</p>
<pre><code class="language-bash"># View the deployment
kubectl get deployment -n dns-system -l instance=primary-dns

# View the pods
kubectl get pods -n dns-system -l instance=primary-dns

# View the service
kubectl get service -n dns-system -l instance=primary-dns
</code></pre>
<h2 id="testing-dns-resolution"><a class="header" href="#testing-dns-resolution">Testing DNS Resolution</a></h2>
<p>Once deployed, test DNS queries:</p>
<pre><code class="language-bash"># Get the service IP
SERVICE_IP=$(kubectl get svc -n dns-system primary-dns -o jsonpath='{.spec.clusterIP}')

# Test DNS query
dig @$SERVICE_IP example.com
</code></pre>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<ul>
<li><a href="guide/./creating-zones.html">Create DNS Zones</a> to host on this instance</li>
<li><a href="guide/./secondary-instance.html">Setup Secondary Instances</a> for redundancy</li>
<li><a href="guide/./multi-region.html">Configure Multi-Region Setup</a> for geographic distribution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secondary-dns-instances"><a class="header" href="#secondary-dns-instances">Secondary DNS Instances</a></h1>
<p>Secondary DNS instances receive zone data from primary servers via zone transfers (AXFR/IXFR). They provide redundancy and load distribution for DNS queries.</p>
<h2 id="creating-a-secondary-instance"><a class="header" href="#creating-a-secondary-instance">Creating a Secondary Instance</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-dns
  namespace: dns-system
  labels:
    dns-role: secondary
    environment: production
spec:
  replicas: 1
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
</code></pre>
<p>Apply with:</p>
<pre><code class="language-bash">kubectl apply -f secondary-instance.yaml
</code></pre>
<h2 id="key-differences-from-primary"><a class="header" href="#key-differences-from-primary">Key Differences from Primary</a></h2>
<h3 id="no-zone-transfers-allowed"><a class="header" href="#no-zone-transfers-allowed">No Zone Transfers Allowed</a></h3>
<p>Secondary servers typically don't allow zone transfers:</p>
<pre><code class="language-yaml">spec:
  config:
    allowTransfer: []  # Empty or omitted - no transfers from secondary
</code></pre>
<h3 id="read-only-zones"><a class="header" href="#read-only-zones">Read-Only Zones</a></h3>
<p>Secondaries receive zone data from primaries and cannot be updated directly. All zone modifications must be made on the primary server.</p>
<h3 id="label-for-selection"><a class="header" href="#label-for-selection">Label for Selection</a></h3>
<p>Use the <code>dns-role: secondary</code> label to distinguish from primary instances:</p>
<pre><code class="language-yaml">metadata:
  labels:
    dns-role: secondary
</code></pre>
<h2 id="configuring-secondary-zones"><a class="header" href="#configuring-secondary-zones">Configuring Secondary Zones</a></h2>
<p>When creating a DNSZone resource for secondary zones, use the <code>secondary</code> type and specify primary servers:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-secondary
  namespace: dns-system
spec:
  zoneName: example.com
  type: secondary
  instanceSelector:
    matchLabels:
      dns-role: secondary
  secondaryConfig:
    primaryServers:
      - "10.0.1.10"  # IP of primary DNS server
      - "10.0.1.11"  # Additional primary for redundancy
</code></pre>
<h2 id="verifying-zone-transfers"><a class="header" href="#verifying-zone-transfers">Verifying Zone Transfers</a></h2>
<p>Check that zones are being transferred:</p>
<pre><code class="language-bash"># Check zone files on secondary
kubectl exec -n dns-system deployment/secondary-dns -- ls -la /var/lib/bind/zones/

# Check BIND9 logs for transfer messages
kubectl logs -n dns-system -l instance=secondary-dns | grep "transfer of"
</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="use-multiple-secondaries"><a class="header" href="#use-multiple-secondaries">Use Multiple Secondaries</a></h3>
<p>Deploy secondary instances in different locations:</p>
<pre><code class="language-yaml"># Secondary in different AZ/region
metadata:
  labels:
    dns-role: secondary
    region: us-west-1
</code></pre>
<h3 id="configure-notify"><a class="header" href="#configure-notify">Configure NOTIFY</a></h3>
<p>Primary servers send NOTIFY messages to secondaries when zones change. Ensure network connectivity allows these notifications.</p>
<h3 id="monitor-transfer-status"><a class="header" href="#monitor-transfer-status">Monitor Transfer Status</a></h3>
<p>Watch for failed transfers in logs:</p>
<pre><code class="language-bash">kubectl logs -n dns-system -l instance=secondary-dns --tail=100 | grep -i transfer
</code></pre>
<h2 id="network-requirements-1"><a class="header" href="#network-requirements-1">Network Requirements</a></h2>
<p>Secondaries must be able to:</p>
<ol>
<li>Receive zone transfers from primaries (TCP port 53)</li>
<li>Receive NOTIFY messages from primaries (UDP port 53)</li>
<li>Respond to DNS queries from clients (UDP/TCP port 53)</li>
</ol>
<p>Ensure Kubernetes network policies and firewall rules allow this traffic.</p>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<ul>
<li><a href="guide/./multi-region.html">Configure Multi-Region Setup</a> with geographically distributed secondaries</li>
<li><a href="guide/./creating-zones.html">Create Secondary Zones</a> that transfer from primaries</li>
<li><a href="guide/../operations/monitoring.html">Monitor DNS Infrastructure</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-region-setup"><a class="header" href="#multi-region-setup">Multi-Region Setup</a></h1>
<p>Distribute your DNS infrastructure across multiple regions or availability zones for maximum availability and performance.</p>
<h2 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h2>
<p>A multi-region DNS setup typically includes:</p>
<ul>
<li><strong>Primary instances</strong> in one or more regions</li>
<li><strong>Secondary instances</strong> in multiple geographic locations</li>
<li><strong>Zone distribution</strong> across all instances using label selectors</li>
</ul>
<h2 id="creating-regional-instances"><a class="header" href="#creating-regional-instances">Creating Regional Instances</a></h2>
<h3 id="primary-in-region-1"><a class="header" href="#primary-in-region-1">Primary in Region 1</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-us-east
  namespace: dns-system
  labels:
    dns-role: primary
    region: us-east-1
    environment: production
spec:
  replicas: 2
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.0.0/8"
    dnssec:
      enabled: true
</code></pre>
<h3 id="secondary-in-region-2"><a class="header" href="#secondary-in-region-2">Secondary in Region 2</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-us-west
  namespace: dns-system
  labels:
    dns-role: secondary
    region: us-west-2
    environment: production
spec:
  replicas: 1
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
</code></pre>
<h3 id="secondary-in-region-3"><a class="header" href="#secondary-in-region-3">Secondary in Region 3</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-eu-west
  namespace: dns-system
  labels:
    dns-role: secondary
    region: eu-west-1
    environment: production
spec:
  replicas: 1
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
</code></pre>
<h2 id="distributing-zones-across-regions"><a class="header" href="#distributing-zones-across-regions">Distributing Zones Across Regions</a></h2>
<p>Create zones that target all regions:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
  namespace: dns-system
spec:
  zoneName: example.com
  type: primary
  instanceSelector:
    matchExpressions:
      - key: environment
        operator: In
        values:
          - production
      - key: dns-role
        operator: In
        values:
          - primary
          - secondary
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin@example.com
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
</code></pre>
<p>This zone will be deployed to all instances matching the selector (all production primary and secondary instances).</p>
<h2 id="deployment-strategy"><a class="header" href="#deployment-strategy">Deployment Strategy</a></h2>
<h3 id="option-1-primary-secondary-model"><a class="header" href="#option-1-primary-secondary-model">Option 1: Primary-Secondary Model</a></h3>
<ul>
<li>One region hosts primary instances</li>
<li>All other regions host secondary instances</li>
<li>Zone transfers flow from primary to secondaries</li>
</ul>
<pre><code> Region 1 (us-east-1)         Region 2 (us-west-2)        Region 3 (eu-west-1)
┌─────────────────────┐      ┌─────────────────────┐     ┌─────────────────────┐
│  Primary Instances  │──────│ Secondary Instances │─────│ Secondary Instances │
│   (Master zones)    │      │  (Slave zones)      │     │  (Slave zones)      │
└─────────────────────┘      └─────────────────────┘     └─────────────────────┘
</code></pre>
<h3 id="option-2-multi-primary-model"><a class="header" href="#option-2-multi-primary-model">Option 2: Multi-Primary Model</a></h3>
<ul>
<li>Multiple regions host primary instances</li>
<li>Different zones can have primaries in different regions</li>
<li>Use careful labeling to route zones to appropriate primaries</li>
</ul>
<h2 id="network-considerations"><a class="header" href="#network-considerations">Network Considerations</a></h2>
<h3 id="zone-transfer-network"><a class="header" href="#zone-transfer-network">Zone Transfer Network</a></h3>
<p>Ensure network connectivity for zone transfers:</p>
<ul>
<li>Primaries must reach secondaries on TCP port 53</li>
<li>Use VPN, peering, or allow public transfer with IP restrictions</li>
</ul>
<h3 id="client-query-routing"><a class="header" href="#client-query-routing">Client Query Routing</a></h3>
<p>Use one of:</p>
<ul>
<li><strong>GeoDNS</strong> - Route clients to nearest regional instance</li>
<li><strong>Anycast</strong> - Same IP announced from multiple locations</li>
<li><strong>Load Balancer</strong> - Distribute across regional endpoints</li>
</ul>
<h2 id="failover-strategy"><a class="header" href="#failover-strategy">Failover Strategy</a></h2>
<h3 id="automatic-failover"><a class="header" href="#automatic-failover">Automatic Failover</a></h3>
<p>Kubernetes handles pod-level failures automatically:</p>
<pre><code class="language-yaml">spec:
  replicas: 2  # Multiple replicas for pod-level HA
</code></pre>
<h3 id="regional-failover"><a class="header" href="#regional-failover">Regional Failover</a></h3>
<p>For regional failures:</p>
<ol>
<li>Clients automatically query secondary instances in other regions</li>
<li>Zone data remains available via zone transfers</li>
<li>Updates queue until primary region recovers</li>
</ol>
<h3 id="manual-failover"><a class="header" href="#manual-failover">Manual Failover</a></h3>
<p>To manually promote a secondary to primary:</p>
<ol>
<li>Update DNSZone to change primary servers</li>
<li>Update instance labels if needed</li>
<li>Verify zone transfers are working correctly</li>
</ol>
<h2 id="monitoring-multi-region-setup"><a class="header" href="#monitoring-multi-region-setup">Monitoring Multi-Region Setup</a></h2>
<p>Check instance distribution:</p>
<pre><code class="language-bash"># View all instances and their regions
kubectl get bind9instances -n dns-system -L region

# Check zone distribution
kubectl describe dnszone example-com -n dns-system
</code></pre>
<p>Monitor zone transfers:</p>
<pre><code class="language-bash"># Check transfer logs on secondaries
kubectl logs -n dns-system -l dns-role=secondary | grep "transfer of"
</code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Use Odd Number of Regions</strong>: 3 or 5 regions for better quorum</li>
<li><strong>Distribute Replicas</strong>: Spread replicas across availability zones</li>
<li><strong>Monitor Latency</strong>: Watch zone transfer times between regions</li>
<li><strong>Test Failover</strong>: Regularly test regional failover scenarios</li>
<li><strong>Automate Updates</strong>: Use GitOps for consistent multi-region deployments</li>
</ol>
<h2 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h2>
<ul>
<li><a href="guide/../operations/monitoring.html">Configure Monitoring</a> for multi-region health</li>
<li><a href="guide/./zone-config.html">Set Up DNSSEC</a> across all regions</li>
<li><a href="guide/../operations/troubleshooting.html">Implement Disaster Recovery</a> procedures</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-dns-zones"><a class="header" href="#managing-dns-zones">Managing DNS Zones</a></h1>
<p>DNS zones are the containers for DNS records. In Bindy, zones are defined using the <code>DNSZone</code> custom resource.</p>
<h2 id="zone-types"><a class="header" href="#zone-types">Zone Types</a></h2>
<h3 id="primary-zones"><a class="header" href="#primary-zones">Primary Zones</a></h3>
<p>Primary (master) zones contain the authoritative data:</p>
<ul>
<li>Zone data is created and managed on the primary</li>
<li>Changes are made by creating/updating DNS record resources</li>
<li>Can be transferred to secondary servers</li>
</ul>
<h3 id="secondary-zones"><a class="header" href="#secondary-zones">Secondary Zones</a></h3>
<p>Secondary (slave) zones receive data from primary servers:</p>
<ul>
<li>Zone data is received via AXFR/IXFR transfers</li>
<li>Read-only - cannot be modified directly</li>
<li>Automatically updated when primary changes</li>
</ul>
<h2 id="zone-lifecycle"><a class="header" href="#zone-lifecycle">Zone Lifecycle</a></h2>
<ol>
<li><strong>Create Bind9Instance</strong> resources to host zones</li>
<li><strong>Create DNSZone</strong> resource with instance selector</li>
<li><strong>Add DNS records</strong> (A, CNAME, MX, etc.)</li>
<li><strong>Monitor status</strong> to ensure zone is active</li>
</ol>
<h2 id="instance-selection"><a class="header" href="#instance-selection">Instance Selection</a></h2>
<p>Zones are deployed to Bind9Instances using label selectors:</p>
<pre><code class="language-yaml">spec:
  instanceSelector:
    matchLabels:
      dns-role: primary
      environment: production
</code></pre>
<p>This deploys the zone to all instances matching both labels.</p>
<h2 id="soa-record"><a class="header" href="#soa-record">SOA Record</a></h2>
<p>Every primary zone requires an SOA (Start of Authority) record:</p>
<pre><code class="language-yaml">spec:
  soaRecord:
    primaryNS: ns1.example.com.      # Primary nameserver
    adminEmail: admin@example.com    # Admin email (@ becomes .)
    serial: 2024010101               # Zone serial number
    refresh: 3600                    # Refresh interval
    retry: 600                       # Retry interval
    expire: 604800                   # Expiration time
    negativeTTL: 86400              # Negative caching TTL
</code></pre>
<h2 id="zone-configuration"><a class="header" href="#zone-configuration">Zone Configuration</a></h2>
<h3 id="ttl-time-to-live"><a class="header" href="#ttl-time-to-live">TTL (Time To Live)</a></h3>
<p>Set the default TTL for records in the zone:</p>
<pre><code class="language-yaml">spec:
  ttl: 3600  # 1 hour default TTL
</code></pre>
<p>Individual records can override this with their own TTL values.</p>
<h2 id="zone-status"><a class="header" href="#zone-status">Zone Status</a></h2>
<p>Check zone status:</p>
<pre><code class="language-bash">kubectl get dnszone -n dns-system
kubectl describe dnszone example-com -n dns-system
</code></pre>
<p>Status conditions indicate:</p>
<ul>
<li>Whether the zone is ready</li>
<li>Which instances are hosting the zone</li>
<li>Any errors or warnings</li>
</ul>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<h3 id="listing-zones"><a class="header" href="#listing-zones">Listing Zones</a></h3>
<pre><code class="language-bash"># List all zones
kubectl get dnszones -n dns-system

# Show zones with custom columns
kubectl get dnszones -n dns-system -o custom-columns=NAME:.metadata.name,ZONE:.spec.zoneName,TYPE:.spec.type
</code></pre>
<h3 id="viewing-zone-details"><a class="header" href="#viewing-zone-details">Viewing Zone Details</a></h3>
<pre><code class="language-bash">kubectl describe dnszone example-com -n dns-system
</code></pre>
<h3 id="updating-zones"><a class="header" href="#updating-zones">Updating Zones</a></h3>
<p>Edit the zone configuration:</p>
<pre><code class="language-bash">kubectl edit dnszone example-com -n dns-system
</code></pre>
<p>Or apply an updated YAML file:</p>
<pre><code class="language-bash">kubectl apply -f zone.yaml
</code></pre>
<h3 id="deleting-zones"><a class="header" href="#deleting-zones">Deleting Zones</a></h3>
<pre><code class="language-bash">kubectl delete dnszone example-com -n dns-system
</code></pre>
<p>This removes the zone from all instances but doesn't delete the instance itself.</p>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<ul>
<li><a href="guide/./creating-zones.html">Create Primary Zones</a></li>
<li><a href="guide/./label-selectors.html">Understanding Label Selectors</a></li>
<li><a href="guide/./zone-config.html">Zone Configuration Options</a></li>
<li><a href="guide/./records-guide.html">Add DNS Records</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-zones"><a class="header" href="#creating-zones">Creating Zones</a></h1>
<p>Learn how to create DNS zones in Bindy using the RNDC protocol.</p>
<h2 id="zone-architecture"><a class="header" href="#zone-architecture">Zone Architecture</a></h2>
<p>Zones in Bindy follow a three-tier model:</p>
<ol>
<li><strong>Bind9Cluster</strong> - Cluster-level configuration (version, shared config, TSIG keys)</li>
<li><strong>Bind9Instance</strong> - Individual BIND9 server deployment (references a cluster)</li>
<li><strong>DNSZone</strong> - DNS zone (references an instance via <code>clusterRef</code>)</li>
</ol>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Before creating a zone, ensure you have:</p>
<ol>
<li>A Bind9Cluster resource deployed</li>
<li>A Bind9Instance resource deployed (referencing the cluster)</li>
<li>The instance is ready and running</li>
</ol>
<h2 id="creating-a-primary-zone"><a class="header" href="#creating-a-primary-zone">Creating a Primary Zone</a></h2>
<p>First, ensure you have a cluster and instance:</p>
<pre><code class="language-yaml"># Step 1: Create a Bind9Cluster (if not already created)
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: production-dns
  namespace: dns-system
spec:
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.0.0/8"

---
# Step 2: Create a Bind9Instance (if not already created)
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  namespace: dns-system
spec:
  clusterRef: production-dns  # References the Bind9Cluster above
  replicas: 1

---
# Step 3: Create the DNSZone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: primary-dns  # References the Bind9Instance above
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin.example.com.  # Note: @ replaced with .
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
  ttl: 3600
</code></pre>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h2>
<p>When you create a DNSZone:</p>
<ol>
<li><strong>Controller discovers pods</strong> - Finds BIND9 pods with label <code>instance=primary-dns</code></li>
<li><strong>Loads RNDC key</strong> - Retrieves Secret named <code>primary-dns-rndc-key</code></li>
<li><strong>Connects via RNDC</strong> - Establishes connection to <code>primary-dns.dns-system.svc.cluster.local:953</code></li>
<li><strong>Executes addzone</strong> - Runs <code>rndc addzone example.com</code> command</li>
<li><strong>BIND9 creates zone</strong> - BIND9 creates the zone and starts serving it</li>
<li><strong>Updates status</strong> - Controller updates DNSZone status to Ready</li>
</ol>
<h2 id="verifying-zone-creation"><a class="header" href="#verifying-zone-creation">Verifying Zone Creation</a></h2>
<p>Check the zone status:</p>
<pre><code class="language-bash">kubectl get dnszones -n dns-system
kubectl describe dnszone example-com -n dns-system
</code></pre>
<p>Expected output:</p>
<pre><code>Name:         example-com
Namespace:    dns-system
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  bindy.firestoned.io/v1alpha1
Kind:         DNSZone
Spec:
  Cluster Ref:  primary-dns
  Zone Name:    example.com
Status:
  Conditions:
    Type:    Ready
    Status:  True
    Reason:  Synchronized
    Message: Zone created for cluster: primary-dns
</code></pre>
<h2 id="next-steps-18"><a class="header" href="#next-steps-18">Next Steps</a></h2>
<ul>
<li><a href="guide/./records-guide.html">Add DNS Records</a> to your zone</li>
<li><a href="guide/../advanced/zone-transfers.html">Configure Zone Transfers</a> for secondaries</li>
<li><a href="guide/../concepts/architecture-rndc.html">Learn about the RNDC Protocol</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cluster-references-2"><a class="header" href="#cluster-references-2">Cluster References</a></h1>
<p>Bindy uses direct cluster references instead of label selectors for targeting DNS zones to BIND9 instances.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>In Bindy's three-tier architecture, resources reference each other directly by name:</p>
<pre><code>Bind9Cluster ← clusterRef ← Bind9Instance ← clusterRef ← DNSZone ← zone ← DNS Records
</code></pre>
<p>This provides:</p>
<ul>
<li><strong>Explicit targeting</strong> - Clear, direct references instead of label matching</li>
<li><strong>Simpler configuration</strong> - No complex selector logic</li>
<li><strong>Better validation</strong> - References can be validated at admission time</li>
<li><strong>Easier troubleshooting</strong> - Direct relationships are easier to understand</li>
</ul>
<h2 id="cluster-reference-model"><a class="header" href="#cluster-reference-model">Cluster Reference Model</a></h2>
<h3 id="dnszone-references-bind9instance"><a class="header" href="#dnszone-references-bind9instance">DNSZone References Bind9Instance</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: primary-dns  # Direct reference to Bind9Instance name
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin.example.com.
</code></pre>
<h3 id="bind9instance-references-bind9cluster"><a class="header" href="#bind9instance-references-bind9cluster">Bind9Instance References Bind9Cluster</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  namespace: dns-system
spec:
  clusterRef: production-dns  # Direct reference to Bind9Cluster name
  replicas: 2
</code></pre>
<h3 id="bind9cluster-top-level"><a class="header" href="#bind9cluster-top-level">Bind9Cluster (Top-Level)</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: production-dns
  namespace: dns-system
spec:
  version: "9.18"
  config:
    recursion: false
</code></pre>
<h2 id="how-references-work"><a class="header" href="#how-references-work">How References Work</a></h2>
<p>When you create a DNSZone with <code>clusterRef: primary-dns</code>:</p>
<ol>
<li><strong>Controller finds the Bind9Instance</strong> - Looks up <code>Bind9Instance</code> named <code>primary-dns</code></li>
<li><strong>Discovers pods</strong> - Finds pods with label <code>instance=primary-dns</code></li>
<li><strong>Loads RNDC key</strong> - Retrieves Secret named <code>primary-dns-rndc-key</code></li>
<li><strong>Connects via RNDC</strong> - Connects to <code>primary-dns.{namespace}.svc.cluster.local:953</code></li>
<li><strong>Creates zone</strong> - Executes <code>rndc addzone</code> command</li>
</ol>
<h2 id="example-multi-region-setup"><a class="header" href="#example-multi-region-setup">Example: Multi-Region Setup</a></h2>
<h3 id="east-region"><a class="header" href="#east-region">East Region</a></h3>
<pre><code class="language-yaml"># East Cluster
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: dns-cluster-east
  namespace: dns-system
spec:
  version: "9.18"

---
# East Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: dns-east
  namespace: dns-system
spec:
  clusterRef: dns-cluster-east
  replicas: 2

---
# Zone on East Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-east
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: dns-east  # Targets east instance
</code></pre>
<h3 id="west-region"><a class="header" href="#west-region">West Region</a></h3>
<pre><code class="language-yaml"># West Cluster
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: dns-cluster-west
  namespace: dns-system
spec:
  version: "9.18"

---
# West Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: dns-west
  namespace: dns-system
spec:
  clusterRef: dns-cluster-west
  replicas: 2

---
# Zone on West Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-west
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: dns-west  # Targets west instance
</code></pre>
<h2 id="benefits-over-label-selectors"><a class="header" href="#benefits-over-label-selectors">Benefits Over Label Selectors</a></h2>
<h3 id="simpler-configuration"><a class="header" href="#simpler-configuration">Simpler Configuration</a></h3>
<p><strong>Old approach (label selectors)</strong>:</p>
<pre><code class="language-yaml"># Had to set labels on instance
labels:
  dns-role: primary
  region: us-east

# Had to use selector in zone
instanceSelector:
  matchLabels:
    dns-role: primary
    region: us-east
</code></pre>
<p><strong>New approach (cluster references)</strong>:</p>
<pre><code class="language-yaml"># Just reference by name
clusterRef: primary-dns
</code></pre>
<h3 id="better-validation"><a class="header" href="#better-validation">Better Validation</a></h3>
<ul>
<li>References can be validated at admission time</li>
<li>Typos are caught immediately</li>
<li>No ambiguity about which instance will host the zone</li>
</ul>
<h3 id="clearer-relationships"><a class="header" href="#clearer-relationships">Clearer Relationships</a></h3>
<pre><code class="language-bash"># See exactly which instance hosts a zone
kubectl get dnszone example-com -o jsonpath='{.spec.clusterRef}'

# See which cluster an instance belongs to
kubectl get bind9instance primary-dns -o jsonpath='{.spec.clusterRef}'
</code></pre>
<h2 id="migrating-from-label-selectors"><a class="header" href="#migrating-from-label-selectors">Migrating from Label Selectors</a></h2>
<p>If you have old DNSZone resources using <code>instanceSelector</code>, migrate them:</p>
<p><strong>Before:</strong></p>
<pre><code class="language-yaml">spec:
  zoneName: example.com
  instanceSelector:
    matchLabels:
      dns-role: primary
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-yaml">spec:
  zoneName: example.com
  clusterRef: primary-dns  # Direct reference to instance name
</code></pre>
<h2 id="next-steps-19"><a class="header" href="#next-steps-19">Next Steps</a></h2>
<ul>
<li><a href="guide/./creating-zones.html">Creating Zones</a> - Learn how to create zones with cluster references</li>
<li><a href="guide/./multi-region.html">Multi-Region Setup</a> - Deploy zones across multiple regions</li>
<li><a href="guide/../concepts/architecture-rndc.html">RNDC-Based Architecture</a> - Understand the RNDC protocol</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zone-configuration-1"><a class="header" href="#zone-configuration-1">Zone Configuration</a></h1>
<p>Advanced zone configuration options.</p>
<h2 id="default-ttl"><a class="header" href="#default-ttl">Default TTL</a></h2>
<p>Set the default TTL for all records in the zone:</p>
<pre><code class="language-yaml">spec:
  ttl: 3600  # 1 hour
</code></pre>
<h2 id="soa-record-details"><a class="header" href="#soa-record-details">SOA Record Details</a></h2>
<pre><code class="language-yaml">spec:
  soaRecord:
    primaryNS: ns1.example.com.    # Primary nameserver FQDN (must end with .)
    adminEmail: admin@example.com  # Admin email (@ replaced with . in zone file)
    serial: 2024010101             # Serial number (YYYYMMDDnn format recommended)
    refresh: 3600                  # How often secondaries check for updates (seconds)
    retry: 600                     # How long to wait before retry after failed refresh
    expire: 604800                 # When to stop answering if no refresh (1 week)
    negativeTTL: 86400             # TTL for negative responses (NXDOMAIN)
</code></pre>
<h2 id="secondary-zone-configuration"><a class="header" href="#secondary-zone-configuration">Secondary Zone Configuration</a></h2>
<p>For secondary zones, specify primary servers:</p>
<pre><code class="language-yaml">spec:
  type: secondary
  secondaryConfig:
    primaryServers:
      - "10.0.1.10"
      - "10.0.1.11"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-dns-records"><a class="header" href="#managing-dns-records">Managing DNS Records</a></h1>
<p>DNS records are the actual data in your zones - IP addresses, mail servers, text data, etc.</p>
<h2 id="record-types"><a class="header" href="#record-types">Record Types</a></h2>
<p>Bindy supports all common DNS record types:</p>
<ul>
<li><strong>A Records</strong> - IPv4 addresses</li>
<li><strong>AAAA Records</strong> - IPv6 addresses</li>
<li><strong>CNAME Records</strong> - Canonical name (alias)</li>
<li><strong>MX Records</strong> - Mail exchange servers</li>
<li><strong>TXT Records</strong> - Text data (SPF, DKIM, DMARC, verification)</li>
<li><strong>NS Records</strong> - Nameserver delegation</li>
<li><strong>SRV Records</strong> - Service location</li>
<li><strong>CAA Records</strong> - Certificate authority authorization</li>
</ul>
<h2 id="record-structure"><a class="header" href="#record-structure">Record Structure</a></h2>
<p>All records share common fields:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: &lt;RecordType&gt;
metadata:
  name: &lt;unique-name&gt;
  namespace: dns-system
spec:
  zone: &lt;zone-resource-name&gt;  # References a DNSZone resource
  name: &lt;record-name&gt;          # Name within the zone
  ttl: &lt;optional-ttl&gt;          # Override zone default TTL
  # ... record-specific fields
</code></pre>
<h2 id="creating-records"><a class="header" href="#creating-records">Creating Records</a></h2>
<p>Records must reference an existing DNSZone:</p>
<pre><code class="language-yaml">spec:
  zone: example-com  # Must match a DNSZone resource name
  name: www          # Creates www.example.com
</code></pre>
<h2 id="next-steps-20"><a class="header" href="#next-steps-20">Next Steps</a></h2>
<ul>
<li><a href="guide/./a-records.html">A Records</a> - IPv4 addresses</li>
<li><a href="guide/./aaaa-records.html">AAAA Records</a> - IPv6 addresses</li>
<li><a href="guide/./cname-records.html">CNAME Records</a> - Aliases</li>
<li><a href="guide/./mx-records.html">MX Records</a> - Mail servers</li>
<li><a href="guide/./txt-records.html">TXT Records</a> - Text data</li>
<li><a href="guide/./ns-records.html">NS Records</a> - Delegation</li>
<li><a href="guide/./srv-records.html">SRV Records</a> - Services</li>
<li><a href="guide/./caa-records.html">CAA Records</a> - Certificate authority</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-records-ipv4"><a class="header" href="#a-records-ipv4">A Records (IPv4)</a></h1>
<p>A records map domain names to IPv4 addresses.</p>
<h2 id="creating-an-a-record"><a class="header" href="#creating-an-a-record">Creating an A Record</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-example
  namespace: dns-system
spec:
  zone: example-com
  name: www
  ipv4Address: "192.0.2.1"
  ttl: 300
</code></pre>
<p>This creates <code>www.example.com -&gt; 192.0.2.1</code>.</p>
<h2 id="root-record"><a class="header" href="#root-record">Root Record</a></h2>
<p>For the zone apex (example.com):</p>
<pre><code class="language-yaml">spec:
  zone: example-com
  name: "@"
  ipv4Address: "192.0.2.1"
</code></pre>
<h2 id="multiple-a-records"><a class="header" href="#multiple-a-records">Multiple A Records</a></h2>
<p>Create multiple records for the same name for load balancing:</p>
<pre><code class="language-bash">kubectl apply -f - &lt;&lt;EOF
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-1
spec:
  zone: example-com
  name: www
  ipv4Address: "192.0.2.1"
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-2
spec:
  zone: example-com
  name: www
  ipv4Address: "192.0.2.2"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aaaa-records-ipv6"><a class="header" href="#aaaa-records-ipv6">AAAA Records (IPv6)</a></h1>
<p>This page is under construction.</p>
<!-- TODO: Add comprehensive documentation for AAAA Records (IPv6) -->
<p>For now, please refer to:</p>
<ul>
<li><a href="guide/../../../README.html">README</a></li>
<li><a href="guide/../installation/quickstart.html">Quick Start</a></li>
<li><a href="https://github.com/firestoned/bindy">GitHub Repository</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cname-records"><a class="header" href="#cname-records">CNAME Records</a></h1>
<p>CNAME (Canonical Name) records create aliases to other domain names.</p>
<h2 id="creating-a-cname"><a class="header" href="#creating-a-cname">Creating a CNAME</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mx-records"><a class="header" href="#mx-records">MX Records</a></h1>
<p>This page is under construction.</p>
<!-- TODO: Add comprehensive documentation for MX Records -->
<p>For now, please refer to:</p>
<ul>
<li><a href="guide/../../../README.html">README</a></li>
<li><a href="guide/../installation/quickstart.html">Quick Start</a></li>
<li><a href="https://github.com/firestoned/bindy">GitHub Repository</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txt-records"><a class="header" href="#txt-records">TXT Records</a></h1>
<p>This page is under construction.</p>
<!-- TODO: Add comprehensive documentation for TXT Records -->
<p>For now, please refer to:</p>
<ul>
<li><a href="guide/../../../README.html">README</a></li>
<li><a href="guide/../installation/quickstart.html">Quick Start</a></li>
<li><a href="https://github.com/firestoned/bindy">GitHub Repository</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ns-records"><a class="header" href="#ns-records">NS Records</a></h1>
<p>This page is under construction.</p>
<!-- TODO: Add comprehensive documentation for NS Records -->
<p>For now, please refer to:</p>
<ul>
<li><a href="guide/../../../README.html">README</a></li>
<li><a href="guide/../installation/quickstart.html">Quick Start</a></li>
<li><a href="https://github.com/firestoned/bindy">GitHub Repository</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="srv-records"><a class="header" href="#srv-records">SRV Records</a></h1>
<p>This page is under construction.</p>
<!-- TODO: Add comprehensive documentation for SRV Records -->
<p>For now, please refer to:</p>
<ul>
<li><a href="guide/../../../README.html">README</a></li>
<li><a href="guide/../installation/quickstart.html">Quick Start</a></li>
<li><a href="https://github.com/firestoned/bindy">GitHub Repository</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caa-records"><a class="header" href="#caa-records">CAA Records</a></h1>
<p>This page is under construction.</p>
<!-- TODO: Add comprehensive documentation for CAA Records -->
<p>For now, please refer to:</p>
<ul>
<li><a href="guide/../../../README.html">README</a></li>
<li><a href="guide/../installation/quickstart.html">Quick Start</a></li>
<li><a href="https://github.com/firestoned/bindy">GitHub Repository</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h1>
<p>Configure the Bindy DNS operator and BIND9 instances for your environment.</p>
<h2 id="controller-configuration"><a class="header" href="#controller-configuration">Controller Configuration</a></h2>
<p>The Bindy controller is configured through environment variables set in the deployment.</p>
<p>See <a href="operations/./env-vars.html">Environment Variables</a> for details on all available configuration options.</p>
<h2 id="bind9-instance-configuration"><a class="header" href="#bind9-instance-configuration">BIND9 Instance Configuration</a></h2>
<p>Configure BIND9 instances through the <code>Bind9Instance</code> custom resource:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  namespace: dns-system
spec:
  clusterRef: my-cluster
  role: primary
  replicas: 2
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.0.0/8"
    dnssec:
      enabled: true
      validation: true
</code></pre>
<h3 id="configuration-options-1"><a class="header" href="#configuration-options-1">Configuration Options</a></h3>
<h4 id="container-image-configuration"><a class="header" href="#container-image-configuration">Container Image Configuration</a></h4>
<p>Customize the BIND9 container image and pull configuration:</p>
<pre><code class="language-yaml">spec:
  # At instance level (overrides cluster)
  image:
    image: "my-registry.example.com/bind9:custom"
    imagePullPolicy: "Always"
    imagePullSecrets:
      - my-registry-secret
</code></pre>
<p>Or configure at the cluster level for all instances:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: my-cluster
spec:
  # Default image configuration for all instances
  image:
    image: "internetsystemsconsortium/bind9:9.18"
    imagePullPolicy: "IfNotPresent"
    imagePullSecrets:
      - shared-pull-secret
</code></pre>
<p><strong>Fields:</strong></p>
<ul>
<li><code>image</code>: Full container image reference (e.g., <code>registry/image:tag</code>)</li>
<li><code>imagePullPolicy</code>: <code>Always</code>, <code>IfNotPresent</code>, or <code>Never</code></li>
<li><code>imagePullSecrets</code>: List of secret names for private registries</li>
</ul>
<h4 id="custom-configuration-files"><a class="header" href="#custom-configuration-files">Custom Configuration Files</a></h4>
<p>Use custom ConfigMaps for BIND9 configuration:</p>
<pre><code class="language-yaml">spec:
  # Reference custom ConfigMaps
  configMapRefs:
    namedConf: "my-custom-named-conf"
    namedConfOptions: "my-custom-options"
</code></pre>
<p>Create your custom ConfigMap:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: my-custom-named-conf
  namespace: dns-system
data:
  named.conf: |
    // Custom BIND9 configuration
    include "/etc/bind/named.conf.options";
    include "/etc/bind/zones/named.conf.zones";

    logging {
      channel custom_log {
        file "/var/log/named/queries.log" versions 3 size 5m;
        severity info;
      };
      category queries { custom_log; };
    };
</code></pre>
<p><strong>Default Behavior:</strong></p>
<ul>
<li>If <code>configMapRefs</code> is not specified, Bindy auto-generates configuration from the <code>config</code> block</li>
<li>If custom ConfigMaps are provided, they take precedence</li>
<li>Default ConfigMap template is available in <code>deploy/configs/default-bind9-config.yaml</code></li>
</ul>
<h4 id="recursion-1"><a class="header" href="#recursion-1">Recursion</a></h4>
<p>Control whether the DNS server performs recursive queries:</p>
<pre><code class="language-yaml">spec:
  config:
    recursion: false  # Disable for authoritative servers
</code></pre>
<p>For authoritative DNS servers, recursion should be disabled.</p>
<h4 id="query-access-control-1"><a class="header" href="#query-access-control-1">Query Access Control</a></h4>
<p>Specify which networks can query the DNS server:</p>
<pre><code class="language-yaml">spec:
  config:
    allowQuery:
      - "0.0.0.0/0"        # Allow from anywhere (public DNS)
      - "10.0.0.0/8"       # Private network only
      - "192.168.1.0/24"   # Specific subnet
</code></pre>
<h4 id="zone-transfer-access-control"><a class="header" href="#zone-transfer-access-control">Zone Transfer Access Control</a></h4>
<p>Restrict zone transfers to authorized servers:</p>
<pre><code class="language-yaml">spec:
  config:
    allowTransfer:
      - "10.0.1.0/24"      # Secondary DNS network
      - "192.168.100.5"    # Specific secondary server
</code></pre>
<h4 id="dnssec-configuration-1"><a class="header" href="#dnssec-configuration-1">DNSSEC Configuration</a></h4>
<p>Enable DNSSEC signing and validation:</p>
<pre><code class="language-yaml">spec:
  config:
    dnssec:
      enabled: true        # Enable DNSSEC signing
      validation: true     # Enable DNSSEC validation
</code></pre>
<h2 id="rbac-configuration"><a class="header" href="#rbac-configuration">RBAC Configuration</a></h2>
<p>Configure Role-Based Access Control for the operator.</p>
<p>See <a href="operations/./rbac.html">RBAC</a> for detailed RBAC setup.</p>
<h2 id="resource-limits-2"><a class="header" href="#resource-limits-2">Resource Limits</a></h2>
<p>Set CPU and memory limits for BIND9 pods.</p>
<p>See <a href="operations/./resources.html">Resource Limits</a> for resource configuration.</p>
<h2 id="configuration-best-practices"><a class="header" href="#configuration-best-practices">Configuration Best Practices</a></h2>
<ol>
<li><strong>Separate Primary and Secondary</strong> - Use different instances for primary and secondary roles</li>
<li><strong>Limit Zone Transfers</strong> - Only allow transfers to known secondaries</li>
<li><strong>Enable DNSSEC</strong> - Use DNSSEC for production zones</li>
<li><strong>Set Appropriate Replicas</strong> - Use 2+ replicas for high availability</li>
<li><strong>Use Labels</strong> - Organize instances with meaningful labels</li>
</ol>
<h2 id="next-steps-21"><a class="header" href="#next-steps-21">Next Steps</a></h2>
<ul>
<li><a href="operations/./env-vars.html">Environment Variables</a> - Controller configuration</li>
<li><a href="operations/./rbac.html">RBAC Setup</a> - Permissions and service accounts</li>
<li><a href="operations/./resources.html">Resource Limits</a> - CPU and memory configuration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h1>
<p>Configure the Bindy controller using environment variables.</p>
<h2 id="controller-environment-variables"><a class="header" href="#controller-environment-variables">Controller Environment Variables</a></h2>
<h3 id="rust_log"><a class="header" href="#rust_log">RUST_LOG</a></h3>
<p>Control logging level:</p>
<pre><code class="language-yaml">env:
  - name: RUST_LOG
    value: "info"  # Options: error, warn, info, debug, trace
</code></pre>
<p><strong>Levels:</strong></p>
<ul>
<li><code>error</code> - Only errors</li>
<li><code>warn</code> - Warnings and errors</li>
<li><code>info</code> - Informational messages (default)</li>
<li><code>debug</code> - Detailed debugging</li>
<li><code>trace</code> - Very detailed tracing</li>
</ul>
<h3 id="reconcile_interval"><a class="header" href="#reconcile_interval">RECONCILE_INTERVAL</a></h3>
<p>Set how often to reconcile resources (in seconds):</p>
<pre><code class="language-yaml">env:
  - name: RECONCILE_INTERVAL
    value: "300"  # 5 minutes
</code></pre>
<h3 id="namespace"><a class="header" href="#namespace">NAMESPACE</a></h3>
<p>Limit operator to specific namespace:</p>
<pre><code class="language-yaml">env:
  - name: NAMESPACE
    valueFrom:
      fieldRef:
        fieldPath: metadata.namespace
</code></pre>
<p>Omit to watch all namespaces (requires ClusterRole).</p>
<h2 id="example-deployment-configuration"><a class="header" href="#example-deployment-configuration">Example Deployment Configuration</a></h2>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: bindy
  namespace: dns-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: bindy
  template:
    metadata:
      labels:
        app: bindy
    spec:
      serviceAccountName: bindy
      containers:
      - name: controller
        image: ghcr.io/firestoned/bindy:latest
        env:
        - name: RUST_LOG
          value: "info"
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li><strong>Use info level in production</strong> - Balance between visibility and noise</li>
<li><strong>Enable debug for troubleshooting</strong> - Temporarily increase to debug level</li>
<li><strong>Set reconcile interval appropriately</strong> - Don't set too low to avoid API pressure</li>
<li><strong>Use namespace scoping</strong> - Scope to specific namespace if not managing cluster-wide DNS</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rbac-role-based-access-control"><a class="header" href="#rbac-role-based-access-control">RBAC (Role-Based Access Control)</a></h1>
<p>Configure Kubernetes RBAC for the Bindy controller.</p>
<h2 id="required-permissions"><a class="header" href="#required-permissions">Required Permissions</a></h2>
<p>The Bindy controller needs permissions to:</p>
<ul>
<li>Manage Bind9Instance, DNSZone, and DNS record resources</li>
<li>Create and manage Deployments, Services, and ConfigMaps</li>
<li>Update resource status fields</li>
<li>Create events for logging</li>
</ul>
<h2 id="clusterrole"><a class="header" href="#clusterrole">ClusterRole</a></h2>
<pre><code class="language-yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: bindy-role
rules:
  # Bindy CRDs
  - apiGroups: ["bindy.firestoned.io"]
    resources:
      - "bind9instances"
      - "bind9instances/status"
      - "dnszones"
      - "dnszones/status"
      - "arecords"
      - "arecords/status"
      - "aaaarecords"
      - "aaaarecords/status"
      - "cnamerecords"
      - "cnamerecords/status"
      - "mxrecords"
      - "mxrecords/status"
      - "txtrecords"
      - "txtrecords/status"
      - "nsrecords"
      - "nsrecords/status"
      - "srvrecords"
      - "srvrecords/status"
      - "caarecords"
      - "caarecords/status"
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  
  # Kubernetes resources
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  
  - apiGroups: [""]
    resources: ["services", "configmaps"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]
</code></pre>
<h2 id="serviceaccount"><a class="header" href="#serviceaccount">ServiceAccount</a></h2>
<pre><code class="language-yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: bindy
  namespace: dns-system
</code></pre>
<h2 id="clusterrolebinding"><a class="header" href="#clusterrolebinding">ClusterRoleBinding</a></h2>
<pre><code class="language-yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: bindy-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: bindy-role
subjects:
- kind: ServiceAccount
  name: bindy
  namespace: dns-system
</code></pre>
<h2 id="namespace-scoped-rbac"><a class="header" href="#namespace-scoped-rbac">Namespace-Scoped RBAC</a></h2>
<p>For namespace-scoped deployments, use Role instead of ClusterRole:</p>
<pre><code class="language-yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: bindy-role
  namespace: dns-system
rules:
  # Same rules as ClusterRole
  - apiGroups: ["bindy.firestoned.io"]
    resources: ["bind9instances", "dnszones", "*records"]
    verbs: ["*"]
  
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["*"]
  
  - apiGroups: [""]
    resources: ["services", "configmaps"]
    verbs: ["*"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: bindy-rolebinding
  namespace: dns-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: bindy-role
subjects:
- kind: ServiceAccount
  name: bindy
  namespace: dns-system
</code></pre>
<h2 id="applying-rbac"><a class="header" href="#applying-rbac">Applying RBAC</a></h2>
<pre><code class="language-bash"># Apply all RBAC resources
kubectl apply -f deploy/rbac/

# Verify ServiceAccount
kubectl get serviceaccount bindy -n dns-system

# Verify ClusterRole
kubectl get clusterrole bindy-role

# Verify ClusterRoleBinding
kubectl get clusterrolebinding bindy-rolebinding
</code></pre>
<h2 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h2>
<ol>
<li><strong>Least Privilege</strong> - Only grant necessary permissions</li>
<li><strong>Namespace Scoping</strong> - Use namespace-scoped roles when possible</li>
<li><strong>Separate ServiceAccounts</strong> - Don't reuse default ServiceAccount</li>
<li><strong>Audit Regularly</strong> - Review permissions periodically</li>
<li><strong>Use Pod Security Policies</strong> - Restrict pod capabilities</li>
</ol>
<h2 id="troubleshooting-rbac"><a class="header" href="#troubleshooting-rbac">Troubleshooting RBAC</a></h2>
<p>Check if controller has required permissions:</p>
<pre><code class="language-bash"># Check what the ServiceAccount can do
kubectl auth can-i list dnszones \
  --as=system:serviceaccount:dns-system:bindy

# Describe the ClusterRoleBinding
kubectl describe clusterrolebinding bindy-rolebinding

# Check controller logs for permission errors
kubectl logs -n dns-system deployment/bindy | grep -i forbidden
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-limits-3"><a class="header" href="#resource-limits-3">Resource Limits</a></h1>
<p>Configure CPU and memory limits for BIND9 pods.</p>
<h2 id="setting-resource-limits"><a class="header" href="#setting-resource-limits">Setting Resource Limits</a></h2>
<p>Configure resources in the Bind9Instance spec:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
spec:
  replicas: 2
  resources:
    requests:
      cpu: "100m"
      memory: "128Mi"
    limits:
      cpu: "500m"
      memory: "512Mi"
</code></pre>
<h2 id="recommended-values"><a class="header" href="#recommended-values">Recommended Values</a></h2>
<h3 id="small-deployment-few-zones"><a class="header" href="#small-deployment-few-zones">Small Deployment (Few zones)</a></h3>
<pre><code class="language-yaml">resources:
  requests:
    cpu: "100m"
    memory: "128Mi"
  limits:
    cpu: "500m"
    memory: "512Mi"
</code></pre>
<h3 id="medium-deployment-multiple-zones"><a class="header" href="#medium-deployment-multiple-zones">Medium Deployment (Multiple zones)</a></h3>
<pre><code class="language-yaml">resources:
  requests:
    cpu: "200m"
    memory: "256Mi"
  limits:
    cpu: "1000m"
    memory: "1Gi"
</code></pre>
<h3 id="large-deployment-many-zones-high-traffic"><a class="header" href="#large-deployment-many-zones-high-traffic">Large Deployment (Many zones, high traffic)</a></h3>
<pre><code class="language-yaml">resources:
  requests:
    cpu: "500m"
    memory: "512Mi"
  limits:
    cpu: "2000m"
    memory: "2Gi"
</code></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li><strong>Set both requests and limits</strong> - Ensures predictable performance</li>
<li><strong>Start conservative</strong> - Begin with lower values and adjust based on monitoring</li>
<li><strong>Monitor usage</strong> - Use metrics to right-size resources</li>
<li><strong>Leave headroom</strong> - Don't max out limits</li>
<li><strong>Consider query volume</strong> - High-traffic DNS needs more resources</li>
</ol>
<h2 id="monitoring-resource-usage"><a class="header" href="#monitoring-resource-usage">Monitoring Resource Usage</a></h2>
<pre><code class="language-bash"># View pod resource usage
kubectl top pods -n dns-system -l app=bind9

# Describe pod to see limits
kubectl describe pod -n dns-system &lt;pod-name&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h1>
<p>Monitor the health and performance of your Bindy DNS infrastructure.</p>
<h2 id="status-conditions"><a class="header" href="#status-conditions">Status Conditions</a></h2>
<p>All Bindy resources report their status using standardized conditions:</p>
<pre><code class="language-bash"># Check Bind9Instance status
kubectl get bind9instance primary-dns -n dns-system -o jsonpath='{.status.conditions}'

# Check DNSZone status
kubectl get dnszone example-com -n dns-system -o jsonpath='{.status.conditions}'
</code></pre>
<p>See <a href="operations/./status.html">Status Conditions</a> for detailed condition types.</p>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>View controller and BIND9 logs:</p>
<pre><code class="language-bash"># Controller logs
kubectl logs -n dns-system deployment/bindy

# BIND9 instance logs
kubectl logs -n dns-system -l instance=primary-dns

# Follow logs
kubectl logs -n dns-system deployment/bindy -f
</code></pre>
<p>See <a href="operations/./logging.html">Logging</a> for log configuration.</p>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<p>Monitor resource usage and performance:</p>
<pre><code class="language-bash"># Pod resource usage
kubectl top pods -n dns-system

# Node resource usage
kubectl top nodes
</code></pre>
<p>See <a href="operations/./metrics.html">Metrics</a> for detailed metrics.</p>
<h2 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h2>
<p>BIND9 pods include liveness and readiness probes:</p>
<pre><code class="language-yaml">livenessProbe:
  exec:
    command: ["dig", "@localhost", "version.bind", "txt", "chaos"]
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  exec:
    command: ["dig", "@localhost", "version.bind", "txt", "chaos"]
  initialDelaySeconds: 5
  periodSeconds: 5
</code></pre>
<p>Check probe status:</p>
<pre><code class="language-bash">kubectl describe pod -n dns-system &lt;bind9-pod-name&gt;
</code></pre>
<h2 id="monitoring-tools"><a class="header" href="#monitoring-tools">Monitoring Tools</a></h2>
<h3 id="prometheus"><a class="header" href="#prometheus">Prometheus</a></h3>
<p>Scrape metrics from BIND9 using bind_exporter:</p>
<pre><code class="language-yaml"># Add exporter sidecar to Bind9Instance
# (Future enhancement)
</code></pre>
<h3 id="grafana"><a class="header" href="#grafana">Grafana</a></h3>
<p>Create dashboards for:</p>
<ul>
<li>Query rate and latency</li>
<li>Zone transfer status</li>
<li>Resource usage</li>
<li>Error rates</li>
</ul>
<h2 id="alerts"><a class="header" href="#alerts">Alerts</a></h2>
<p>Set up alerts for:</p>
<ol>
<li>Pod crashes or restarts</li>
<li>Failed zone transfers</li>
<li>High query latency</li>
<li>Resource exhaustion</li>
<li>DNSSEC validation failures</li>
</ol>
<h2 id="next-steps-22"><a class="header" href="#next-steps-22">Next Steps</a></h2>
<ul>
<li><a href="operations/./status.html">Status Conditions</a> - Understanding resource status</li>
<li><a href="operations/./logging.html">Logging</a> - Log configuration and analysis</li>
<li><a href="operations/./metrics.html">Metrics</a> - Detailed metrics collection</li>
<li><a href="operations/./troubleshooting.html">Troubleshooting</a> - Debugging issues</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="status-conditions-1"><a class="header" href="#status-conditions-1">Status Conditions</a></h1>
<p>This document describes the standardized status conditions used across all Bindy CRDs.</p>
<h2 id="condition-types"><a class="header" href="#condition-types">Condition Types</a></h2>
<p>All Bindy custom resources (Bind9Instance, DNSZone, and all DNS record types) use the following standardized condition types:</p>
<h3 id="ready"><a class="header" href="#ready">Ready</a></h3>
<ul>
<li><strong>Description</strong>: Indicates whether the resource is fully operational and ready to serve its intended purpose</li>
<li><strong>Common Use</strong>: Primary condition type used by all reconcilers</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource is ready and operational</li>
<li><code>False</code>: Resource is not ready (error or in progress)</li>
<li><code>Unknown</code>: Status cannot be determined</li>
</ul>
</li>
</ul>
<h3 id="available"><a class="header" href="#available">Available</a></h3>
<ul>
<li><strong>Description</strong>: Indicates whether the resource is available for use</li>
<li><strong>Common Use</strong>: Used to distinguish between "ready" and "available" when resources may be ready but not yet serving traffic</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource is available</li>
<li><code>False</code>: Resource is not available</li>
<li><code>Unknown</code>: Availability cannot be determined</li>
</ul>
</li>
</ul>
<h3 id="progressing"><a class="header" href="#progressing">Progressing</a></h3>
<ul>
<li><strong>Description</strong>: Indicates whether the resource is currently being worked on</li>
<li><strong>Common Use</strong>: During initial creation or updates</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource is being created or updated</li>
<li><code>False</code>: Resource is not currently progressing</li>
<li><code>Unknown</code>: Progress status cannot be determined</li>
</ul>
</li>
</ul>
<h3 id="degraded"><a class="header" href="#degraded">Degraded</a></h3>
<ul>
<li><strong>Description</strong>: Indicates that the resource is functioning but in a degraded state</li>
<li><strong>Common Use</strong>: When some replicas are down but service continues, or when non-critical features are unavailable</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource is degraded</li>
<li><code>False</code>: Resource is not degraded</li>
<li><code>Unknown</code>: Degradation status cannot be determined</li>
</ul>
</li>
</ul>
<h3 id="failed"><a class="header" href="#failed">Failed</a></h3>
<ul>
<li><strong>Description</strong>: Indicates that the resource has failed and cannot fulfill its purpose</li>
<li><strong>Common Use</strong>: Permanent failures that require intervention</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource has failed</li>
<li><code>False</code>: Resource has not failed</li>
<li><code>Unknown</code>: Failure status cannot be determined</li>
</ul>
</li>
</ul>
<h2 id="condition-structure"><a class="header" href="#condition-structure">Condition Structure</a></h2>
<p>All conditions follow this structure:</p>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready              # One of: Ready, Available, Progressing, Degraded, Failed
      status: "True"           # One of: "True", "False", "Unknown"
      reason: Ready            # Machine-readable reason (typically same as type)
      message: "Bind9Instance configured with 2 replicas"  # Human-readable message
      lastTransitionTime: "2024-11-26T10:00:00Z"          # RFC3339 timestamp
  observedGeneration: 1        # Generation last observed by controller
  # Resource-specific fields (replicas, recordCount, etc.)
</code></pre>
<h2 id="current-usage"><a class="header" href="#current-usage">Current Usage</a></h2>
<h3 id="bind9instance-3"><a class="header" href="#bind9instance-3">Bind9Instance</a></h3>
<ul>
<li>Uses <code>Ready</code> condition type</li>
<li>Status <code>True</code> when Deployment, Service, and ConfigMap are successfully created</li>
<li>Status <code>False</code> when resource creation fails</li>
<li>Additional status fields:
<ul>
<li><code>replicas</code>: Total number of replicas</li>
<li><code>readyReplicas</code>: Number of ready replicas</li>
</ul>
</li>
</ul>
<h3 id="dnszone-2"><a class="header" href="#dnszone-2">DNSZone</a></h3>
<ul>
<li>Uses <code>Ready</code> condition type</li>
<li>Status <code>True</code> when zone file is created and instances are matched</li>
<li>Status <code>False</code> when zone creation fails</li>
<li>Additional status fields:
<ul>
<li><code>recordCount</code>: Number of records in the zone</li>
<li><code>observedGeneration</code>: Last observed generation</li>
</ul>
</li>
</ul>
<h3 id="dns-records-a-aaaa-cname-mx-txt-ns-srv-caa"><a class="header" href="#dns-records-a-aaaa-cname-mx-txt-ns-srv-caa">DNS Records (A, AAAA, CNAME, MX, TXT, NS, SRV, CAA)</a></h3>
<ul>
<li>All use <code>Ready</code> condition type</li>
<li>Status <code>True</code> when record is successfully added to zone</li>
<li>Status <code>False</code> when record creation fails</li>
<li>Additional status fields:
<ul>
<li><code>observedGeneration</code>: Last observed generation</li>
</ul>
</li>
</ul>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<ol>
<li><strong>Always set the condition type</strong>: Use one of the five standardized types</li>
<li><strong>Include timestamps</strong>: Set <code>lastTransitionTime</code> when condition status changes</li>
<li><strong>Provide clear messages</strong>: The <code>message</code> field should be human-readable and actionable</li>
<li><strong>Use appropriate reasons</strong>: The <code>reason</code> field should be machine-readable and consistent</li>
<li><strong>Update observedGeneration</strong>: Always update to match the resource's current generation</li>
<li><strong>Multiple conditions</strong>: Resources can have multiple conditions simultaneously (e.g., <code>Ready: True</code> and <code>Degraded: True</code>)</li>
</ol>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="successful-bind9instance"><a class="header" href="#successful-bind9instance">Successful Bind9Instance</a></h3>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      reason: Ready
      message: "Bind9Instance configured with 2 replicas"
      lastTransitionTime: "2024-11-26T10:00:00Z"
  observedGeneration: 1
  replicas: 2
  readyReplicas: 2
</code></pre>
<h3 id="failed-dnszone"><a class="header" href="#failed-dnszone">Failed DNSZone</a></h3>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "False"
      reason: Failed
      message: "No Bind9Instances matched selector"
      lastTransitionTime: "2024-11-26T10:00:00Z"
  observedGeneration: 1
  recordCount: 0
</code></pre>
<h3 id="progressing-deployment"><a class="header" href="#progressing-deployment">Progressing Deployment</a></h3>
<pre><code class="language-yaml">status:
  conditions:
    - type: Progressing
      status: "True"
      reason: Progressing
      message: "Deployment is rolling out"
      lastTransitionTime: "2024-11-26T10:00:00Z"
    - type: Ready
      status: "False"
      reason: Progressing
      message: "Waiting for deployment to complete"
      lastTransitionTime: "2024-11-26T10:00:00Z"
  observedGeneration: 2
  replicas: 2
  readyReplicas: 1
</code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>All condition types are enforced via CRD validation. Attempting to use a condition type not in the enum will result in a validation error:</p>
<pre><code class="language-bash">$ kubectl apply -f invalid-condition.yaml
Error from server (Invalid): error when creating "invalid-condition.yaml":
Bind9Instance.bindy.firestoned.io "test" is invalid:
status.conditions[0].type: Unsupported value: "CustomType":
supported values: "Ready", "Available", "Progressing", "Degraded", "Failed"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-1"><a class="header" href="#logging-1">Logging</a></h1>
<p>Configure and analyze logs from the Bindy controller and BIND9 instances.</p>
<h2 id="controller-logging"><a class="header" href="#controller-logging">Controller Logging</a></h2>
<h3 id="log-levels"><a class="header" href="#log-levels">Log Levels</a></h3>
<p>Set log level via RUST_LOG environment variable:</p>
<pre><code class="language-yaml">env:
  - name: RUST_LOG
    value: "info"  # error, warn, info, debug, trace
</code></pre>
<h3 id="viewing-controller-logs"><a class="header" href="#viewing-controller-logs">Viewing Controller Logs</a></h3>
<pre><code class="language-bash"># View recent logs
kubectl logs -n dns-system deployment/bindy --tail=100

# Follow logs in real-time
kubectl logs -n dns-system deployment/bindy -f

# Filter by log level
kubectl logs -n dns-system deployment/bindy | grep ERROR

# Search for specific resource
kubectl logs -n dns-system deployment/bindy | grep "example-com"
</code></pre>
<h2 id="bind9-instance-logging"><a class="header" href="#bind9-instance-logging">BIND9 Instance Logging</a></h2>
<h3 id="viewing-bind9-logs"><a class="header" href="#viewing-bind9-logs">Viewing BIND9 Logs</a></h3>
<pre><code class="language-bash"># Logs from all BIND9 pods
kubectl logs -n dns-system -l app=bind9

# Logs from specific instance
kubectl logs -n dns-system -l instance=primary-dns

# Follow logs
kubectl logs -n dns-system -l instance=primary-dns -f --tail=50
</code></pre>
<h3 id="common-log-messages"><a class="header" href="#common-log-messages">Common Log Messages</a></h3>
<p><strong>Successful Zone Load:</strong></p>
<pre><code>zone example.com/IN: loaded serial 2024010101
</code></pre>
<p><strong>Zone Transfer:</strong></p>
<pre><code>transfer of 'example.com/IN' from 10.0.1.10#53: Transfer completed
</code></pre>
<p><strong>Query Logging (if enabled):</strong></p>
<pre><code>client @0x7f... 192.0.2.1#53210: query: www.example.com IN A
</code></pre>
<h2 id="log-aggregation"><a class="header" href="#log-aggregation">Log Aggregation</a></h2>
<h3 id="using-fluentdfluent-bit"><a class="header" href="#using-fluentdfluent-bit">Using Fluentd/Fluent Bit</a></h3>
<p>Collect logs to centralized logging:</p>
<pre><code class="language-yaml"># Example Fluent Bit DaemonSet configuration
# Automatically collects pod logs
</code></pre>
<h3 id="using-loki"><a class="header" href="#using-loki">Using Loki</a></h3>
<p>Store and query logs with Grafana Loki:</p>
<pre><code class="language-bash"># Query logs for DNS zone
{namespace="dns-system", app="bind9"} |= "example.com"

# Query for errors
{namespace="dns-system"} |= "ERROR"
</code></pre>
<h2 id="structured-logging"><a class="header" href="#structured-logging">Structured Logging</a></h2>
<p>Controller logs use structured format:</p>
<pre><code class="language-json">{
  "timestamp": "2024-11-26T10:00:00Z",
  "level": "INFO",
  "target": "bindy::reconcilers::dnszone",
  "message": "Reconciling DNSZone: dns-system/example-com"
}
</code></pre>
<h2 id="log-retention"><a class="header" href="#log-retention">Log Retention</a></h2>
<p>Configure log retention based on your needs:</p>
<ul>
<li><strong>Development</strong>: 7 days</li>
<li><strong>Production</strong>: 30-90 days</li>
<li><strong>Compliance</strong>: As required by regulations</li>
</ul>
<h2 id="troubleshooting-with-logs"><a class="header" href="#troubleshooting-with-logs">Troubleshooting with Logs</a></h2>
<h3 id="find-failed-reconciliations"><a class="header" href="#find-failed-reconciliations">Find Failed Reconciliations</a></h3>
<pre><code class="language-bash">kubectl logs -n dns-system deployment/bindy | grep "ERROR\|Failed"
</code></pre>
<h3 id="track-zone-transfer-issues"><a class="header" href="#track-zone-transfer-issues">Track Zone Transfer Issues</a></h3>
<pre><code class="language-bash">kubectl logs -n dns-system -l dns-role=secondary | grep "transfer"
</code></pre>
<h3 id="monitor-resource-creation"><a class="header" href="#monitor-resource-creation">Monitor Resource Creation</a></h3>
<pre><code class="language-bash">kubectl logs -n dns-system deployment/bindy | grep "Creating\|Updating"
</code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<ol>
<li><strong>Use appropriate log levels</strong> - info for production, debug for troubleshooting</li>
<li><strong>Centralize logs</strong> - Use log aggregation for easier analysis</li>
<li><strong>Set up log rotation</strong> - Prevent disk space issues</li>
<li><strong>Create alerts</strong> - Alert on ERROR level logs</li>
<li><strong>Regular review</strong> - Periodically review logs for issues</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-1"><a class="header" href="#metrics-1">Metrics</a></h1>
<p>Monitor performance and health metrics for Bindy DNS infrastructure.</p>
<h2 id="resource-metrics"><a class="header" href="#resource-metrics">Resource Metrics</a></h2>
<h3 id="pod-metrics"><a class="header" href="#pod-metrics">Pod Metrics</a></h3>
<p>View CPU and memory usage:</p>
<pre><code class="language-bash"># All DNS pods
kubectl top pods -n dns-system

# Specific instance
kubectl top pods -n dns-system -l instance=primary-dns

# Sort by CPU
kubectl top pods -n dns-system --sort-by=cpu

# Sort by memory
kubectl top pods -n dns-system --sort-by=memory
</code></pre>
<h3 id="node-metrics"><a class="header" href="#node-metrics">Node Metrics</a></h3>
<pre><code class="language-bash"># Node resource usage
kubectl top nodes

# Detailed node info
kubectl describe node &lt;node-name&gt;
</code></pre>
<h2 id="dns-query-metrics"><a class="header" href="#dns-query-metrics">DNS Query Metrics</a></h2>
<h3 id="using-bind9-statistics"><a class="header" href="#using-bind9-statistics">Using BIND9 Statistics</a></h3>
<p>Enable BIND9 statistics channel (future enhancement):</p>
<pre><code class="language-yaml">spec:
  config:
    statisticsChannels:
      - address: "127.0.0.1"
        port: 8053
</code></pre>
<h3 id="query-counters"><a class="header" href="#query-counters">Query Counters</a></h3>
<p>Monitor query rate and types:</p>
<ul>
<li>Total queries received</li>
<li>Queries by record type (A, AAAA, MX, etc.)</li>
<li>Successful vs failed queries</li>
<li>NXDOMAIN responses</li>
</ul>
<h2 id="performance-metrics"><a class="header" href="#performance-metrics">Performance Metrics</a></h2>
<h3 id="query-latency"><a class="header" href="#query-latency">Query Latency</a></h3>
<p>Measure DNS query response time:</p>
<pre><code class="language-bash"># Test query latency
time dig @&lt;dns-server-ip&gt; example.com

# Multiple queries for average
for i in {1..10}; do time dig @&lt;dns-server-ip&gt; example.com +short; done
</code></pre>
<h3 id="zone-transfer-metrics"><a class="header" href="#zone-transfer-metrics">Zone Transfer Metrics</a></h3>
<p>Monitor zone transfer performance:</p>
<ul>
<li>Transfer duration</li>
<li>Transfer size</li>
<li>Transfer failures</li>
<li>Lag between primary and secondary</li>
</ul>
<h2 id="kubernetes-metrics"><a class="header" href="#kubernetes-metrics">Kubernetes Metrics</a></h2>
<h3 id="resource-utilization"><a class="header" href="#resource-utilization">Resource Utilization</a></h3>
<pre><code class="language-yaml"># View resource requests vs limits
kubectl describe pod -n dns-system &lt;pod-name&gt; | grep -A5 "Limits:\|Requests:"
</code></pre>
<h3 id="pod-health"><a class="header" href="#pod-health">Pod Health</a></h3>
<pre><code class="language-yaml"># Pod status and restarts
kubectl get pods -n dns-system -o wide

# Events
kubectl get events -n dns-system --sort-by='.lastTimestamp'
</code></pre>
<h2 id="prometheus-integration"><a class="header" href="#prometheus-integration">Prometheus Integration</a></h2>
<h3 id="bind9-exporter"><a class="header" href="#bind9-exporter">BIND9 Exporter</a></h3>
<p>Deploy bind_exporter as sidecar (future enhancement):</p>
<pre><code class="language-yaml">containers:
- name: bind-exporter
  image: prometheuscommunity/bind-exporter:latest
  args:
    - "--bind.stats-url=http://localhost:8053"
  ports:
    - name: metrics
      containerPort: 9119
</code></pre>
<h3 id="service-monitor"><a class="header" href="#service-monitor">Service Monitor</a></h3>
<pre><code class="language-yaml">apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: bindy-metrics
spec:
  selector:
    matchLabels:
      app: bind9
  endpoints:
  - port: metrics
    interval: 30s
</code></pre>
<h2 id="key-metrics-to-monitor"><a class="header" href="#key-metrics-to-monitor">Key Metrics to Monitor</a></h2>
<ol>
<li><strong>Query Rate</strong> - Queries per second</li>
<li><strong>Query Latency</strong> - Response time</li>
<li><strong>Error Rate</strong> - Failed queries percentage</li>
<li><strong>Cache Hit Ratio</strong> - Cache effectiveness</li>
<li><strong>Zone Transfer Status</strong> - Success/failure of transfers</li>
<li><strong>Resource Usage</strong> - CPU and memory utilization</li>
<li><strong>Pod Health</strong> - Running vs desired replicas</li>
</ol>
<h2 id="grafana-dashboards"><a class="header" href="#grafana-dashboards">Grafana Dashboards</a></h2>
<p>Create dashboards for:</p>
<h3 id="dns-overview"><a class="header" href="#dns-overview">DNS Overview</a></h3>
<ul>
<li>Total query rate</li>
<li>Average latency</li>
<li>Error rate</li>
<li>Top queried domains</li>
</ul>
<h3 id="instance-health"><a class="header" href="#instance-health">Instance Health</a></h3>
<ul>
<li>Pod status</li>
<li>CPU/memory usage</li>
<li>Restart count</li>
<li>Network I/O</li>
</ul>
<h3 id="zone-management-1"><a class="header" href="#zone-management-1">Zone Management</a></h3>
<ul>
<li>Zones count</li>
<li>Records per zone</li>
<li>Zone transfer status</li>
<li>Serial numbers</li>
</ul>
<h2 id="alerting-thresholds"><a class="header" href="#alerting-thresholds">Alerting Thresholds</a></h2>
<p>Recommended alert thresholds:</p>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Warning</th><th>Critical</th></tr></thead><tbody>
<tr><td>CPU Usage</td><td>&gt; 70%</td><td>&gt; 90%</td></tr>
<tr><td>Memory Usage</td><td>&gt; 70%</td><td>&gt; 90%</td></tr>
<tr><td>Query Latency</td><td>&gt; 100ms</td><td>&gt; 500ms</td></tr>
<tr><td>Error Rate</td><td>&gt; 1%</td><td>&gt; 5%</td></tr>
<tr><td>Pod Restarts</td><td>&gt; 3/hour</td><td>&gt; 10/hour</td></tr>
</tbody></table>
</div>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<ol>
<li><strong>Baseline metrics</strong> - Establish normal operating ranges</li>
<li><strong>Set appropriate alerts</strong> - Avoid alert fatigue</li>
<li><strong>Monitor trends</strong> - Look for gradual degradation</li>
<li><strong>Capacity planning</strong> - Use metrics to plan scaling</li>
<li><strong>Regular review</strong> - Review dashboards weekly</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h1>
<p>Diagnose and resolve common issues with Bindy DNS operator.</p>
<h2 id="quick-diagnosis"><a class="header" href="#quick-diagnosis">Quick Diagnosis</a></h2>
<h3 id="check-overall-health"><a class="header" href="#check-overall-health">Check Overall Health</a></h3>
<pre><code class="language-bash"># Check all resources
kubectl get all -n dns-system

# Check CRDs
kubectl get bind9instances,dnszones,arecords -A

# Check events
kubectl get events -n dns-system --sort-by='.lastTimestamp' | tail -20
</code></pre>
<h3 id="view-status-conditions"><a class="header" href="#view-status-conditions">View Status Conditions</a></h3>
<pre><code class="language-bash"># Bind9Instance status
kubectl get bind9instance primary-dns -n dns-system -o yaml | yq '.status'

# DNSZone status
kubectl get dnszone example-com -n dns-system -o yaml | yq '.status'
</code></pre>
<h2 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h2>
<p>See <a href="operations/./common-issues.html">Common Issues</a> for frequently encountered problems and solutions.</p>
<h2 id="debugging-steps"><a class="header" href="#debugging-steps">Debugging Steps</a></h2>
<p>See <a href="operations/./debugging.html">Debugging Guide</a> for detailed debugging procedures.</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p>See <a href="operations/./faq.html">FAQ</a> for answers to frequently asked questions.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<h3 id="check-logs"><a class="header" href="#check-logs">Check Logs</a></h3>
<pre><code class="language-bash"># Controller logs
kubectl logs -n dns-system deployment/bindy --tail=100

# BIND9 instance logs
kubectl logs -n dns-system -l instance=primary-dns
</code></pre>
<h3 id="describe-resources"><a class="header" href="#describe-resources">Describe Resources</a></h3>
<pre><code class="language-bash"># Describe Bind9Instance
kubectl describe bind9instance primary-dns -n dns-system

# Describe pods
kubectl describe pod -n dns-system &lt;pod-name&gt;
</code></pre>
<h3 id="check-resource-status"><a class="header" href="#check-resource-status">Check Resource Status</a></h3>
<pre><code class="language-bash"># Get detailed status
kubectl get bind9instance primary-dns -n dns-system -o jsonpath='{.status}' | jq
</code></pre>
<h2 id="escalation"><a class="header" href="#escalation">Escalation</a></h2>
<p>If issues persist:</p>
<ol>
<li>Check <a href="operations/./common-issues.html">Common Issues</a></li>
<li>Review <a href="operations/./debugging.html">Debugging Guide</a></li>
<li>Check <a href="operations/./faq.html">FAQ</a></li>
<li>Search GitHub issues: https://github.com/firestoned/bindy/issues</li>
<li>Create a new issue with:
<ul>
<li>Kubernetes version</li>
<li>Bindy version</li>
<li>Resource YAMLs</li>
<li>Controller logs</li>
<li>Error messages</li>
</ul>
</li>
</ol>
<h2 id="next-steps-23"><a class="header" href="#next-steps-23">Next Steps</a></h2>
<ul>
<li><a href="operations/./common-issues.html">Common Issues</a> - Frequently encountered problems</li>
<li><a href="operations/./debugging.html">Debugging</a> - Step-by-step debugging</li>
<li><a href="operations/./faq.html">FAQ</a> - Frequently asked questions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h1>
<p>Solutions to frequently encountered problems.</p>
<h2 id="bind9instance-issues"><a class="header" href="#bind9instance-issues">Bind9Instance Issues</a></h2>
<h3 id="pods-not-starting"><a class="header" href="#pods-not-starting">Pods Not Starting</a></h3>
<p><strong>Symptom:</strong> Bind9Instance created but pods not running</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash">kubectl get pods -n dns-system -l instance=primary-dns
kubectl describe pod -n dns-system &lt;pod-name&gt;
</code></pre>
<p><strong>Common Causes:</strong></p>
<ol>
<li><strong>Image pull errors</strong> - Check image name and registry access</li>
<li><strong>Resource limits</strong> - Insufficient CPU/memory on nodes</li>
<li><strong>RBAC issues</strong> - ServiceAccount lacks permissions</li>
</ol>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Check events
kubectl get events -n dns-system

# Fix resource limits
kubectl edit bind9instance primary-dns -n dns-system
# Increase resources.requests and resources.limits

# Verify RBAC
kubectl auth can-i create deployments \
  --as=system:serviceaccount:dns-system:bindy
</code></pre>
<h3 id="configmap-not-created"><a class="header" href="#configmap-not-created">ConfigMap Not Created</a></h3>
<p><strong>Symptom:</strong> ConfigMap missing for Bind9Instance</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash">kubectl get configmap -n dns-system
kubectl logs -n dns-system deployment/bindy | grep ConfigMap
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Check controller logs for errors
kubectl logs -n dns-system deployment/bindy --tail=50

# Delete and recreate instance
kubectl delete bind9instance primary-dns -n dns-system
kubectl apply -f instance.yaml
</code></pre>
<h2 id="dnszone-issues"><a class="header" href="#dnszone-issues">DNSZone Issues</a></h2>
<h3 id="no-instances-match-selector"><a class="header" href="#no-instances-match-selector">No Instances Match Selector</a></h3>
<p><strong>Symptom:</strong> DNSZone status shows "No Bind9Instances matched selector"</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash">kubectl get bind9instances -n dns-system --show-labels
kubectl get dnszone example-com -n dns-system -o yaml | yq '.spec.instanceSelector'
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Verify labels on instances
kubectl label bind9instance primary-dns dns-role=primary -n dns-system

# Or update zone selector
kubectl edit dnszone example-com -n dns-system
</code></pre>
<h3 id="zone-file-not-created"><a class="header" href="#zone-file-not-created">Zone File Not Created</a></h3>
<p><strong>Symptom:</strong> Zone exists but no zone file in BIND9</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash">kubectl exec -n dns-system deployment/primary-dns -- ls -la /var/lib/bind/zones/
kubectl logs -n dns-system deployment/bindy | grep "example-com"
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Check if zone reconciliation succeeded
kubectl describe dnszone example-com -n dns-system

# Trigger reconciliation by updating zone
kubectl annotate dnszone example-com reconcile=true -n dns-system
</code></pre>
<h2 id="dns-record-issues"><a class="header" href="#dns-record-issues">DNS Record Issues</a></h2>
<h3 id="record-not-appearing-in-zone"><a class="header" href="#record-not-appearing-in-zone">Record Not Appearing in Zone</a></h3>
<p><strong>Symptom:</strong> ARecord created but not in zone file</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash"># Check record status
kubectl get arecord www-example -n dns-system -o yaml

# Check zone file
kubectl exec -n dns-system deployment/primary-dns -- cat /var/lib/bind/zones/example.com.zone
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Verify zone reference is correct
kubectl get arecord www-example -n dns-system -o jsonpath='{.spec.zone}'

# Should match DNSZone resource name
kubectl get dnszones -n dns-system

# Update if incorrect
kubectl edit arecord www-example -n dns-system
</code></pre>
<h3 id="dns-query-not-resolving"><a class="header" href="#dns-query-not-resolving">DNS Query Not Resolving</a></h3>
<p><strong>Symptom:</strong> dig/nslookup fails to resolve</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash"># Get DNS service IP
SERVICE_IP=$(kubectl get svc primary-dns -n dns-system -o jsonpath='{.spec.clusterIP}')

# Test query
dig @$SERVICE_IP www.example.com

# Check BIND9 logs
kubectl logs -n dns-system -l instance=primary-dns | tail -20
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li><strong>Record doesn't exist:</strong></li>
</ol>
<pre><code class="language-bash">kubectl get arecords -n dns-system
kubectl apply -f record.yaml
</code></pre>
<ol start="2">
<li><strong>Zone not loaded:</strong></li>
</ol>
<pre><code class="language-bash">kubectl logs -n dns-system -l instance=primary-dns | grep "loaded serial"
</code></pre>
<ol start="3">
<li><strong>Network policy blocking:</strong></li>
</ol>
<pre><code class="language-bash">kubectl get networkpolicies -n dns-system
</code></pre>
<h2 id="zone-transfer-issues"><a class="header" href="#zone-transfer-issues">Zone Transfer Issues</a></h2>
<h3 id="secondary-not-receiving-transfers"><a class="header" href="#secondary-not-receiving-transfers">Secondary Not Receiving Transfers</a></h3>
<p><strong>Symptom:</strong> Secondary instance not getting zone updates</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash"># Check secondary logs
kubectl logs -n dns-system -l dns-role=secondary | grep transfer

# Check primary allows transfers
kubectl get bind9instance primary-dns -n dns-system -o jsonpath='{.spec.config.allowTransfer}'
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Update primary to allow transfers
kubectl edit bind9instance primary-dns -n dns-system

# Add secondary network to allowTransfer:
spec:
  config:
    allowTransfer:
      - "10.0.0.0/8"

# Verify network connectivity
kubectl exec -n dns-system deployment/secondary-dns -- dig @primary-dns-service AXFR example.com
</code></pre>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="high-query-latency"><a class="header" href="#high-query-latency">High Query Latency</a></h3>
<p><strong>Symptom:</strong> DNS queries taking too long</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash"># Test query time
time dig @$SERVICE_IP example.com

# Check resource usage
kubectl top pods -n dns-system -l instance=primary-dns
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li><strong>Increase resources:</strong></li>
</ol>
<pre><code class="language-yaml">spec:
  resources:
    limits:
      cpu: "1000m"
      memory: "1Gi"
</code></pre>
<ol start="2">
<li><strong>Add more replicas:</strong></li>
</ol>
<pre><code class="language-yaml">spec:
  replicas: 3
</code></pre>
<ol start="3">
<li><strong>Enable caching</strong> (if appropriate for your use case)</li>
</ol>
<h2 id="rbac-issues"><a class="header" href="#rbac-issues">RBAC Issues</a></h2>
<h3 id="forbidden-errors-in-logs"><a class="header" href="#forbidden-errors-in-logs">Forbidden Errors in Logs</a></h3>
<p><strong>Symptom:</strong> Controller logs show "Forbidden" errors</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash">kubectl logs -n dns-system deployment/bindy | grep Forbidden

# Check permissions
kubectl auth can-i create deployments \
  --as=system:serviceaccount:dns-system:bindy \
  -n dns-system
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Reapply RBAC
kubectl apply -f deploy/rbac/

# Verify ClusterRoleBinding
kubectl get clusterrolebinding bindy-rolebinding -o yaml

# Restart controller
kubectl rollout restart deployment/bindy -n dns-system
</code></pre>
<h2 id="next-steps-24"><a class="header" href="#next-steps-24">Next Steps</a></h2>
<ul>
<li><a href="operations/./debugging.html">Debugging Guide</a> - Detailed debugging procedures</li>
<li><a href="operations/./faq.html">FAQ</a> - Frequently asked questions</li>
<li><a href="operations/./logging.html">Logging</a> - Log analysis</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Step-by-step guide to debugging Bindy DNS operator issues.</p>
<h2 id="debug-workflow"><a class="header" href="#debug-workflow">Debug Workflow</a></h2>
<h3 id="1-identify-the-problem"><a class="header" href="#1-identify-the-problem">1. Identify the Problem</a></h3>
<p>Determine what's not working:</p>
<ul>
<li>Bind9Instance not creating pods?</li>
<li>DNSZone not loading?</li>
<li>DNS records not resolving?</li>
<li>Zone transfers failing?</li>
</ul>
<h3 id="2-check-resource-status"><a class="header" href="#2-check-resource-status">2. Check Resource Status</a></h3>
<pre><code class="language-bash"># Get high-level status
kubectl get bind9instances,dnszones,arecords -A

# Check specific resource
kubectl describe bind9instance primary-dns -n dns-system
kubectl describe dnszone example-com -n dns-system
</code></pre>
<h3 id="3-review-events"><a class="header" href="#3-review-events">3. Review Events</a></h3>
<pre><code class="language-bash"># Recent events
kubectl get events -n dns-system --sort-by='.lastTimestamp'

# Events for specific resource
kubectl describe dnszone example-com -n dns-system | grep -A10 Events
</code></pre>
<h3 id="4-examine-logs"><a class="header" href="#4-examine-logs">4. Examine Logs</a></h3>
<pre><code class="language-bash"># Controller logs
kubectl logs -n dns-system deployment/bindy --tail=100

# BIND9 instance logs
kubectl logs -n dns-system -l instance=primary-dns --tail=50

# Follow logs in real-time
kubectl logs -n dns-system deployment/bindy -f
</code></pre>
<h2 id="debugging-bind9instance"><a class="header" href="#debugging-bind9instance">Debugging Bind9Instance</a></h2>
<h3 id="issue-pods-not-starting"><a class="header" href="#issue-pods-not-starting">Issue: Pods Not Starting</a></h3>
<pre><code class="language-bash"># 1. Check pod status
kubectl get pods -n dns-system -l instance=primary-dns

# 2. Describe pod
kubectl describe pod -n dns-system &lt;pod-name&gt;

# 3. Check events
kubectl get events -n dns-system --field-selector involvedObject.name=&lt;pod-name&gt;

# 4. Check logs if pod is running
kubectl logs -n dns-system &lt;pod-name&gt;

# 5. Check deployment
kubectl describe deployment primary-dns -n dns-system
</code></pre>
<h3 id="issue-configmap-not-created"><a class="header" href="#issue-configmap-not-created">Issue: ConfigMap Not Created</a></h3>
<pre><code class="language-bash"># 1. List ConfigMaps
kubectl get configmaps -n dns-system

# 2. Check controller logs
kubectl logs -n dns-system deployment/bindy | grep -i configmap

# 3. Check RBAC permissions
kubectl auth can-i create configmaps \
  --as=system:serviceaccount:dns-system:bindy \
  -n dns-system

# 4. Manually trigger reconciliation
kubectl annotate bind9instance primary-dns reconcile=true -n dns-system --overwrite
</code></pre>
<h2 id="debugging-dnszone"><a class="header" href="#debugging-dnszone">Debugging DNSZone</a></h2>
<h3 id="issue-no-instances-match-selector"><a class="header" href="#issue-no-instances-match-selector">Issue: No Instances Match Selector</a></h3>
<pre><code class="language-bash"># 1. Check zone selector
kubectl get dnszone example-com -n dns-system -o yaml | grep -A5 instanceSelector

# 2. List instances with labels
kubectl get bind9instances -n dns-system --show-labels

# 3. Test selector match
kubectl get bind9instances -n dns-system \
  -l dns-role=primary,environment=production

# 4. Fix labels or selector
kubectl label bind9instance primary-dns dns-role=primary -n dns-system
# Or edit zone selector
kubectl edit dnszone example-com -n dns-system
</code></pre>
<h3 id="issue-zone-file-missing"><a class="header" href="#issue-zone-file-missing">Issue: Zone File Missing</a></h3>
<pre><code class="language-bash"># 1. Check if zone reconciliation succeeded
kubectl get dnszone example-com -n dns-system -o jsonpath='{.status.conditions}'

# 2. Exec into pod and check zones directory
kubectl exec -n dns-system deployment/primary-dns -- ls -la /var/lib/bind/zones/

# 3. Check BIND9 configuration
kubectl exec -n dns-system deployment/primary-dns -- cat /etc/bind/named.conf

# 4. Check BIND9 logs
kubectl logs -n dns-system -l instance=primary-dns | grep "example.com"

# 5. Reload BIND9 configuration
kubectl exec -n dns-system deployment/primary-dns -- rndc reload
</code></pre>
<h2 id="debugging-dns-records"><a class="header" href="#debugging-dns-records">Debugging DNS Records</a></h2>
<h3 id="issue-record-not-in-zone-file"><a class="header" href="#issue-record-not-in-zone-file">Issue: Record Not in Zone File</a></h3>
<pre><code class="language-bash"># 1. Verify record exists
kubectl get arecord www-example -n dns-system

# 2. Check record status
kubectl get arecord www-example -n dns-system -o jsonpath='{.status}'

# 3. Verify zone reference
kubectl get arecord www-example -n dns-system -o jsonpath='{.spec.zone}'
# Should match a DNSZone resource name

# 4. Check zone file contents
kubectl exec -n dns-system deployment/primary-dns -- \
  cat /var/lib/bind/zones/example.com.zone

# 5. Trigger record reconciliation
kubectl annotate arecord www-example reconcile=true -n dns-system --overwrite
</code></pre>
<h3 id="issue-dns-query-not-resolving"><a class="header" href="#issue-dns-query-not-resolving">Issue: DNS Query Not Resolving</a></h3>
<pre><code class="language-bash"># 1. Get DNS service IP
SERVICE_IP=$(kubectl get svc primary-dns -n dns-system -o jsonpath='{.spec.clusterIP}')

# 2. Test query from within cluster
kubectl run -it --rm debug --image=nicolaka/netshoot --restart=Never -- \
  dig @$SERVICE_IP www.example.com

# 3. Test query from BIND9 pod directly
kubectl exec -n dns-system deployment/primary-dns -- \
  dig @localhost www.example.com

# 4. Check if zone is loaded
kubectl exec -n dns-system deployment/primary-dns -- \
  rndc status | grep "zones loaded"

# 5. Query zone status
kubectl exec -n dns-system deployment/primary-dns -- \
  rndc zonestatus example.com
</code></pre>
<h2 id="debugging-zone-transfers"><a class="header" href="#debugging-zone-transfers">Debugging Zone Transfers</a></h2>
<h3 id="issue-secondary-not-receiving-transfers"><a class="header" href="#issue-secondary-not-receiving-transfers">Issue: Secondary Not Receiving Transfers</a></h3>
<pre><code class="language-bash"># 1. Check primary allows transfers
kubectl get bind9instance primary-dns -n dns-system \
  -o jsonpath='{.spec.config.allowTransfer}'

# 2. Check secondary configuration
kubectl get dnszone example-com-secondary -n dns-system \
  -o jsonpath='{.spec.secondaryConfig}'

# 3. Test network connectivity
kubectl exec -n dns-system deployment/secondary-dns -- \
  nc -zv primary-dns-service 53

# 4. Attempt manual transfer
kubectl exec -n dns-system deployment/secondary-dns -- \
  dig @primary-dns-service example.com AXFR

# 5. Check transfer logs
kubectl logs -n dns-system -l dns-role=secondary | grep -i transfer

# 6. Check NOTIFY messages
kubectl logs -n dns-system -l dns-role=primary | grep -i notify
</code></pre>
<h2 id="enable-debug-logging"><a class="header" href="#enable-debug-logging">Enable Debug Logging</a></h2>
<h3 id="controller-debug-logging"><a class="header" href="#controller-debug-logging">Controller Debug Logging</a></h3>
<pre><code class="language-bash"># Edit controller deployment
kubectl set env deployment/bindy RUST_LOG=debug -n dns-system

# Or patch deployment
kubectl patch deployment bindy -n dns-system \
  -p '{"spec":{"template":{"spec":{"containers":[{"name":"controller","env":[{"name":"RUST_LOG","value":"debug"}]}]}}}}'

# Restart controller
kubectl rollout restart deployment/bindy -n dns-system

# View debug logs
kubectl logs -n dns-system deployment/bindy -f
</code></pre>
<h3 id="bind9-debug-logging"><a class="header" href="#bind9-debug-logging">BIND9 Debug Logging</a></h3>
<pre><code class="language-bash"># Enable query logging
kubectl exec -n dns-system deployment/primary-dns -- \
  rndc querylog on

# View queries
kubectl logs -n dns-system -l instance=primary-dns -f | grep "query:"

# Disable query logging
kubectl exec -n dns-system deployment/primary-dns -- \
  rndc querylog off
</code></pre>
<h2 id="network-debugging"><a class="header" href="#network-debugging">Network Debugging</a></h2>
<h3 id="test-dns-resolution"><a class="header" href="#test-dns-resolution">Test DNS Resolution</a></h3>
<pre><code class="language-bash"># From debug pod
kubectl run -it --rm debug --image=nicolaka/netshoot --restart=Never -- /bin/bash

# Inside pod:
dig @primary-dns-service.dns-system.svc.cluster.local www.example.com
nslookup www.example.com primary-dns-service.dns-system.svc.cluster.local
host www.example.com primary-dns-service.dns-system.svc.cluster.local
</code></pre>
<h3 id="check-network-policies"><a class="header" href="#check-network-policies">Check Network Policies</a></h3>
<pre><code class="language-bash"># List network policies
kubectl get networkpolicies -n dns-system

# Describe policy
kubectl describe networkpolicy &lt;policy-name&gt; -n dns-system

# Temporarily remove policy for testing
kubectl delete networkpolicy &lt;policy-name&gt; -n dns-system
</code></pre>
<h2 id="performance-debugging"><a class="header" href="#performance-debugging">Performance Debugging</a></h2>
<h3 id="check-resource-usage"><a class="header" href="#check-resource-usage">Check Resource Usage</a></h3>
<pre><code class="language-bash"># Pod resource usage
kubectl top pods -n dns-system

# Node pressure
kubectl describe nodes | grep -A5 "Conditions:\|Allocated resources:"

# Detailed pod metrics
kubectl describe pod &lt;pod-name&gt; -n dns-system | grep -A10 "Limits:\|Requests:"
</code></pre>
<h3 id="profile-dns-queries"><a class="header" href="#profile-dns-queries">Profile DNS Queries</a></h3>
<pre><code class="language-bash"># Measure query latency
for i in {1..100}; do
  dig @$SERVICE_IP www.example.com +stats | grep "Query time:"
done | awk '{sum+=$4; count++} END {print "Average:", sum/count, "ms"}'

# Test concurrent queries
seq 1 100 | xargs -I{} -P10 dig @$SERVICE_IP www.example.com +short
</code></pre>
<h2 id="collect-diagnostic-information"><a class="header" href="#collect-diagnostic-information">Collect Diagnostic Information</a></h2>
<h3 id="create-support-bundle"><a class="header" href="#create-support-bundle">Create Support Bundle</a></h3>
<pre><code class="language-bash">#!/bin/bash
# collect-diagnostics.sh

NAMESPACE="dns-system"
OUTPUT_DIR="bindy-diagnostics-$(date +%Y%m%d-%H%M%S)"

mkdir -p $OUTPUT_DIR

# Collect resources
kubectl get all -n $NAMESPACE -o yaml &gt; $OUTPUT_DIR/resources.yaml
kubectl get bind9instances,dnszones,arecords,aaaarecords,cnamerecords -A -o yaml &gt; $OUTPUT_DIR/crds.yaml

# Collect logs
kubectl logs -n $NAMESPACE deployment/bindy --tail=1000 &gt; $OUTPUT_DIR/controller.log
kubectl logs -n $NAMESPACE -l app=bind9 --tail=1000 &gt; $OUTPUT_DIR/bind9.log

# Collect events
kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' &gt; $OUTPUT_DIR/events.txt

# Collect status
kubectl describe bind9instances -A &gt; $OUTPUT_DIR/bind9instances-describe.txt
kubectl describe dnszones -A &gt; $OUTPUT_DIR/dnszones-describe.txt

# Create archive
tar -czf $OUTPUT_DIR.tar.gz $OUTPUT_DIR/

echo "Diagnostics collected in $OUTPUT_DIR.tar.gz"
</code></pre>
<h2 id="next-steps-25"><a class="header" href="#next-steps-25">Next Steps</a></h2>
<ul>
<li><a href="operations/./common-issues.html">Common Issues</a> - Known problems and solutions</li>
<li><a href="operations/./faq.html">FAQ</a> - Frequently asked questions</li>
<li><a href="operations/./logging.html">Logging</a> - Log configuration and analysis</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq-frequently-asked-questions"><a class="header" href="#faq-frequently-asked-questions">FAQ (Frequently Asked Questions)</a></h1>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<h3 id="what-is-bindy-1"><a class="header" href="#what-is-bindy-1">What is Bindy?</a></h3>
<p>Bindy is a Kubernetes operator that manages BIND9 DNS servers using Custom Resource Definitions (CRDs). It allows you to manage DNS zones and records declaratively using Kubernetes resources.</p>
<h3 id="why-use-bindy-instead-of-manual-bind9-configuration"><a class="header" href="#why-use-bindy-instead-of-manual-bind9-configuration">Why use Bindy instead of manual BIND9 configuration?</a></h3>
<ul>
<li><strong>Declarative</strong>: Define DNS infrastructure as Kubernetes resources</li>
<li><strong>GitOps-friendly</strong>: Version control your DNS configuration</li>
<li><strong>Kubernetes-native</strong>: Uses familiar kubectl commands</li>
<li><strong>Automated</strong>: Controller handles BIND9 configuration and reloading</li>
<li><strong>Scalable</strong>: Easy multi-region, multi-instance deployments</li>
</ul>
<h3 id="what-bind9-versions-are-supported"><a class="header" href="#what-bind9-versions-are-supported">What BIND9 versions are supported?</a></h3>
<p>Bindy supports BIND 9.16 and 9.18. The version is configurable per Bind9Instance.</p>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<h3 id="can-i-run-bindy-in-a-namespace-other-than-dns-system"><a class="header" href="#can-i-run-bindy-in-a-namespace-other-than-dns-system">Can I run Bindy in a namespace other than dns-system?</a></h3>
<p>Yes, you can deploy Bindy in any namespace. Update the namespace in deployment YAMLs and RBAC resources.</p>
<h3 id="do-i-need-cluster-admin-permissions"><a class="header" href="#do-i-need-cluster-admin-permissions">Do I need cluster-admin permissions?</a></h3>
<p>You need permissions to:</p>
<ul>
<li>Create CRDs (cluster-scoped)</li>
<li>Create ClusterRole and ClusterRoleBinding</li>
<li>Create resources in the operator namespace</li>
</ul>
<p>A cluster administrator can pre-install CRDs and RBAC, then delegate namespace management.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="how-do-i-update-bind9-configuration"><a class="header" href="#how-do-i-update-bind9-configuration">How do I update BIND9 configuration?</a></h3>
<p>Edit the Bind9Instance resource:</p>
<pre><code class="language-bash">kubectl edit bind9instance primary-dns -n dns-system
</code></pre>
<p>The controller will automatically update the ConfigMap and restart pods if needed.</p>
<h3 id="can-i-use-external-bind9-servers"><a class="header" href="#can-i-use-external-bind9-servers">Can I use external BIND9 servers?</a></h3>
<p>No, Bindy manages BIND9 instances running in Kubernetes. For external servers, consider DNS integration tools.</p>
<h3 id="how-do-i-enable-query-logging"><a class="header" href="#how-do-i-enable-query-logging">How do I enable query logging?</a></h3>
<p>Currently, enable it manually in the BIND9 pod:</p>
<pre><code class="language-bash">kubectl exec -n dns-system deployment/primary-dns -- rndc querylog on
</code></pre>
<p>Future versions may support configuration through Bind9Instance spec.</p>
<h2 id="dns-zones"><a class="header" href="#dns-zones">DNS Zones</a></h2>
<h3 id="how-many-zones-can-one-instance-host"><a class="header" href="#how-many-zones-can-one-instance-host">How many zones can one instance host?</a></h3>
<p>BIND9 can handle thousands of zones. Practical limits depend on:</p>
<ul>
<li>Resource allocation (CPU/memory)</li>
<li>Query volume</li>
<li>Zone size</li>
</ul>
<p>Start with 100-500 zones per instance and scale as needed.</p>
<h3 id="can-i-host-the-same-zone-on-multiple-instances"><a class="header" href="#can-i-host-the-same-zone-on-multiple-instances">Can I host the same zone on multiple instances?</a></h3>
<p>Yes! Use label selectors to target multiple instances:</p>
<pre><code class="language-yaml">instanceSelector:
  matchLabels:
    environment: production
</code></pre>
<p>This deploys the zone to all matching instances.</p>
<h3 id="how-do-i-migrate-zones-between-instances"><a class="header" href="#how-do-i-migrate-zones-between-instances">How do I migrate zones between instances?</a></h3>
<p>Update the DNSZone's instance Selector:</p>
<pre><code class="language-yaml">instanceSelector:
  matchLabels:
    dns-role: new-primary
</code></pre>
<p>The zone will be created on new instances and you can delete from old ones.</p>
<h2 id="dns-records-1"><a class="header" href="#dns-records-1">DNS Records</a></h2>
<h3 id="how-do-i-create-multiple-a-records-for-the-same-name"><a class="header" href="#how-do-i-create-multiple-a-records-for-the-same-name">How do I create multiple A records for the same name?</a></h3>
<p>Create multiple ARecord resources with different names but same spec.name:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-1
spec:
  zone: example-com
  name: www
  ipv4Address: "192.0.2.1"
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-2
spec:
  zone: example-com
  name: www
  ipv4Address: "192.0.2.2"
</code></pre>
<h3 id="can-i-import-existing-zone-files"><a class="header" href="#can-i-import-existing-zone-files">Can I import existing zone files?</a></h3>
<p>Not directly. You need to convert zone files to Bindy CRD resources. Future versions may include an import tool.</p>
<h3 id="how-do-i-delete-all-records-in-a-zone"><a class="header" href="#how-do-i-delete-all-records-in-a-zone">How do I delete all records in a zone?</a></h3>
<pre><code class="language-bash">kubectl delete arecords,aaaarecords,cnamerecords,mxrecords,txtrecords \
  -n dns-system -l zone=example-com
</code></pre>
<p>(If you label records with their zone)</p>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<h3 id="how-do-i-upgrade-bindy"><a class="header" href="#how-do-i-upgrade-bindy">How do I upgrade Bindy?</a></h3>
<ol>
<li>Update CRDs: <code>kubectl apply -k deploy/crds/</code></li>
<li>Update controller: <code>kubectl set image deployment/bindy controller=new-image</code></li>
<li>Monitor rollout: <code>kubectl rollout status deployment/bindy -n dns-system</code></li>
</ol>
<h3 id="how-do-i-backup-dns-configuration"><a class="header" href="#how-do-i-backup-dns-configuration">How do I backup DNS configuration?</a></h3>
<pre><code class="language-bash"># Export all CRDs
kubectl get bind9instances,dnszones,arecords,aaaarecords,cnamerecords,mxrecords,txtrecords,nsrecords,srvrecords,caarecords \
  -A -o yaml &gt; bindy-backup.yaml
</code></pre>
<p>Store in version control or backup storage.</p>
<h3 id="how-do-i-restore-from-backup"><a class="header" href="#how-do-i-restore-from-backup">How do I restore from backup?</a></h3>
<pre><code class="language-bash">kubectl apply -f bindy-backup.yaml
</code></pre>
<h3 id="can-i-run-bindy-in-high-availability-mode"><a class="header" href="#can-i-run-bindy-in-high-availability-mode">Can I run Bindy in high availability mode?</a></h3>
<p>Yes, run multiple controller replicas:</p>
<pre><code class="language-yaml">spec:
  replicas: 2  # Multiple controller replicas
</code></pre>
<p>Only one will be active (leader election), others are standby.</p>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="pods-are-crashlooping"><a class="header" href="#pods-are-crashlooping">Pods are crashlooping</a></h3>
<p>Check pod logs and events:</p>
<pre><code class="language-bash">kubectl logs -n dns-system &lt;pod-name&gt;
kubectl describe pod -n dns-system &lt;pod-name&gt;
</code></pre>
<p>Common causes:</p>
<ul>
<li>Invalid BIND9 configuration</li>
<li>Insufficient resources</li>
<li>Image pull errors</li>
</ul>
<h3 id="dns-queries-timing-out"><a class="header" href="#dns-queries-timing-out">DNS queries timing out</a></h3>
<p>Check:</p>
<ol>
<li>Service is correctly exposing pods</li>
<li>Pods are ready</li>
<li>Query is reaching BIND9 (check logs)</li>
<li>Zone is loaded</li>
<li>Record exists</li>
</ol>
<pre><code class="language-bash">kubectl get svc -n dns-system
kubectl get pods -n dns-system
kubectl logs -n dns-system -l instance=primary-dns
</code></pre>
<h3 id="zone-transfers-not-working"><a class="header" href="#zone-transfers-not-working">Zone transfers not working</a></h3>
<p>Ensure:</p>
<ol>
<li>Primary allows transfers: <code>spec.config.allowTransfer</code></li>
<li>Network connectivity between primary and secondary</li>
<li>Secondary has correct primary server IPs</li>
<li>Firewall rules allow TCP port 53</li>
</ol>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<h3 id="how-do-i-optimize-for-high-query-volume"><a class="header" href="#how-do-i-optimize-for-high-query-volume">How do I optimize for high query volume?</a></h3>
<ol>
<li><strong>Increase replicas</strong>: More pods = more capacity</li>
<li><strong>Add resources</strong>: Increase CPU/memory limits</li>
<li><strong>Use caching</strong>: If appropriate for your use case</li>
<li><strong>Geographic distribution</strong>: Deploy instances near clients</li>
<li><strong>Load balancing</strong>: Use service load balancing</li>
</ol>
<h3 id="what-are-typical-resource-requirements"><a class="header" href="#what-are-typical-resource-requirements">What are typical resource requirements?</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Deployment Size</th><th>CPU Request</th><th>Memory Request</th><th>CPU Limit</th><th>Memory Limit</th></tr></thead><tbody>
<tr><td>Small (&lt;50 zones)</td><td>100m</td><td>128Mi</td><td>500m</td><td>512Mi</td></tr>
<tr><td>Medium (50-500 zones)</td><td>200m</td><td>256Mi</td><td>1000m</td><td>1Gi</td></tr>
<tr><td>Large (500+ zones)</td><td>500m</td><td>512Mi</td><td>2000m</td><td>2Gi</td></tr>
</tbody></table>
</div>
<p>Adjust based on actual usage monitoring.</p>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<h3 id="is-dnssec-supported"><a class="header" href="#is-dnssec-supported">Is DNSSEC supported?</a></h3>
<p>Yes, enable DNSSEC in Bind9Instance spec:</p>
<pre><code class="language-yaml">spec:
  config:
    dnssec:
      enabled: true
      validation: true
</code></pre>
<h3 id="how-do-i-restrict-access-to-dns-queries"><a class="header" href="#how-do-i-restrict-access-to-dns-queries">How do I restrict access to DNS queries?</a></h3>
<p>Use <code>allowQuery</code> in Bind9Instance spec:</p>
<pre><code class="language-yaml">spec:
  config:
    allowQuery:
      - "10.0.0.0/8"  # Only internal network
</code></pre>
<h3 id="are-zone-transfers-secure"><a class="header" href="#are-zone-transfers-secure">Are zone transfers secure?</a></h3>
<p>Zone transfers occur over TCP and can be restricted by IP address using <code>allowTransfer</code>. For additional security, consider:</p>
<ul>
<li>Network policies</li>
<li>IPsec or VPN between regions</li>
<li>TSIG keys (future enhancement)</li>
</ul>
<h2 id="integration"><a class="header" href="#integration">Integration</a></h2>
<h3 id="can-i-use-bindy-with-external-dns"><a class="header" href="#can-i-use-bindy-with-external-dns">Can I use Bindy with external-dns?</a></h3>
<p>Bindy manages internal DNS infrastructure. external-dns manages external DNS providers. They serve different purposes and can coexist.</p>
<h3 id="does-bindy-work-with-service-meshes"><a class="header" href="#does-bindy-work-with-service-meshes">Does Bindy work with service meshes?</a></h3>
<p>Yes, Bindy DNS servers can be used by service mesh for internal DNS resolution.</p>
<h3 id="can-i-integrate-with-existing-dns-infrastructure"><a class="header" href="#can-i-integrate-with-existing-dns-infrastructure">Can I integrate with existing DNS infrastructure?</a></h3>
<p>Yes, configure Bindy instances as secondaries receiving transfers from existing primaries, or vice versa.</p>
<h2 id="next-steps-26"><a class="header" href="#next-steps-26">Next Steps</a></h2>
<ul>
<li><a href="operations/./troubleshooting.html">Troubleshooting</a> - Debug issues</li>
<li><a href="operations/./common-issues.html">Common Issues</a> - Known problems</li>
<li><a href="operations/./debugging.html">Debugging</a> - Detailed debugging steps</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-availability-1"><a class="header" href="#high-availability-1">High Availability</a></h1>
<p>Design and implement highly available DNS infrastructure with Bindy.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>High availability (HA) DNS ensures continuous DNS service even during:</p>
<ul>
<li>Pod failures</li>
<li>Node failures</li>
<li>Availability zone outages</li>
<li>Regional outages</li>
<li>Planned maintenance</li>
</ul>
<h2 id="ha-architecture-components"><a class="header" href="#ha-architecture-components">HA Architecture Components</a></h2>
<h3 id="1-multiple-replicas"><a class="header" href="#1-multiple-replicas">1. Multiple Replicas</a></h3>
<p>Run multiple replicas of each Bind9Instance:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
spec:
  replicas: 3  # Multiple replicas for pod-level HA
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Survives pod crashes</li>
<li>Load distribution</li>
<li>Zero-downtime updates</li>
</ul>
<h3 id="2-multiple-instances"><a class="header" href="#2-multiple-instances">2. Multiple Instances</a></h3>
<p>Deploy separate primary and secondary instances:</p>
<pre><code class="language-yaml"># Primary instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  labels:
    dns-role: primary
spec:
  replicas: 2
---
# Secondary instance  
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-dns
  labels:
    dns-role: secondary
spec:
  replicas: 2
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Role separation</li>
<li>Independent scaling</li>
<li>Failover capability</li>
</ul>
<h3 id="3-geographic-distribution"><a class="header" href="#3-geographic-distribution">3. Geographic Distribution</a></h3>
<p>Deploy instances across multiple regions:</p>
<pre><code class="language-yaml"># US East primary
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-us-east
  labels:
    dns-role: primary
    region: us-east-1
spec:
  replicas: 2
---
# US West secondary
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-us-west
  labels:
    dns-role: secondary
    region: us-west-2
spec:
  replicas: 2
---
# EU secondary
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-eu-west
  labels:
    dns-role: secondary
    region: eu-west-1
spec:
  replicas: 2
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Regional failure tolerance</li>
<li>Lower latency for global users</li>
<li>Regulatory compliance (data locality)</li>
</ul>
<h2 id="ha-patterns"><a class="header" href="#ha-patterns">HA Patterns</a></h2>
<h3 id="pattern-1-active-passive"><a class="header" href="#pattern-1-active-passive">Pattern 1: Active-Passive</a></h3>
<p>One active primary, multiple passive secondaries:</p>
<pre><code>┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│   Primary    │────────▶│  Secondary   │────────▶│  Secondary   │
│  (Active)    │  AXFR   │  (Passive)   │  AXFR   │  (Passive)   │
│  us-east-1   │         │  us-west-2   │         │  eu-west-1   │
└──────────────┘         └──────────────┘         └──────────────┘
        │                        │                        │
        └────────────────────────┴────────────────────────┘
                        Clients query any
</code></pre>
<ul>
<li>Updates go to primary only</li>
<li>Secondaries receive via zone transfer</li>
<li>Clients query any available instance</li>
</ul>
<h3 id="pattern-2-multi-primary"><a class="header" href="#pattern-2-multi-primary">Pattern 2: Multi-Primary</a></h3>
<p>Multiple primaries in different regions:</p>
<pre><code>┌──────────────┐         ┌──────────────┐
│   Primary    │◀───────▶│   Primary    │
│  (zone-a)    │  Sync   │  (zone-b)    │
│  us-east-1   │         │  eu-west-1   │
└──────────────┘         └──────────────┘
</code></pre>
<ul>
<li>Different zones on different primaries</li>
<li>Geographic distribution of updates</li>
<li>Careful coordination required</li>
</ul>
<h3 id="pattern-3-anycast"><a class="header" href="#pattern-3-anycast">Pattern 3: Anycast</a></h3>
<p>Same IP announced from multiple locations:</p>
<pre><code>        Client Query (192.0.2.53)
                 │
         ┌───────┼───────┐
         ▼       ▼       ▼
      ┌────┐  ┌────┐  ┌────┐
      │DNS │  │DNS │  │DNS │
      │US  │  │EU  │  │APAC│
      └────┘  └────┘  └────┘
</code></pre>
<ul>
<li>Requires BGP routing</li>
<li>Lowest latency routing</li>
<li>Automatic failover</li>
</ul>
<h2 id="pod-level-ha"><a class="header" href="#pod-level-ha">Pod-Level HA</a></h2>
<h3 id="anti-affinity"><a class="header" href="#anti-affinity">Anti-Affinity</a></h3>
<p>Spread pods across nodes:</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: primary-dns
spec:
  replicas: 3
  template:
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: instance
                  operator: In
                  values:
                  - primary-dns
              topologyKey: kubernetes.io/hostname
</code></pre>
<h3 id="topology-spread"><a class="header" href="#topology-spread">Topology Spread</a></h3>
<p>Distribute across availability zones:</p>
<pre><code class="language-yaml">spec:
  topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: DoNotSchedule
    labelSelector:
      matchLabels:
        instance: primary-dns
</code></pre>
<h2 id="service-level-ha"><a class="header" href="#service-level-ha">Service-Level HA</a></h2>
<h3 id="liveness-and-readiness-probes"><a class="header" href="#liveness-and-readiness-probes">Liveness and Readiness Probes</a></h3>
<p>Ensure only healthy pods serve traffic:</p>
<pre><code class="language-yaml">livenessProbe:
  exec:
    command: ["dig", "@localhost", "version.bind", "txt", "chaos"]
  initialDelaySeconds: 30
  periodSeconds: 10
  
readinessProbe:
  exec:
    command: ["dig", "@localhost", "version.bind", "txt", "chaos"]
  initialDelaySeconds: 5
  periodSeconds: 5
</code></pre>
<h3 id="pod-disruption-budgets"><a class="header" href="#pod-disruption-budgets">Pod Disruption Budgets</a></h3>
<p>Limit concurrent disruptions:</p>
<pre><code class="language-yaml">apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: primary-dns-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      instance: primary-dns
</code></pre>
<h2 id="monitoring-ha"><a class="header" href="#monitoring-ha">Monitoring HA</a></h2>
<h3 id="check-instance-distribution"><a class="header" href="#check-instance-distribution">Check Instance Distribution</a></h3>
<pre><code class="language-bash"># View instances across regions
kubectl get bind9instances -A -L region

# View pod distribution
kubectl get pods -n dns-system -o wide

# Check zone spread
kubectl get pods -n dns-system \
  -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName,ZONE:.spec.nodeSelector
</code></pre>
<h3 id="test-failover"><a class="header" href="#test-failover">Test Failover</a></h3>
<pre><code class="language-bash"># Simulate pod failure
kubectl delete pod -n dns-system &lt;pod-name&gt;

# Verify automatic recovery
kubectl get pods -n dns-system -w

# Test DNS during failover
while true; do dig @$SERVICE_IP example.com +short; sleep 1; done
</code></pre>
<h2 id="disaster-recovery"><a class="header" href="#disaster-recovery">Disaster Recovery</a></h2>
<h3 id="backup-strategy"><a class="header" href="#backup-strategy">Backup Strategy</a></h3>
<pre><code class="language-bash"># Regular backups of all CRDs
kubectl get bind9instances,dnszones,arecords,aaaarecords,cnamerecords,mxrecords,txtrecords,nsrecords,srvrecords,caarecords \
  -A -o yaml &gt; backup-$(date +%Y%m%d).yaml
</code></pre>
<h3 id="recovery-procedures"><a class="header" href="#recovery-procedures">Recovery Procedures</a></h3>
<ol>
<li><strong>Single Pod Failure</strong> - Kubernetes automatically recreates</li>
<li><strong>Instance Failure</strong> - Clients fail over to other instances</li>
<li><strong>Regional Failure</strong> - Zone data available from other regions</li>
<li><strong>Complete Loss</strong> - Restore from backup</li>
</ol>
<pre><code class="language-bash"># Restore from backup
kubectl apply -f backup-20241126.yaml
</code></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<ol>
<li><strong>Run 3+ Replicas</strong> - Odd numbers for quorum</li>
<li><strong>Multi-AZ Deployment</strong> - Spread across availability zones</li>
<li><strong>Geographic Redundancy</strong> - At least 2 regions for critical zones</li>
<li><strong>Monitor Continuously</strong> - Alert on degraded HA</li>
<li><strong>Test Failover</strong> - Regular disaster recovery drills</li>
<li><strong>Automate Recovery</strong> - Use Kubernetes self-healing</li>
<li><strong>Document Procedures</strong> - Runbooks for incidents</li>
</ol>
<h2 id="next-steps-27"><a class="header" href="#next-steps-27">Next Steps</a></h2>
<ul>
<li><a href="advanced/./zone-transfers.html">Zone Transfers</a> - Configure zone replication</li>
<li><a href="advanced/./replication.html">Replication</a> - Multi-region replication strategies</li>
<li><a href="advanced/./performance.html">Performance</a> - Optimize for high availability</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zone-transfers"><a class="header" href="#zone-transfers">Zone Transfers</a></h1>
<p>Configure and optimize DNS zone transfers between primary and secondary instances.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>Zone transfers replicate DNS zone data from primary to secondary servers using AXFR (full transfer) or IXFR (incremental transfer).</p>
<h2 id="configuring-zone-transfers"><a class="header" href="#configuring-zone-transfers">Configuring Zone Transfers</a></h2>
<h3 id="primary-instance-setup"><a class="header" href="#primary-instance-setup">Primary Instance Setup</a></h3>
<p>Allow zone transfers to secondary servers:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
spec:
  config:
    allowTransfer:
      - "10.0.0.0/8"        # Secondary network
      - "192.168.100.0/24"  # Specific secondary subnet
</code></pre>
<h3 id="secondary-instance-setup"><a class="header" href="#secondary-instance-setup">Secondary Instance Setup</a></h3>
<p>Configure secondary zones to transfer from primary:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-secondary
spec:
  zoneName: example.com
  type: secondary
  instanceSelector:
    matchLabels:
      dns-role: secondary
  secondaryConfig:
    primaryServers:
      - "10.0.1.10"  # Primary DNS server IP
      - "10.0.1.11"  # Backup primary IP
</code></pre>
<h2 id="transfer-types"><a class="header" href="#transfer-types">Transfer Types</a></h2>
<h3 id="full-transfer-axfr"><a class="header" href="#full-transfer-axfr">Full Transfer (AXFR)</a></h3>
<p>Transfers entire zone:</p>
<ul>
<li>Used for initial zone load</li>
<li>Triggered manually or when IXFR unavailable</li>
<li>More bandwidth intensive</li>
</ul>
<h3 id="incremental-transfer-ixfr"><a class="header" href="#incremental-transfer-ixfr">Incremental Transfer (IXFR)</a></h3>
<p>Transfers only changes since last serial:</p>
<ul>
<li>More efficient for large zones</li>
<li>Requires serial number tracking</li>
<li>Automatically used when available</li>
</ul>
<h2 id="transfer-triggers"><a class="header" href="#transfer-triggers">Transfer Triggers</a></h2>
<h3 id="notify-messages"><a class="header" href="#notify-messages">NOTIFY Messages</a></h3>
<p>Primary sends NOTIFY when zone changes:</p>
<pre><code>Primary Updates Zone
      │
      ├──NOTIFY──▶ Secondary 1
      ├──NOTIFY──▶ Secondary 2
      └──NOTIFY──▶ Secondary 3
      
Secondaries initiate IXFR/AXFR
</code></pre>
<h3 id="refresh-timer"><a class="header" href="#refresh-timer">Refresh Timer</a></h3>
<p>Secondary checks for updates periodically:</p>
<pre><code class="language-yaml">soaRecord:
  refresh: 3600  # Check every hour
  retry: 600     # Retry after 10 minutes if failed
</code></pre>
<h3 id="manual-trigger"><a class="header" href="#manual-trigger">Manual Trigger</a></h3>
<p>Force zone transfer:</p>
<pre><code class="language-bash"># On secondary pod
kubectl exec -n dns-system deployment/secondary-dns -- \
  rndc retransfer example.com
</code></pre>
<h2 id="monitoring-zone-transfers"><a class="header" href="#monitoring-zone-transfers">Monitoring Zone Transfers</a></h2>
<h3 id="check-transfer-status"><a class="header" href="#check-transfer-status">Check Transfer Status</a></h3>
<pre><code class="language-bash"># View transfer logs
kubectl logs -n dns-system -l dns-role=secondary | grep "transfer of"

# Successful transfer
# transfer of 'example.com/IN' from 10.0.1.10#53: Transfer completed: 1 messages, 42 records

# Check zone status
kubectl exec -n dns-system deployment/secondary-dns -- \
  rndc zonestatus example.com
</code></pre>
<h3 id="verify-serial-numbers"><a class="header" href="#verify-serial-numbers">Verify Serial Numbers</a></h3>
<pre><code class="language-bash"># Primary serial
kubectl exec -n dns-system deployment/primary-dns -- \
  dig @localhost example.com SOA +short | awk '{print $3}'

# Secondary serial  
kubectl exec -n dns-system deployment/secondary-dns -- \
  dig @localhost example.com SOA +short | awk '{print $3}'

# Should match when in sync
</code></pre>
<h2 id="transfer-performance"><a class="header" href="#transfer-performance">Transfer Performance</a></h2>
<h3 id="optimize-transfer-speed"><a class="header" href="#optimize-transfer-speed">Optimize Transfer Speed</a></h3>
<ol>
<li><strong>Use IXFR</strong> - Only transfer changes</li>
<li><strong>Increase Bandwidth</strong> - Adequate network resources</li>
<li><strong>Compress Transfers</strong> - Enable BIND9 compression</li>
<li><strong>Parallel Transfers</strong> - Multiple zones transfer concurrently</li>
</ol>
<h3 id="transfer-limits"><a class="header" href="#transfer-limits">Transfer Limits</a></h3>
<p>Configure maximum concurrent transfers:</p>
<pre><code class="language-yaml"># In BIND9 config (future enhancement)
options {
  transfers-in 10;   # Max incoming transfers
  transfers-out 10;  # Max outgoing transfers
};
</code></pre>
<h2 id="security-1"><a class="header" href="#security-1">Security</a></h2>
<h3 id="access-control"><a class="header" href="#access-control">Access Control</a></h3>
<p>Restrict transfers by IP:</p>
<pre><code class="language-yaml">spec:
  config:
    allowTransfer:
      - "10.0.0.0/8"  # Only this network
</code></pre>
<h3 id="tsig-authentication-2"><a class="header" href="#tsig-authentication-2">TSIG Authentication</a></h3>
<p>Use TSIG keys for authenticated transfers (future enhancement):</p>
<pre><code class="language-yaml"># Primary config
key "transfer-key" {
  algorithm hmac-sha256;
  secret "base64-encoded-secret";
};

# Allow transfers using key
allow-transfer {
  key transfer-key;
};
</code></pre>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<h3 id="transfer-failures"><a class="header" href="#transfer-failures">Transfer Failures</a></h3>
<p><strong>Check network connectivity:</strong></p>
<pre><code class="language-bash">kubectl exec -n dns-system deployment/secondary-dns -- \
  nc -zv primary-dns-service 53
</code></pre>
<p><strong>Test manual transfer:</strong></p>
<pre><code class="language-bash">kubectl exec -n dns-system deployment/secondary-dns -- \
  dig @primary-dns-service example.com AXFR
</code></pre>
<p><strong>Check ACLs:</strong></p>
<pre><code class="language-bash">kubectl get bind9instance primary-dns -o jsonpath='{.spec.config.allowTransfer}'
</code></pre>
<h3 id="slow-transfers"><a class="header" href="#slow-transfers">Slow Transfers</a></h3>
<p><strong>Check zone size:</strong></p>
<pre><code class="language-bash">kubectl exec -n dns-system deployment/primary-dns -- \
  wc -l /var/lib/bind/zones/example.com.zone
</code></pre>
<p><strong>Monitor transfer time:</strong></p>
<pre><code class="language-bash">kubectl logs -n dns-system -l dns-role=secondary | \
  grep "transfer of" | grep "msecs"
</code></pre>
<h3 id="transfer-lag"><a class="header" href="#transfer-lag">Transfer Lag</a></h3>
<p><strong>Check refresh interval:</strong></p>
<pre><code class="language-bash">kubectl get dnszone example-com -o jsonpath='{.spec.soaRecord.refresh}'
</code></pre>
<p><strong>Force immediate transfer:</strong></p>
<pre><code class="language-bash">kubectl exec -n dns-system deployment/secondary-dns -- \
  rndc retransfer example.com
</code></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<ol>
<li><strong>Use IXFR</strong> - More efficient than full transfers</li>
<li><strong>Set Appropriate Refresh</strong> - Balance freshness vs load</li>
<li><strong>Monitor Serial Numbers</strong> - Detect sync issues</li>
<li><strong>Secure Transfers</strong> - Use ACLs and TSIG</li>
<li><strong>Test Failover</strong> - Verify secondaries work when primary fails</li>
<li><strong>Log Transfers</strong> - Monitor for failures</li>
<li><strong>Geographic Distribution</strong> - Secondaries in different regions</li>
</ol>
<h2 id="example-complete-setup"><a class="header" href="#example-complete-setup">Example: Complete Setup</a></h2>
<pre><code class="language-yaml"># Primary Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  labels:
    dns-role: primary
spec:
  replicas: 2
  config:
    allowTransfer:
      - "10.0.0.0/8"
---
# Primary Zone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-primary
spec:
  zoneName: example.com
  type: primary
  instanceSelector:
    matchLabels:
      dns-role: primary
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin@example.com
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
---
# Secondary Instance  
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-dns
  labels:
    dns-role: secondary
spec:
  replicas: 2
---
# Secondary Zone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-secondary
spec:
  zoneName: example.com
  type: secondary
  instanceSelector:
    matchLabels:
      dns-role: secondary
  secondaryConfig:
    primaryServers:
      - "primary-dns-service.dns-system.svc.cluster.local"
</code></pre>
<h2 id="next-steps-28"><a class="header" href="#next-steps-28">Next Steps</a></h2>
<ul>
<li><a href="advanced/./replication.html">Replication</a> - Multi-region replication strategies</li>
<li><a href="advanced/./ha.html">High Availability</a> - HA architecture</li>
<li><a href="advanced/./performance.html">Performance</a> - Optimize zone transfer performance</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replication"><a class="header" href="#replication">Replication</a></h1>
<p>Implement multi-region DNS replication strategies for global availability.</p>
<h2 id="replication-models"><a class="header" href="#replication-models">Replication Models</a></h2>
<h3 id="hub-and-spoke"><a class="header" href="#hub-and-spoke">Hub-and-Spoke</a></h3>
<p>One central primary, multiple regional secondaries:</p>
<pre><code>        Primary (us-east-1)
             │
      ┌──────┼──────┐
      ▼      ▼      ▼
  Secondary Secondary Secondary
  (us-west) (eu-west) (ap-south)
</code></pre>
<p><strong>Pros:</strong> Simple, clear source of truth
<strong>Cons:</strong> Single point of failure, latency for distant regions</p>
<h3 id="multi-primary"><a class="header" href="#multi-primary">Multi-Primary</a></h3>
<p>Multiple primaries in different regions:</p>
<pre><code>Primary A ◀─────▶ Primary B
(us-east)        (eu-west)
    │                │
    ▼                ▼
Secondary        Secondary
(us-west)        (ap-south)
</code></pre>
<p><strong>Pros:</strong> Regional updates, better latency
<strong>Cons:</strong> Complex synchronization, conflict resolution</p>
<h3 id="hierarchical"><a class="header" href="#hierarchical">Hierarchical</a></h3>
<p>Tiered replication structure:</p>
<pre><code>      Global Primary
           │
    ┌──────┼──────┐
    ▼      ▼      ▼
Regional   Regional  Regional
Primary    Primary   Primary
    │         │         │
    ▼         ▼         ▼
  Local     Local     Local
Secondary Secondary Secondary
</code></pre>
<p><strong>Pros:</strong> Scales well, reduces global load
<strong>Cons:</strong> More complex, longer propagation time</p>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<h3 id="hub-and-spoke-setup"><a class="header" href="#hub-and-spoke-setup">Hub-and-Spoke Setup</a></h3>
<pre><code class="language-yaml"># Central Primary (us-east-1)
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: global-primary
  labels:
    dns-role: primary
    region: us-east-1
spec:
  replicas: 3
  config:
    allowTransfer:
      - "10.0.0.0/8"  # Allow all regional networks
---
# Regional Secondaries
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-us-west
  labels:
    dns-role: secondary
    region: us-west-2
spec:
  replicas: 2
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-eu-west
  labels:
    dns-role: secondary
    region: eu-west-1
spec:
  replicas: 2
</code></pre>
<h2 id="replication-latency"><a class="header" href="#replication-latency">Replication Latency</a></h2>
<h3 id="measuring-propagation-time"><a class="header" href="#measuring-propagation-time">Measuring Propagation Time</a></h3>
<pre><code class="language-bash"># Update record on primary
kubectl apply -f new-record.yaml

# Check serial on primary
PRIMARY_SERIAL=$(kubectl exec -n dns-system deployment/global-primary -- \
  dig @localhost example.com SOA +short | awk '{print $3}')

# Wait and check secondary
SECONDARY_SERIAL=$(kubectl exec -n dns-system deployment/secondary-eu-west -- \
  dig @localhost example.com SOA +short | awk '{print $3}')

# Calculate lag
echo "Primary: $PRIMARY_SERIAL, Secondary: $SECONDARY_SERIAL"
</code></pre>
<h3 id="optimizing-propagation"><a class="header" href="#optimizing-propagation">Optimizing Propagation</a></h3>
<ol>
<li><strong>Reduce refresh interval</strong> - More frequent checks</li>
<li><strong>Enable NOTIFY</strong> - Immediate notification of changes</li>
<li><strong>Use IXFR</strong> - Faster incremental transfers</li>
<li><strong>Optimize network</strong> - Low-latency connections between regions</li>
</ol>
<h2 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h2>
<p>When using multi-primary setups, handle conflicts:</p>
<h3 id="prevention"><a class="header" href="#prevention">Prevention</a></h3>
<ul>
<li>Separate zones per primary</li>
<li>Use different subdomains per region</li>
<li>Implement locking mechanism</li>
</ul>
<h3 id="detection"><a class="header" href="#detection">Detection</a></h3>
<pre><code class="language-bash"># Compare zones between primaries
diff &lt;(kubectl exec deployment/primary-us -- cat /var/lib/bind/zones/example.com.zone) \
     &lt;(kubectl exec deployment/primary-eu -- cat /var/lib/bind/zones/example.com.zone)
</code></pre>
<h2 id="monitoring-replication"><a class="header" href="#monitoring-replication">Monitoring Replication</a></h2>
<h3 id="replication-dashboard"><a class="header" href="#replication-dashboard">Replication Dashboard</a></h3>
<p>Monitor:</p>
<ul>
<li>Serial number sync status</li>
<li>Replication lag per region</li>
<li>Transfer success/failure rate</li>
<li>Zone size and growth</li>
</ul>
<h3 id="alerts-1"><a class="header" href="#alerts-1">Alerts</a></h3>
<p>Set up alerts for:</p>
<ul>
<li>Serial number drift &gt; threshold</li>
<li>Failed zone transfers</li>
<li>Replication lag &gt; SLA</li>
<li>Network connectivity issues</li>
</ul>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<ol>
<li><strong>Document topology</strong> - Clear replication map</li>
<li><strong>Monitor lag</strong> - Track propagation time</li>
<li><strong>Test failover</strong> - Regular DR drills</li>
<li><strong>Use consistent serials</strong> - YYYYMMDDnn format</li>
<li><strong>Automate updates</strong> - GitOps for all regions</li>
<li><strong>Capacity planning</strong> - Account for replication traffic</li>
</ol>
<h2 id="next-steps-29"><a class="header" href="#next-steps-29">Next Steps</a></h2>
<ul>
<li><a href="advanced/./ha.html">High Availability</a> - HA architecture</li>
<li><a href="advanced/./zone-transfers.html">Zone Transfers</a> - Transfer configuration</li>
<li><a href="advanced/./performance.html">Performance</a> - Optimize replication performance</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-2"><a class="header" href="#security-2">Security</a></h1>
<p>Secure your Bindy DNS infrastructure against threats and unauthorized access.</p>
<h2 id="security-layers"><a class="header" href="#security-layers">Security Layers</a></h2>
<h3 id="1-network-security"><a class="header" href="#1-network-security">1. Network Security</a></h3>
<ul>
<li>Firewall rules limiting DNS access</li>
<li>Network policies in Kubernetes</li>
<li>Private networks for zone transfers</li>
</ul>
<h3 id="2-access-control"><a class="header" href="#2-access-control">2. Access Control</a></h3>
<ul>
<li>Query restrictions (allowQuery)</li>
<li>Transfer restrictions (allowTransfer)</li>
<li>RBAC for Kubernetes resources</li>
</ul>
<h3 id="3-dnssec"><a class="header" href="#3-dnssec">3. DNSSEC</a></h3>
<ul>
<li>Cryptographic validation</li>
<li>Zone signing</li>
<li>Trust chain verification</li>
</ul>
<h3 id="4-pod-security"><a class="header" href="#4-pod-security">4. Pod Security</a></h3>
<ul>
<li>Pod Security Standards</li>
<li>SecurityContext settings</li>
<li>Read-only filesystems</li>
</ul>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<ol>
<li><strong>Principle of Least Privilege</strong> - Minimal permissions</li>
<li><strong>Defense in Depth</strong> - Multiple security layers</li>
<li><strong>Regular Updates</strong> - Keep BIND9 and controller updated</li>
<li><strong>Audit Logging</strong> - Track all changes</li>
<li><strong>Encryption</strong> - TLS for management, DNSSEC for queries</li>
</ol>
<h2 id="quick-security-checklist"><a class="header" href="#quick-security-checklist">Quick Security Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Enable DNSSEC for public zones</li>
<li><input disabled="" type="checkbox"/>
Restrict allowQuery to expected networks</li>
<li><input disabled="" type="checkbox"/>
Limit allowTransfer to secondary servers only</li>
<li><input disabled="" type="checkbox"/>
Use RBAC for Kubernetes access</li>
<li><input disabled="" type="checkbox"/>
Enable Pod Security Standards</li>
<li><input disabled="" type="checkbox"/>
Regular security audits</li>
<li><input disabled="" type="checkbox"/>
Monitor for suspicious queries</li>
<li><input disabled="" type="checkbox"/>
Keep software updated</li>
</ul>
<h2 id="next-steps-30"><a class="header" href="#next-steps-30">Next Steps</a></h2>
<ul>
<li><a href="advanced/./dnssec.html">DNSSEC</a> - Enable cryptographic validation</li>
<li><a href="advanced/./access-control.html">Access Control</a> - Configure query and transfer restrictions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dnssec"><a class="header" href="#dnssec">DNSSEC</a></h1>
<p>Enable DNS Security Extensions (DNSSEC) for cryptographic validation of DNS responses.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>DNSSEC adds cryptographic signatures to DNS records, preventing:</p>
<ul>
<li>Cache poisoning</li>
<li>Man-in-the-middle attacks</li>
<li>Response tampering</li>
</ul>
<h2 id="enabling-dnssec"><a class="header" href="#enabling-dnssec">Enabling DNSSEC</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
spec:
  config:
    dnssec:
      enabled: true      # Enable DNSSEC signing
      validation: true   # Enable DNSSEC validation
</code></pre>
<h2 id="dnssec-record-types"><a class="header" href="#dnssec-record-types">DNSSEC Record Types</a></h2>
<ul>
<li><strong>DNSKEY</strong> - Public signing keys</li>
<li><strong>RRSIG</strong> - Resource record signatures</li>
<li><strong>NSEC/NSEC3</strong> - Proof of non-existence</li>
<li><strong>DS</strong> - Delegation signer (at parent zone)</li>
</ul>
<h2 id="verification-2"><a class="header" href="#verification-2">Verification</a></h2>
<h3 id="check-dnssec-status"><a class="header" href="#check-dnssec-status">Check DNSSEC Status</a></h3>
<pre><code class="language-bash"># Query with DNSSEC validation
dig @$SERVICE_IP example.com +dnssec

# Check for ad (authentic data) flag
dig @$SERVICE_IP example.com +dnssec | grep "flags.*ad"

# Verify RRSIG records
dig @$SERVICE_IP example.com RRSIG
</code></pre>
<h3 id="validate-chain-of-trust"><a class="header" href="#validate-chain-of-trust">Validate Chain of Trust</a></h3>
<pre><code class="language-bash"># Check DS record at parent
dig @parent-dns example.com DS

# Verify DNSKEY matches DS
dig @$SERVICE_IP example.com DNSKEY
</code></pre>
<h2 id="key-management"><a class="header" href="#key-management">Key Management</a></h2>
<h3 id="automatic-key-rotation"><a class="header" href="#automatic-key-rotation">Automatic Key Rotation</a></h3>
<p>BIND9 handles automatic key rotation (future enhancement for Bindy configuration).</p>
<h3 id="manual-key-management"><a class="header" href="#manual-key-management">Manual Key Management</a></h3>
<pre><code class="language-bash"># Generate keys (inside BIND9 pod)
kubectl exec -n dns-system deployment/primary-dns -- \
  dnssec-keygen -a RSASHA256 -b 2048 -n ZONE example.com

# Sign zone
kubectl exec -n dns-system deployment/primary-dns -- \
  dnssec-signzone -o example.com /var/lib/bind/zones/example.com.zone
</code></pre>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<h3 id="dnssec-validation-failures"><a class="header" href="#dnssec-validation-failures">DNSSEC Validation Failures</a></h3>
<pre><code class="language-bash"># Check validation logs
kubectl logs -n dns-system -l instance=primary-dns | grep dnssec

# Test with validation disabled
dig @$SERVICE_IP example.com +cd

# Verify time synchronization (critical for DNSSEC)
kubectl exec -n dns-system deployment/primary-dns -- date
</code></pre>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<ol>
<li><strong>Enable on primaries</strong> - Sign at source</li>
<li><strong>Monitor expiration</strong> - Alert on expiring signatures</li>
<li><strong>Test before enabling</strong> - Verify in staging first</li>
<li><strong>Keep clocks synced</strong> - NTP critical for DNSSEC</li>
<li><strong>Plan key rotation</strong> - Regular key updates</li>
</ol>
<h2 id="next-steps-31"><a class="header" href="#next-steps-31">Next Steps</a></h2>
<ul>
<li><a href="advanced/./security.html">Security</a> - Overall security strategy</li>
<li><a href="advanced/./access-control.html">Access Control</a> - Query restrictions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control-1"><a class="header" href="#access-control-1">Access Control</a></h1>
<p>Configure fine-grained access control for DNS queries and zone transfers.</p>
<h2 id="query-access-control-2"><a class="header" href="#query-access-control-2">Query Access Control</a></h2>
<p>Restrict who can query your DNS servers:</p>
<h3 id="public-dns-allow-all"><a class="header" href="#public-dns-allow-all">Public DNS (Allow All)</a></h3>
<pre><code class="language-yaml">spec:
  config:
    allowQuery:
      - "0.0.0.0/0"  # IPv4 - anyone
      - "::/0"       # IPv6 - anyone
</code></pre>
<h3 id="internal-dns-restricted"><a class="header" href="#internal-dns-restricted">Internal DNS (Restricted)</a></h3>
<pre><code class="language-yaml">spec:
  config:
    allowQuery:
      - "10.0.0.0/8"      # RFC1918 private
      - "172.16.0.0/12"   # RFC1918 private
      - "192.168.0.0/16"  # RFC1918 private
</code></pre>
<h3 id="specific-networks"><a class="header" href="#specific-networks">Specific Networks</a></h3>
<pre><code class="language-yaml">spec:
  config:
    allowQuery:
      - "192.168.1.0/24"   # Office network
      - "10.100.0.0/16"    # VPN network
      - "172.20.5.10"      # Specific host
</code></pre>
<h2 id="zone-transfer-access-control-1"><a class="header" href="#zone-transfer-access-control-1">Zone Transfer Access Control</a></h2>
<p>Restrict zone transfers to authorized servers:</p>
<pre><code class="language-yaml">spec:
  config:
    allowTransfer:
      - "10.0.1.0/24"      # Secondary DNS subnet
      - "192.168.100.5"    # Specific secondary
      - "192.168.100.6"    # Another secondary
</code></pre>
<h3 id="block-all-transfers"><a class="header" href="#block-all-transfers">Block All Transfers</a></h3>
<pre><code class="language-yaml">spec:
  config:
    allowTransfer: []  # No transfers allowed
</code></pre>
<h2 id="acl-best-practices"><a class="header" href="#acl-best-practices">ACL Best Practices</a></h2>
<ol>
<li><strong>Default Deny</strong> - Start restrictive, open as needed</li>
<li><strong>Use CIDR Blocks</strong> - More maintainable than individual IPs</li>
<li><strong>Document ACLs</strong> - Note why each entry exists</li>
<li><strong>Regular Review</strong> - Remove obsolete entries</li>
<li><strong>Test Changes</strong> - Verify before production</li>
</ol>
<h2 id="network-policies-1"><a class="header" href="#network-policies-1">Network Policies</a></h2>
<p>Kubernetes NetworkPolicies add another layer:</p>
<pre><code class="language-yaml">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: dns-ingress
  namespace: dns-system
spec:
  podSelector:
    matchLabels:
      app: bind9
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector: {}  # Allow from all namespaces
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
</code></pre>
<h2 id="testing-access-control"><a class="header" href="#testing-access-control">Testing Access Control</a></h2>
<pre><code class="language-bash"># From allowed network (should work)
dig @$SERVICE_IP example.com

# From blocked network (should timeout or refuse)
dig @$SERVICE_IP example.com
# ;; communications error: connection timed out

# Test zone transfer restriction
dig @$SERVICE_IP example.com AXFR
# Transfer should fail if not in allowTransfer list
</code></pre>
<h2 id="next-steps-32"><a class="header" href="#next-steps-32">Next Steps</a></h2>
<ul>
<li><a href="advanced/./security.html">Security</a> - Overall security</li>
<li><a href="advanced/./dnssec.html">DNSSEC</a> - Cryptographic validation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-1"><a class="header" href="#performance-1">Performance</a></h1>
<p>Optimize Bindy DNS infrastructure for maximum performance and efficiency.</p>
<h2 id="performance-metrics-1"><a class="header" href="#performance-metrics-1">Performance Metrics</a></h2>
<p>Key metrics to monitor:</p>
<ul>
<li><strong>Query latency</strong> - Time to respond to DNS queries</li>
<li><strong>Throughput</strong> - Queries per second (QPS)</li>
<li><strong>Resource usage</strong> - CPU and memory utilization</li>
<li><strong>Cache hit ratio</strong> - Percentage of cached responses</li>
</ul>
<h2 id="optimization-strategies"><a class="header" href="#optimization-strategies">Optimization Strategies</a></h2>
<h3 id="1-resource-allocation"><a class="header" href="#1-resource-allocation">1. Resource Allocation</a></h3>
<p>Provide adequate CPU and memory:</p>
<pre><code class="language-yaml">spec:
  resources:
    requests:
      cpu: "500m"
      memory: "512Mi"
    limits:
      cpu: "2000m"
      memory: "2Gi"
</code></pre>
<h3 id="2-horizontal-scaling"><a class="header" href="#2-horizontal-scaling">2. Horizontal Scaling</a></h3>
<p>Add more replicas for higher capacity:</p>
<pre><code class="language-yaml">spec:
  replicas: 5  # More replicas = more capacity
</code></pre>
<h3 id="3-geographic-distribution-1"><a class="header" href="#3-geographic-distribution-1">3. Geographic Distribution</a></h3>
<p>Place DNS servers near clients:</p>
<ul>
<li>Reduced network latency</li>
<li>Better user experience</li>
<li>Regional load distribution</li>
</ul>
<h3 id="4-caching-strategy"><a class="header" href="#4-caching-strategy">4. Caching Strategy</a></h3>
<p>Configure BIND9 caching (when appropriate):</p>
<ul>
<li>Longer TTLs reduce upstream queries</li>
<li>Negative caching for NXDOMAIN</li>
<li>Prefetching for popular domains</li>
</ul>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="baseline-testing"><a class="header" href="#baseline-testing">Baseline Testing</a></h3>
<pre><code class="language-bash"># Single query latency
time dig @$SERVICE_IP example.com

# Sustained load (100 QPS for 60 seconds)
dnsp erf -s $SERVICE_IP -d example.com -q 100 -t 60
</code></pre>
<h3 id="load-testing"><a class="header" href="#load-testing">Load Testing</a></h3>
<pre><code class="language-bash"># Using dnsperf
dnsperf -s $SERVICE_IP -d queries.txt -l 60 -Q 1000

# Using custom script
for i in {1..1000}; do
  dig @$SERVICE_IP test$i.example.com &amp;
done
wait
</code></pre>
<h2 id="resource-optimization"><a class="header" href="#resource-optimization">Resource Optimization</a></h2>
<h3 id="cpu-optimization"><a class="header" href="#cpu-optimization">CPU Optimization</a></h3>
<ul>
<li>Use efficient query algorithms</li>
<li>Enable query parallelization</li>
<li>Optimize zone file format</li>
</ul>
<h3 id="memory-optimization"><a class="header" href="#memory-optimization">Memory Optimization</a></h3>
<ul>
<li>Right-size zone cache</li>
<li>Limit journal size</li>
<li>Regular zone file cleanup</li>
</ul>
<h3 id="network-optimization"><a class="header" href="#network-optimization">Network Optimization</a></h3>
<ul>
<li>Use UDP for queries (TCP for transfers)</li>
<li>Enable TCP Fast Open</li>
<li>Optimize MTU size</li>
</ul>
<h2 id="monitoring-performance"><a class="header" href="#monitoring-performance">Monitoring Performance</a></h2>
<pre><code class="language-bash"># Real-time resource usage
kubectl top pods -n dns-system -l app=bind9

# Query statistics
kubectl exec -n dns-system deployment/primary-dns -- \
  rndc stats

# View statistics file
kubectl exec -n dns-system deployment/primary-dns -- \
  cat /var/cache/bind/named.stats
</code></pre>
<h2 id="performance-targets"><a class="header" href="#performance-targets">Performance Targets</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Target</th><th>Good</th><th>Excellent</th></tr></thead><tbody>
<tr><td>Query Latency</td><td>&lt; 50ms</td><td>&lt; 20ms</td><td>&lt; 10ms</td></tr>
<tr><td>Throughput</td><td>&gt; 1000 QPS</td><td>&gt; 5000 QPS</td><td>&gt; 10000 QPS</td></tr>
<tr><td>CPU Usage</td><td>&lt; 70%</td><td>&lt; 50%</td><td>&lt; 30%</td></tr>
<tr><td>Memory Usage</td><td>&lt; 80%</td><td>&lt; 60%</td><td>&lt; 40%</td></tr>
<tr><td>Cache Hit Ratio</td><td>&gt; 60%</td><td>&gt; 80%</td><td>&gt; 90%</td></tr>
</tbody></table>
</div>
<h2 id="next-steps-33"><a class="header" href="#next-steps-33">Next Steps</a></h2>
<ul>
<li><a href="advanced/./tuning.html">Tuning</a> - Detailed tuning parameters</li>
<li><a href="advanced/./benchmarking.html">Benchmarking</a> - Performance testing methodology</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuning"><a class="header" href="#tuning">Tuning</a></h1>
<p>Fine-tune BIND9 and Kubernetes parameters for optimal performance.</p>
<h2 id="bind9-tuning"><a class="header" href="#bind9-tuning">BIND9 Tuning</a></h2>
<h3 id="query-performance"><a class="header" href="#query-performance">Query Performance</a></h3>
<pre><code class="language-yaml"># Future enhancement - BIND9 tuning via Bind9Instance spec
spec:
  config:
    tuning:
      maxCacheSize: "512M"
      maxCacheTTL: 86400
      recursiveClients: 1000
</code></pre>
<h3 id="zone-transfer-tuning"><a class="header" href="#zone-transfer-tuning">Zone Transfer Tuning</a></h3>
<ul>
<li>Concurrent transfers: <code>transfers-in</code>, <code>transfers-out</code></li>
<li>Transfer timeout: Adjust for large zones</li>
<li>Compression: Enable for faster transfers</li>
</ul>
<h2 id="kubernetes-tuning"><a class="header" href="#kubernetes-tuning">Kubernetes Tuning</a></h2>
<h3 id="pod-resources"><a class="header" href="#pod-resources">Pod Resources</a></h3>
<p>Right-size based on load:</p>
<pre><code class="language-yaml"># Light load
resources:
  requests: {cpu: "100m", memory: "128Mi"}
  limits: {cpu: "500m", memory: "512Mi"}

# Medium load
resources:
  requests: {cpu: "500m", memory: "512Mi"}
  limits: {cpu: "2000m", memory: "2Gi"}

# Heavy load
resources:
  requests: {cpu: "2000m", memory: "2Gi"}
  limits: {cpu: "4000m", memory: "4Gi"}
</code></pre>
<h3 id="hpa-horizontal-pod-autoscaling"><a class="header" href="#hpa-horizontal-pod-autoscaling">HPA (Horizontal Pod Autoscaling)</a></h3>
<pre><code class="language-yaml">apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: bind9-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: primary-dns
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
</code></pre>
<h3 id="node-affinity"><a class="header" href="#node-affinity">Node Affinity</a></h3>
<p>Place DNS pods on optimized nodes:</p>
<pre><code class="language-yaml">affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchExpressions:
        - key: workload-type
          operator: In
          values:
          - dns
</code></pre>
<h2 id="network-tuning"><a class="header" href="#network-tuning">Network Tuning</a></h2>
<h3 id="service-type"><a class="header" href="#service-type">Service Type</a></h3>
<p>Consider NodePort or LoadBalancer for external access:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
spec:
  type: LoadBalancer  # Or NodePort
  externalTrafficPolicy: Local  # Preserve source IP
</code></pre>
<h3 id="dns-caching"><a class="header" href="#dns-caching">DNS Caching</a></h3>
<p>Adjust TTL values:</p>
<pre><code class="language-yaml"># Short TTL for dynamic records
spec:
  ttl: 60  # 1 minute

# Long TTL for static records
spec:
  ttl: 86400  # 24 hours
</code></pre>
<h2 id="os-level-tuning"><a class="header" href="#os-level-tuning">OS-Level Tuning</a></h2>
<h3 id="file-descriptors"><a class="header" href="#file-descriptors">File Descriptors</a></h3>
<p>Increase limits for high query volume:</p>
<pre><code class="language-yaml"># In pod security context (future enhancement)
securityContext:
  limits:
    nofile: 65536
</code></pre>
<h3 id="network-buffers"><a class="header" href="#network-buffers">Network Buffers</a></h3>
<p>Optimize for DNS traffic (node-level):</p>
<pre><code class="language-bash"># Increase UDP buffer sizes
sysctl -w net.core.rmem_max=8388608
sysctl -w net.core.wmem_max=8388608
</code></pre>
<h2 id="monitoring-tuning-impact"><a class="header" href="#monitoring-tuning-impact">Monitoring Tuning Impact</a></h2>
<pre><code class="language-bash"># Before tuning - baseline
kubectl top pods -n dns-system
time dig @$SERVICE_IP example.com

# Apply tuning
kubectl apply -f tuned-config.yaml

# After tuning - compare
kubectl top pods -n dns-system
time dig @$SERVICE_IP example.com
</code></pre>
<h2 id="tuning-checklist"><a class="header" href="#tuning-checklist">Tuning Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Right-sized pod resources</li>
<li><input disabled="" type="checkbox"/>
Optimal replica count</li>
<li><input disabled="" type="checkbox"/>
HPA configured</li>
<li><input disabled="" type="checkbox"/>
Appropriate TTL values</li>
<li><input disabled="" type="checkbox"/>
Network policies optimized</li>
<li><input disabled="" type="checkbox"/>
Node placement configured</li>
<li><input disabled="" type="checkbox"/>
Monitoring enabled</li>
<li><input disabled="" type="checkbox"/>
Performance tested</li>
</ul>
<h2 id="next-steps-34"><a class="header" href="#next-steps-34">Next Steps</a></h2>
<ul>
<li><a href="advanced/./performance.html">Performance</a> - Performance overview</li>
<li><a href="advanced/./benchmarking.html">Benchmarking</a> - Testing methodology</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h1>
<p>Measure and analyze DNS performance using industry-standard tools.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<h3 id="dnsperf"><a class="header" href="#dnsperf">dnsperf</a></h3>
<p>Industry-standard DNS benchmarking:</p>
<pre><code class="language-bash"># Install dnsperf
apt-get install dnsperf

# Create query file
cat &gt; queries.txt &lt;&lt;'QUERIES'
example.com A
www.example.com A
mail.example.com MX
QUERIES

# Run benchmark
dnsperf -s $SERVICE_IP -d queries.txt -l 60 -Q 1000
</code></pre>
<h3 id="resperf"><a class="header" href="#resperf">resperf</a></h3>
<p>Response rate testing:</p>
<pre><code class="language-bash"># Test maximum QPS
resperf -s $SERVICE_IP -d queries.txt -m 10000
</code></pre>
<h3 id="dig"><a class="header" href="#dig">dig</a></h3>
<p>Simple latency testing:</p>
<pre><code class="language-bash"># Measure query time
dig @$SERVICE_IP example.com | grep "Query time"

# Multiple queries for average
for i in {1..100}; do
  dig @$SERVICE_IP example.com +stats | grep "Query time"
done | awk '{sum+=$4; count++} END {print "Average:", sum/count, "ms"}'
</code></pre>
<h2 id="benchmark-scenarios"><a class="header" href="#benchmark-scenarios">Benchmark Scenarios</a></h2>
<h3 id="scenario-1-baseline-performance"><a class="header" href="#scenario-1-baseline-performance">Scenario 1: Baseline Performance</a></h3>
<p>Single client, sequential queries:</p>
<pre><code class="language-bash">dnsperf -s $SERVICE_IP -d queries.txt -l 60 -Q 100
</code></pre>
<p><strong>Expected:</strong> &lt; 10ms latency, &gt; 90% success</p>
<h3 id="scenario-2-load-test"><a class="header" href="#scenario-2-load-test">Scenario 2: Load Test</a></h3>
<p>Multiple clients, high QPS:</p>
<pre><code class="language-bash">dnsperf -s $SERVICE_IP -d queries.txt -l 300 -Q 5000 -c 50
</code></pre>
<p><strong>Expected:</strong> &lt; 50ms latency under load</p>
<h3 id="scenario-3-stress-test"><a class="header" href="#scenario-3-stress-test">Scenario 3: Stress Test</a></h3>
<p>Maximum capacity test:</p>
<pre><code class="language-bash">resperf -s $SERVICE_IP -d queries.txt -m 50000
</code></pre>
<p><strong>Expected:</strong> Find maximum QPS before degradation</p>
<h2 id="metrics-to-collect"><a class="header" href="#metrics-to-collect">Metrics to Collect</a></h2>
<h3 id="response-time"><a class="header" href="#response-time">Response Time</a></h3>
<ul>
<li>Minimum latency</li>
<li>Average latency</li>
<li>95th percentile</li>
<li>99th percentile</li>
<li>Maximum latency</li>
</ul>
<h3 id="throughput"><a class="header" href="#throughput">Throughput</a></h3>
<ul>
<li>Queries per second</li>
<li>Successful responses</li>
<li>Failed queries</li>
<li>Timeout rate</li>
</ul>
<h3 id="resource-usage"><a class="header" href="#resource-usage">Resource Usage</a></h3>
<pre><code class="language-bash"># During benchmark
kubectl top pods -n dns-system

# CPU and memory trends
kubectl top pods -n dns-system --use-protocol-buffers
</code></pre>
<h2 id="sample-benchmark-report"><a class="header" href="#sample-benchmark-report">Sample Benchmark Report</a></h2>
<pre><code>Benchmark: Load Test
Date: 2024-11-26
Duration: 300 seconds
Target QPS: 5000

Results:
- Queries sent: 1,500,000
- Queries completed: 1,498,500
- Success rate: 99.9%
- Average latency: 12.3ms
- 95th percentile: 24.1ms
- 99th percentile: 45.2ms
- Max latency: 89.5ms

Resource Usage:
- Average CPU: 1.2 cores
- Average Memory: 512MB
- Peak CPU: 1.8 cores
- Peak Memory: 768MB
</code></pre>
<h2 id="continuous-benchmarking"><a class="header" href="#continuous-benchmarking">Continuous Benchmarking</a></h2>
<h3 id="automated-testing"><a class="header" href="#automated-testing">Automated Testing</a></h3>
<pre><code class="language-yaml">apiVersion: batch/v1
kind: CronJob
metadata:
  name: dns-benchmark
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: dnsperf
            image: dnsperf:latest
            command:
            - /bin/sh
            - -c
            - dnsperf -s primary-dns -d /queries.txt -l 60 &gt;&gt; /results/benchmark.log
</code></pre>
<h3 id="trend-analysis"><a class="header" href="#trend-analysis">Trend Analysis</a></h3>
<p>Track performance over time:</p>
<ul>
<li>Daily benchmarks</li>
<li>Compare before/after changes</li>
<li>Identify degradation early</li>
<li>Capacity planning</li>
</ul>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<ol>
<li><strong>Consistent tests</strong> - Same queries, duration</li>
<li><strong>Isolated environment</strong> - Minimize external factors</li>
<li><strong>Multiple runs</strong> - Average results</li>
<li><strong>Document changes</strong> - Link to config changes</li>
<li><strong>Realistic load</strong> - Match production patterns</li>
</ol>
<h2 id="next-steps-35"><a class="header" href="#next-steps-35">Next Steps</a></h2>
<ul>
<li><a href="advanced/./performance.html">Performance</a> - Performance overview</li>
<li><a href="advanced/./tuning.html">Tuning</a> - Optimization parameters</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-1"><a class="header" href="#integration-1">Integration</a></h1>
<p>Integrate Bindy with other Kubernetes and DNS systems.</p>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="1-internal-service-discovery"><a class="header" href="#1-internal-service-discovery">1. Internal Service Discovery</a></h3>
<p>Use Bindy for internal service DNS.</p>
<h3 id="2-hybrid-dns"><a class="header" href="#2-hybrid-dns">2. Hybrid DNS</a></h3>
<p>Combine Bindy with external DNS providers.</p>
<h3 id="3-gitops"><a class="header" href="#3-gitops">3. GitOps</a></h3>
<p>Manage DNS configuration through Git.</p>
<h2 id="kubernetes-integration"><a class="header" href="#kubernetes-integration">Kubernetes Integration</a></h2>
<h3 id="coredns-integration"><a class="header" href="#coredns-integration">CoreDNS Integration</a></h3>
<p>Use Bindy alongside CoreDNS:</p>
<pre><code class="language-yaml"># CoreDNS for cluster.local
# Bindy for custom domains
</code></pre>
<h3 id="service-mesh"><a class="header" href="#service-mesh">Service Mesh</a></h3>
<p>Integrate with Istio, Linkerd:</p>
<ul>
<li>Custom DNS resolution</li>
<li>Service discovery</li>
<li>Traffic routing</li>
</ul>
<h2 id="next-steps-36"><a class="header" href="#next-steps-36">Next Steps</a></h2>
<ul>
<li><a href="advanced/./external-dns.html">External DNS</a> - External provider integration</li>
<li><a href="advanced/./service-discovery.html">Service Discovery</a> - Kubernetes service discovery</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-dns-integration"><a class="header" href="#external-dns-integration">External DNS Integration</a></h1>
<p>Integrate Bindy with external DNS management systems.</p>
<h2 id="use-cases-3"><a class="header" href="#use-cases-3">Use Cases</a></h2>
<ol>
<li><strong>Hybrid Cloud</strong> - Internal DNS in Bindy, external in cloud provider</li>
<li><strong>Public/Private Split</strong> - Public zones external, private in Bindy</li>
<li><strong>Migration</strong> - Gradual migration from external to Bindy</li>
</ol>
<h2 id="integration-with-external-dns"><a class="header" href="#integration-with-external-dns">Integration with external-dns</a></h2>
<p>External-dns manages external providers (Route53, CloudDNS), Bindy manages internal BIND9.</p>
<h3 id="separate-domains"><a class="header" href="#separate-domains">Separate Domains</a></h3>
<pre><code class="language-yaml"># external-dns manages example.com (public)
# Bindy manages internal.example.com (private)
</code></pre>
<h3 id="forwarding"><a class="header" href="#forwarding">Forwarding</a></h3>
<p>Configure external DNS to forward to Bindy for internal zones.</p>
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<ol>
<li><strong>Clear boundaries</strong> - Document which system owns which zones</li>
<li><strong>Consistent records</strong> - Synchronize where needed</li>
<li><strong>Separate responsibilities</strong> - External for public, Bindy for internal</li>
</ol>
<h2 id="next-steps-37"><a class="header" href="#next-steps-37">Next Steps</a></h2>
<ul>
<li><a href="advanced/./integration.html">Integration</a> - Integration overview</li>
<li><a href="advanced/./service-discovery.html">Service Discovery</a> - Kubernetes service discovery</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-discovery"><a class="header" href="#service-discovery">Service Discovery</a></h1>
<p>Use Bindy for Kubernetes service discovery and internal DNS.</p>
<h2 id="kubernetes-service-dns"><a class="header" href="#kubernetes-service-dns">Kubernetes Service DNS</a></h2>
<h3 id="automatic-service-records"><a class="header" href="#automatic-service-records">Automatic Service Records</a></h3>
<p>Create DNS records for Kubernetes services:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: myapp
  namespace: production
spec:
  selector:
    app: myapp
  ports:
  - port: 80
---
# Create corresponding DNS record
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: myapp
spec:
  zone: internal-local
  name: myapp.production
  ipv4Address: "10.100.5.10"  # Service ClusterIP
</code></pre>
<h3 id="service-discovery-pattern"><a class="header" href="#service-discovery-pattern">Service Discovery Pattern</a></h3>
<pre><code>Application Query: myapp.production.internal.local
                           │
                           ▼
                    Bindy DNS Server
                           │
                           ▼
                   Returns: 10.100.5.10
                           │
                           ▼
                  Kubernetes Service
</code></pre>
<h2 id="dynamic-updates"><a class="header" href="#dynamic-updates">Dynamic Updates</a></h2>
<p>Automatically update DNS when services change (future enhancement):</p>
<pre><code class="language-yaml"># Controller watches Services and creates DNS records
</code></pre>
<h2 id="best-practices-15"><a class="header" href="#best-practices-15">Best Practices</a></h2>
<ol>
<li><strong>Consistent naming</strong> - Match service names to DNS names</li>
<li><strong>Namespace separation</strong> - Use subdomains per namespace</li>
<li><strong>TTL management</strong> - Short TTLs for dynamic services</li>
<li><strong>Health checks</strong> - Only advertise healthy services</li>
</ol>
<h2 id="next-steps-38"><a class="header" href="#next-steps-38">Next Steps</a></h2>
<ul>
<li><a href="advanced/./integration.html">Integration</a> - Integration patterns</li>
<li><a href="advanced/./external-dns.html">External DNS</a> - External DNS integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h1>
<p>Set up your development environment for contributing to Bindy.</p>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<h3 id="required-tools"><a class="header" href="#required-tools">Required Tools</a></h3>
<ul>
<li><strong>Rust</strong> - 1.70 or later</li>
<li><strong>Kubernetes</strong> - 1.27 or later (for testing)</li>
<li><strong>kubectl</strong> - Matching your Kubernetes version</li>
<li><strong>Docker</strong> - For building images</li>
<li><strong>kind</strong> - For local Kubernetes testing (optional)</li>
</ul>
<h3 id="install-rust"><a class="header" href="#install-rust">Install Rust</a></h3>
<pre><code class="language-bash"># Install rustup
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Verify installation
rustc --version
cargo --version
</code></pre>
<h3 id="install-development-tools"><a class="header" href="#install-development-tools">Install Development Tools</a></h3>
<pre><code class="language-bash"># Install cargo tools
cargo install cargo-watch  # Auto-rebuild on changes
cargo install cargo-tarpaulin  # Code coverage

# Install mdbook for documentation
cargo install mdbook
</code></pre>
<h2 id="clone-repository"><a class="header" href="#clone-repository">Clone Repository</a></h2>
<pre><code class="language-bash">git clone https://github.com/firestoned/bindy.git
cd bindy
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<pre><code>bindy/
├── src/              # Rust source code
│   ├── main.rs       # Entry point
│   ├── crd.rs        # CRD definitions
│   ├── reconcilers/  # Reconciliation logic
│   └── bind9.rs      # BIND9 integration
├── deploy/           # Kubernetes manifests
│   ├── crds/         # CRD definitions
│   ├── rbac/         # RBAC resources
│   └── controller/   # Controller deployment
├── tests/            # Integration tests
├── examples/         # Example configurations
├── docs/             # Documentation
└── Cargo.toml        # Rust dependencies
</code></pre>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Key dependencies:</p>
<ul>
<li><code>kube</code> - Kubernetes client</li>
<li><code>tokio</code> - Async runtime</li>
<li><code>serde</code> - Serialization</li>
<li><code>tracing</code> - Logging</li>
</ul>
<p>See <a href="development/../../Cargo.toml">Cargo.toml</a> for full list.</p>
<h2 id="ide-setup"><a class="header" href="#ide-setup">IDE Setup</a></h2>
<h3 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h3>
<p>Recommended extensions:</p>
<ul>
<li>rust-analyzer</li>
<li>crates</li>
<li>Even Better TOML</li>
<li>Kubernetes</li>
</ul>
<h3 id="intellij-idea--clion"><a class="header" href="#intellij-idea--clion">IntelliJ IDEA / CLion</a></h3>
<ul>
<li>Install Rust plugin</li>
<li>Install Kubernetes plugin</li>
</ul>
<h2 id="verify-setup"><a class="header" href="#verify-setup">Verify Setup</a></h2>
<pre><code class="language-bash"># Build the project
cargo build

# Run tests
cargo test

# Run clippy (linter)
cargo clippy

# Format code
cargo fmt
</code></pre>
<p>If all commands succeed, your development environment is ready!</p>
<h2 id="next-steps-39"><a class="header" href="#next-steps-39">Next Steps</a></h2>
<ul>
<li><a href="development/./building.html">Building from Source</a> - Build the controller</li>
<li><a href="development/./testing.html">Running Tests</a> - Test your changes</li>
<li><a href="development/./workflow.html">Development Workflow</a> - Daily development workflow</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h1>
<p>Build the Bindy controller from source code.</p>
<h2 id="build-debug-version"><a class="header" href="#build-debug-version">Build Debug Version</a></h2>
<p>For development with debug symbols:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>Binary location: <code>target/debug/bindy</code></p>
<h2 id="build-release-version"><a class="header" href="#build-release-version">Build Release Version</a></h2>
<p>Optimized for production:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>Binary location: <code>target/release/bindy</code></p>
<h2 id="run-locally"><a class="header" href="#run-locally">Run Locally</a></h2>
<pre><code class="language-bash"># Set log level
export RUST_LOG=info

# Run controller (requires kubeconfig)
cargo run --release
</code></pre>
<h2 id="build-docker-image"><a class="header" href="#build-docker-image">Build Docker Image</a></h2>
<pre><code class="language-bash"># Build image
docker build -t bindy:dev .

# Or use make
make docker-build TAG=dev
</code></pre>
<h2 id="build-for-different-platforms"><a class="header" href="#build-for-different-platforms">Build for Different Platforms</a></h2>
<h3 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h3>
<pre><code class="language-bash"># Install cross
cargo install cross

# Build for Linux (from macOS/Windows)
cross build --release --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="multi-architecture-images"><a class="header" href="#multi-architecture-images">Multi-Architecture Images</a></h3>
<pre><code class="language-bash"># Build for multiple architectures
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  -t bindy:multi \
  --push .
</code></pre>
<h2 id="build-documentation"><a class="header" href="#build-documentation">Build Documentation</a></h2>
<h3 id="rustdoc-api-docs"><a class="header" href="#rustdoc-api-docs">Rustdoc (API docs)</a></h3>
<pre><code class="language-bash">cargo doc --no-deps --open
</code></pre>
<h3 id="mdbook-user-guide"><a class="header" href="#mdbook-user-guide">mdBook (User guide)</a></h3>
<pre><code class="language-bash"># Build book
mdbook build

# Serve locally
mdbook serve
</code></pre>
<h3 id="combined-documentation"><a class="header" href="#combined-documentation">Combined Documentation</a></h3>
<pre><code class="language-bash">make docs
</code></pre>
<h2 id="optimization"><a class="header" href="#optimization">Optimization</a></h2>
<h3 id="profile-guided-optimization"><a class="header" href="#profile-guided-optimization">Profile-Guided Optimization</a></h3>
<pre><code class="language-bash"># Generate profile data
cargo build --release
./target/release/bindy  # Run workload

# Build with PGO
cargo build --release
</code></pre>
<h3 id="size-optimization"><a class="header" href="#size-optimization">Size Optimization</a></h3>
<pre><code class="language-toml"># In Cargo.toml
[profile.release]
opt-level = 'z'     # Optimize for size
lto = true          # Link-time optimization
codegen-units = 1   # Better optimization
strip = true        # Strip symbols
</code></pre>
<h2 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h2>
<h3 id="build-errors"><a class="header" href="#build-errors">Build Errors</a></h3>
<p><strong>OpenSSL not found:</strong></p>
<pre><code class="language-bash"># Ubuntu/Debian
apt-get install libssl-dev pkg-config

# macOS
brew install openssl
</code></pre>
<p><strong>Linker errors:</strong></p>
<pre><code class="language-bash"># Install build essentials
apt-get install build-essential
</code></pre>
<h2 id="next-steps-40"><a class="header" href="#next-steps-40">Next Steps</a></h2>
<ul>
<li><a href="development/./testing.html">Running Tests</a> - Test your build</li>
<li><a href="development/./workflow.html">Development Workflow</a> - Daily development</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h1>
<p>Run and write tests for Bindy.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<pre><code class="language-bash"># Run all tests
cargo test

# Run specific test
cargo test test_name

# Run with output
cargo test -- --nocapture
</code></pre>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<pre><code class="language-bash"># Requires Kubernetes cluster
cargo test --test simple_integration -- --ignored

# Or use make
make test-integration
</code></pre>
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<pre><code class="language-bash"># Install tarpaulin
cargo install cargo-tarpaulin

# Generate coverage
cargo tarpaulin --out Html

# Open report
open tarpaulin-report.html
</code></pre>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<p>See <a href="development/./testing-guidelines.html">Testing Guidelines</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bindy-dns-controller---testing-guide"><a class="header" href="#bindy-dns-controller---testing-guide">Bindy DNS Controller - Testing Guide</a></h1>
<p>Complete guide for testing the Bindy DNS Controller, including unit tests and integration tests with Kind (Kubernetes in Docker).</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><code class="language-bash"># Unit tests (fast, no Kubernetes required)
make test

# Integration tests (automated with Kind cluster)
make kind-integration-test

# View results
# Unit: 62 tests passing
# Integration: All 8 DNS record types + infrastructure tests
</code></pre>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="development/testing-guide.html#test-overview">Test Overview</a></li>
<li><a href="development/testing-guide.html#unit-tests">Unit Tests</a></li>
<li><a href="development/testing-guide.html#integration-tests">Integration Tests</a></li>
<li><a href="development/testing-guide.html#makefile-targets">Makefile Targets</a></li>
<li><a href="development/testing-guide.html#troubleshooting">Troubleshooting</a></li>
<li><a href="development/testing-guide.html#cicd-integration">CI/CD Integration</a></li>
</ul>
<h2 id="test-overview"><a class="header" href="#test-overview">Test Overview</a></h2>
<h3 id="test-results"><a class="header" href="#test-results">Test Results</a></h3>
<p><strong>Unit Tests: 62 PASSING ✅</strong></p>
<pre><code>test result: ok. 62 passed; 0 failed; 0 ignored
</code></pre>
<p><strong>Integration Tests: Automated with Kind</strong></p>
<ul>
<li>Kubernetes connectivity ✅</li>
<li>CRD verification ✅</li>
<li>All 8 DNS record types ✅</li>
<li>Resource lifecycle ✅</li>
</ul>
<h3 id="test-structure"><a class="header" href="#test-structure">Test Structure</a></h3>
<pre><code>bindy/
├── src/
│   ├── crd_tests.rs              # CRD structure tests (28 tests)
│   └── reconcilers/
│       └── tests.rs              # Bind9Manager tests (34 tests)
├── tests/
│   ├── simple_integration.rs     # Rust integration tests
│   ├── integration_test.sh       # Full integration test suite
│   └── common/mod.rs            # Shared test utilities
└── deploy/
    ├── kind-deploy.sh           # Deploy to Kind cluster
    ├── kind-test.sh             # Basic functional tests
    └── kind-cleanup.sh          # Cleanup Kind cluster
</code></pre>
<h2 id="unit-tests-1"><a class="header" href="#unit-tests-1">Unit Tests</a></h2>
<p>Unit tests run locally without Kubernetes (&lt; 1 second).</p>
<h3 id="running-unit-tests"><a class="header" href="#running-unit-tests">Running Unit Tests</a></h3>
<pre><code class="language-bash"># All unit tests
make test
# or
cargo test

# Specific module
cargo test crd_tests::
cargo test bind9::tests::

# With output
cargo test -- --nocapture
</code></pre>
<h3 id="unit-test-coverage-62-tests"><a class="header" href="#unit-test-coverage-62-tests">Unit Test Coverage (62 tests)</a></h3>
<h4 id="crd-tests-28-tests"><a class="header" href="#crd-tests-28-tests">CRD Tests (28 tests)</a></h4>
<ul>
<li>Label selectors and matching</li>
<li>SOA record structure</li>
<li>DNSZone specs (primary/secondary)</li>
<li>All DNS record types (A, AAAA, CNAME, MX, TXT, NS, SRV, CAA)</li>
<li>Bind9Instance configurations</li>
<li>DNSSEC settings</li>
</ul>
<h4 id="bind9manager-tests-34-tests"><a class="header" href="#bind9manager-tests-34-tests">Bind9Manager Tests (34 tests)</a></h4>
<ul>
<li>Zone file creation</li>
<li>Email formatting for DNS</li>
<li>All DNS record types (with/without TTL)</li>
<li>Secondary zone configuration</li>
<li>Zone lifecycle (create, exists, delete)</li>
<li>Edge cases and workflows</li>
</ul>
<h2 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration Tests</a></h2>
<p>Integration tests run against Kind (Kubernetes in Docker) clusters.</p>
<h3 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h3>
<pre><code class="language-bash"># Docker
docker --version  # 20.10+

# Kind
kind --version    # 0.20.0+
brew install kind  # macOS

# kubectl
kubectl version --client  # 1.24+
</code></pre>
<h3 id="running-integration-tests"><a class="header" href="#running-integration-tests">Running Integration Tests</a></h3>
<h4 id="full-integration-suite-recommended"><a class="header" href="#full-integration-suite-recommended">Full Integration Suite (Recommended)</a></h4>
<pre><code class="language-bash">make kind-integration-test
</code></pre>
<p>This automatically:</p>
<ol>
<li>Creates Kind cluster (if needed)</li>
<li>Builds and deploys controller</li>
<li>Runs all integration tests</li>
<li>Cleans up test resources</li>
</ol>
<h4 id="step-by-step"><a class="header" href="#step-by-step">Step-by-Step</a></h4>
<pre><code class="language-bash"># 1. Deploy to Kind
make kind-deploy

# 2. Run functional tests
make kind-test

# 3. Run comprehensive integration tests
make kind-integration-test

# 4. View logs
make kind-logs

# 5. Cleanup
make kind-cleanup
</code></pre>
<h3 id="integration-test-coverage"><a class="header" href="#integration-test-coverage">Integration Test Coverage</a></h3>
<p><strong>Rust Integration Tests</strong></p>
<ul>
<li><code>test_kubernetes_connectivity</code> - Cluster access</li>
<li><code>test_crds_installed</code> - CRD verification</li>
<li><code>test_create_and_cleanup_namespace</code> - Namespace lifecycle</li>
</ul>
<p><strong>Full Integration Suite</strong> (<code>integration_test.sh</code>)</p>
<ul>
<li>Bind9Instance creation</li>
<li>DNSZone creation</li>
<li>A Record (IPv4)</li>
<li>AAAA Record (IPv6)</li>
<li>CNAME Record</li>
<li>MX Record</li>
<li>TXT Record</li>
<li>NS Record</li>
<li>SRV Record</li>
<li>CAA Record</li>
</ul>
<h3 id="expected-output"><a class="header" href="#expected-output">Expected Output</a></h3>
<pre><code>🧪 Running Bindy Integration Tests

✅ Using existing cluster 'bindy-test'

1️⃣  Running Rust integration tests...
test test_kubernetes_connectivity ... ok
test test_crds_installed ... ok
test test_create_and_cleanup_namespace ... ok

2️⃣  Running functional tests with kubectl...
Testing Bind9Instance creation...
Testing DNSZone creation...
Testing all DNS record types...

3️⃣  Verifying resources...
  ✓ Bind9Instance created
  ✓ DNSZone created
  ✓ arecord created
  ✓ aaaarecord created
  ✓ cnamerecord created
  ✓ mxrecord created
  ✓ txtrecord created
  ✓ nsrecord created
  ✓ srvrecord created
  ✓ caarecord created

✅ All integration tests passed!
</code></pre>
<h2 id="makefile-targets"><a class="header" href="#makefile-targets">Makefile Targets</a></h2>
<h3 id="test-targets"><a class="header" href="#test-targets">Test Targets</a></h3>
<pre><code class="language-bash">make test                   # Run unit tests
make test-lib              # Library tests only
make test-integration      # Rust integration tests
make test-all             # Unit + Rust integration tests
make test-cov             # Coverage report (HTML)
make test-cov-view        # Generate and open coverage
</code></pre>
<h3 id="kind-targets"><a class="header" href="#kind-targets">Kind Targets</a></h3>
<pre><code class="language-bash">make kind-create          # Create Kind cluster
make kind-deploy          # Deploy controller
make kind-test            # Basic functional tests
make kind-integration-test # Full integration suite
make kind-logs            # View controller logs
make kind-cleanup         # Delete cluster
</code></pre>
<h3 id="other-targets"><a class="header" href="#other-targets">Other Targets</a></h3>
<pre><code class="language-bash">make lint                 # Run clippy and fmt check
make format               # Format code
make build                # Build release binary
make docker-build         # Build Docker image
</code></pre>
<h2 id="troubleshooting-7"><a class="header" href="#troubleshooting-7">Troubleshooting</a></h2>
<h3 id="unit-tests-2"><a class="header" href="#unit-tests-2">Unit Tests</a></h3>
<p><strong>Tests fail to compile</strong></p>
<pre><code class="language-bash">cargo clean
cargo test
</code></pre>
<p><strong>Specific test fails</strong></p>
<pre><code class="language-bash">cargo test test_name -- --nocapture
</code></pre>
<h3 id="integration-tests-2"><a class="header" href="#integration-tests-2">Integration Tests</a></h3>
<p><strong>"Cluster not found"</strong></p>
<pre><code class="language-bash"># Auto-created by integration test, or:
./deploy/kind-deploy.sh
</code></pre>
<p><strong>"Controller not ready"</strong></p>
<pre><code class="language-bash"># Check status
kubectl get pods -n dns-system

# View logs
kubectl logs -n dns-system -l app=bindy

# Redeploy
./deploy/kind-deploy.sh
</code></pre>
<p><strong>"CRDs not installed"</strong></p>
<pre><code class="language-bash"># Check CRDs
kubectl get crds | grep bindy.firestoned.io

# Install
kubectl apply -k deploy/crds
</code></pre>
<p><strong>Resource creation fails</strong></p>
<pre><code class="language-bash"># Controller logs
kubectl logs -n dns-system -l app=bindy --tail=50

# Resource status
kubectl describe bind9instance &lt;name&gt; -n dns-system

# Events
kubectl get events -n dns-system --sort-by='.lastTimestamp'
</code></pre>
<h3 id="manual-cleanup"><a class="header" href="#manual-cleanup">Manual Cleanup</a></h3>
<pre><code class="language-bash"># Delete test resources
kubectl delete bind9instances,dnszones,arecords,aaaarecords,cnamerecords,mxrecords,txtrecords,nsrecords,srvrecords,caarecords --all -n dns-system

# Delete cluster
kind delete cluster --name bindy-test

# Clean build
cargo clean
</code></pre>
<h2 id="cicd-integration"><a class="header" href="#cicd-integration">CI/CD Integration</a></h2>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<p>Current PR workflow (<code>.github/workflows/pr.yaml</code>):</p>
<ul>
<li>Lint (formatting, clippy)</li>
<li>Test (unit tests)</li>
<li>Build (stable, beta)</li>
<li>Docker (build and push to ghcr.io)</li>
<li>Security audit</li>
<li>Coverage</li>
</ul>
<h3 id="add-integration-tests"><a class="header" href="#add-integration-tests">Add Integration Tests</a></h3>
<pre><code class="language-yaml">integration-tests:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4
    - uses: dtolnay/rust-toolchain@stable

    - name: Install Kind
      run: |
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/latest/kind-linux-amd64
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin/kind

    - name: Run Integration Tests
      run: |
        chmod +x tests/integration_test.sh
        ./tests/integration_test.sh
</code></pre>
<h2 id="test-development"><a class="header" href="#test-development">Test Development</a></h2>
<h3 id="writing-unit-tests"><a class="header" href="#writing-unit-tests">Writing Unit Tests</a></h3>
<p>Add to <code>src/crd_tests.rs</code> or <code>src/reconcilers/tests.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_my_feature() {
    // Arrange
    let (_temp_dir, manager) = create_test_manager();

    // Act
    let result = manager.my_operation();

    // Assert
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="writing-integration-tests"><a class="header" href="#writing-integration-tests">Writing Integration Tests</a></h3>
<p>Add to <code>tests/simple_integration.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
#[ignore]  // Always mark as ignored
async fn test_my_scenario() {
    let client = match get_kube_client_or_skip().await {
        Some(c) =&gt; c,
        None =&gt; return,  // Skip if no cluster
    };

    // Test code here
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-test-helpers"><a class="header" href="#using-test-helpers">Using Test Helpers</a></h3>
<p>From <code>tests/common/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use common::*;

let client = setup_dns_test_environment("my-test-ns").await?;
create_bind9_instance(&amp;client, "ns", "dns", None).await?;
wait_for_ready(Duration::from_secs(10)).await;
cleanup_test_namespace(&amp;client, "ns").await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-testing-1"><a class="header" href="#performance-testing-1">Performance Testing</a></h2>
<h3 id="coverage"><a class="header" href="#coverage">Coverage</a></h3>
<pre><code class="language-bash">make test-cov-view
# Opens coverage/tarpaulin-report.html
</code></pre>
<h3 id="load-testing-1"><a class="header" href="#load-testing-1">Load Testing</a></h3>
<pre><code class="language-bash"># Create many resources
for i in {1..100}; do
  kubectl apply -f - &lt;&lt;EOF
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: test-${i}
  namespace: dns-system
spec:
  zone: example.com
  name: host-${i}
  ipv4Address: "192.0.2.${i}"
EOF
done

# Monitor
kubectl top pod -n dns-system
</code></pre>
<h2 id="best-practices-16"><a class="header" href="#best-practices-16">Best Practices</a></h2>
<h3 id="unit-tests-3"><a class="header" href="#unit-tests-3">Unit Tests</a></h3>
<ul>
<li>Test one thing at a time</li>
<li>Fast (&lt; 1s each)</li>
<li>No external dependencies</li>
<li>Descriptive names</li>
</ul>
<h3 id="integration-tests-3"><a class="header" href="#integration-tests-3">Integration Tests</a></h3>
<ul>
<li>Always use <code>#[ignore]</code></li>
<li>Check cluster connectivity first</li>
<li>Unique namespaces</li>
<li>Always cleanup</li>
<li>Good error messages</li>
</ul>
<h3 id="general-1"><a class="header" href="#general-1">General</a></h3>
<ul>
<li>Run <code>cargo fmt</code> before committing</li>
<li>Run <code>cargo clippy</code> to catch issues</li>
<li>Keep tests updated</li>
<li>Document complex scenarios</li>
</ul>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">Rust Testing</a></li>
<li><a href="https://github.com/kube-rs/kube/tree/main/examples">Kube-rs Examples</a></li>
<li><a href="https://kind.sigs.k8s.io/">Kind Docs</a></li>
<li><a href="https://bind9.readthedocs.io/">BIND9 Docs</a></li>
<li><a href="development/TEST_SUMMARY.html">TEST_SUMMARY.md</a> - Quick reference</li>
</ul>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<ul>
<li>GitHub Issues: https://github.com/firestoned/bindy/issues</li>
<li>Controller logs: <code>make kind-logs</code></li>
<li>Test with output: <code>cargo test -- --nocapture</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-coverage-1"><a class="header" href="#test-coverage-1">Test Coverage</a></h1>
<h2 id="test-statistics"><a class="header" href="#test-statistics">Test Statistics</a></h2>
<p><strong>Total Unit Tests</strong>: 95 (96 including helper tests)</p>
<h3 id="test-breakdown-by-module"><a class="header" href="#test-breakdown-by-module">Test Breakdown by Module</a></h3>
<h4 id="bind9-module-34-tests"><a class="header" href="#bind9-module-34-tests">bind9 Module (34 tests)</a></h4>
<p>Zone file and DNS record management tests:</p>
<ul>
<li>Zone creation and management (primary/secondary)</li>
<li>All 8 DNS record types (A, AAAA, CNAME, MX, TXT, NS, SRV, CAA)</li>
<li>Record lifecycle (add, update, delete)</li>
<li>TTL handling</li>
<li>Special characters and edge cases</li>
<li>Complete workflow tests</li>
</ul>
<h4 id="bind9_resources-module-21-tests"><a class="header" href="#bind9_resources-module-21-tests">bind9_resources Module (21 tests)</a></h4>
<p>Kubernetes resource builder tests:</p>
<ul>
<li>Label generation and consistency</li>
<li>ConfigMap creation with BIND9 configuration</li>
<li>Deployment creation with proper specs</li>
<li>Service creation with TCP/UDP ports</li>
<li>Pod specification validation</li>
<li>Volume and volume mount configuration</li>
<li>Health and readiness probes</li>
<li>BIND9 configuration options:
<ul>
<li>Recursion settings</li>
<li>ACL configuration (allow_query, allow_transfer)</li>
<li>DNSSEC configuration</li>
<li>Multiple ACL entries</li>
</ul>
</li>
<li>Resource naming conventions</li>
<li>Selector matching (Deployment ↔ Service)</li>
</ul>
<h4 id="crd_tests-module-28-tests"><a class="header" href="#crd_tests-module-28-tests">crd_tests Module (28 tests)</a></h4>
<p>CRD structure and validation tests:</p>
<ul>
<li>Label selectors and requirements</li>
<li>SOA record structure</li>
<li>Secondary zone configuration</li>
<li>All DNS record specs (A, AAAA, CNAME, MX, TXT, NS, SRV, CAA)</li>
<li>BIND9 configuration structures</li>
<li>DNSSEC configuration</li>
<li>Bind9Instance specifications</li>
<li>Status structures for all resource types</li>
</ul>
<h4 id="status-and-condition-tests-17-new-tests"><a class="header" href="#status-and-condition-tests-17-new-tests">Status and Condition Tests (17 new tests)</a></h4>
<p>Comprehensive condition type validation:</p>
<ul>
<li>All 5 condition types: Ready, Available, Progressing, Degraded, Failed</li>
<li>All 3 status values: True, False, Unknown</li>
<li>Condition field validation (type, status, reason, message, lastTransitionTime)</li>
<li>Multiple conditions support</li>
<li>Status structures for:
<ul>
<li>Bind9Instance (with replicas tracking)</li>
<li>DNSZone (with record count)</li>
<li>All DNS record types</li>
</ul>
</li>
<li>Condition serialization/deserialization</li>
<li>Observed generation tracking</li>
<li>Edge cases (no conditions, empty status)</li>
</ul>
<h4 id="integration-tests-4-tests-3-ignored"><a class="header" href="#integration-tests-4-tests-3-ignored">Integration Tests (4 tests, 3 ignored)</a></h4>
<ul>
<li>Kubernetes connectivity (ignored - requires cluster)</li>
<li>CRD installation verification (ignored - requires cluster)</li>
<li>Namespace creation/cleanup (ignored - requires cluster)</li>
<li>Unit test verification (always runs)</li>
</ul>
<h2 id="test-categories"><a class="header" href="#test-categories">Test Categories</a></h2>
<h3 id="unit-tests-95"><a class="header" href="#unit-tests-95">Unit Tests (95)</a></h3>
<ul>
<li><strong>Pure Functions</strong>: All resource builders, configuration generators</li>
<li><strong>Data Structures</strong>: All CRD types, status structures, conditions</li>
<li><strong>Business Logic</strong>: Zone management, record handling</li>
<li><strong>Validation</strong>: Condition types, status values, configuration options</li>
</ul>
<h3 id="integration-tests-3-ignored--1-running"><a class="header" href="#integration-tests-3-ignored--1-running">Integration Tests (3 ignored + 1 running)</a></h3>
<ul>
<li>Kubernetes cluster connectivity</li>
<li>CRD deployment</li>
<li>Resource lifecycle</li>
<li>End-to-end workflows</li>
</ul>
<h2 id="coverage-by-feature"><a class="header" href="#coverage-by-feature">Coverage by Feature</a></h2>
<h3 id="crd-validation"><a class="header" href="#crd-validation">CRD Validation</a></h3>
<ul>
<li>✅ All 10 CRDs have proper structure tests</li>
<li>✅ Condition types validated (Ready, Available, Progressing, Degraded, Failed)</li>
<li>✅ Status values validated (True, False, Unknown)</li>
<li>✅ Required fields enforced in CRD definitions</li>
<li>✅ Serialization/deserialization tested</li>
</ul>
<h3 id="bind9-configuration"><a class="header" href="#bind9-configuration">BIND9 Configuration</a></h3>
<ul>
<li>✅ Named configuration file generation</li>
<li>✅ Options configuration with all settings</li>
<li>✅ Recursion control</li>
<li>✅ ACL management (query, transfer)</li>
<li>✅ DNSSEC configuration (enable, validation)</li>
<li>✅ Default value handling</li>
<li>✅ Multiple ACL entries</li>
<li>✅ Empty ACL lists</li>
</ul>
<h3 id="kubernetes-resources"><a class="header" href="#kubernetes-resources">Kubernetes Resources</a></h3>
<ul>
<li>✅ Deployment creation with proper replica counts</li>
<li>✅ Service creation with TCP/UDP ports</li>
<li>✅ ConfigMap creation with BIND9 config</li>
<li>✅ Label consistency across resources</li>
<li>✅ Selector matching</li>
<li>✅ Volume and volume mount configuration</li>
<li>✅ Health probes (liveness, readiness)</li>
<li>✅ Container image version handling</li>
</ul>
<h3 id="dns-records-2"><a class="header" href="#dns-records-2">DNS Records</a></h3>
<ul>
<li>✅ All 8 record types (A, AAAA, CNAME, MX, TXT, NS, SRV, CAA)</li>
<li>✅ Record creation with TTL</li>
<li>✅ Default TTL handling</li>
<li>✅ Multiple records per zone</li>
<li>✅ Special characters in records</li>
<li>✅ Record deletion</li>
<li>✅ Zone apex vs subdomain records</li>
</ul>
<h3 id="status-management"><a class="header" href="#status-management">Status Management</a></h3>
<ul>
<li>✅ Condition creation with all fields</li>
<li>✅ Multiple conditions per resource</li>
<li>✅ Observed generation tracking</li>
<li>✅ Replica count tracking (Bind9Instance)</li>
<li>✅ Record count tracking (DNSZone)</li>
<li>✅ Status transitions (Ready ↔ Failed)</li>
<li>✅ Degraded state handling</li>
</ul>
<h2 id="running-tests-1"><a class="header" href="#running-tests-1">Running Tests</a></h2>
<h3 id="all-tests"><a class="header" href="#all-tests">All Tests</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="unit-tests-only"><a class="header" href="#unit-tests-only">Unit Tests Only</a></h3>
<pre><code class="language-bash">cargo test --lib
</code></pre>
<h3 id="specific-module"><a class="header" href="#specific-module">Specific Module</a></h3>
<pre><code class="language-bash">cargo test --lib bind9_resources
cargo test --lib crd_tests
</code></pre>
<h3 id="integration-tests-4"><a class="header" href="#integration-tests-4">Integration Tests</a></h3>
<pre><code class="language-bash">cargo test --test simple_integration -- --ignored
</code></pre>
<h3 id="with-coverage"><a class="header" href="#with-coverage">With Coverage</a></h3>
<pre><code class="language-bash">cargo tarpaulin --verbose --all-features --workspace --timeout 120 --out Xml
</code></pre>
<h2 id="test-quality-metrics"><a class="header" href="#test-quality-metrics">Test Quality Metrics</a></h2>
<ul>
<li><strong>Coverage</strong>: High coverage of core functionality</li>
<li><strong>Isolation</strong>: All unit tests are isolated and independent</li>
<li><strong>Speed</strong>: All unit tests complete in &lt; 0.01 seconds</li>
<li><strong>Deterministic</strong>: No flaky tests, all results are reproducible</li>
<li><strong>Comprehensive</strong>: Tests cover happy paths, edge cases, and error conditions</li>
</ul>
<h2 id="recent-additions-26-new-tests"><a class="header" href="#recent-additions-26-new-tests">Recent Additions (26 new tests)</a></h2>
<h3 id="bind9_resources-module-14-tests"><a class="header" href="#bind9_resources-module-14-tests">bind9_resources Module (+14 tests)</a></h3>
<ol>
<li><code>test_build_pod_spec</code> - Pod specification validation</li>
<li><code>test_build_deployment_replicas</code> - Replica count configuration</li>
<li><code>test_build_deployment_version</code> - BIND9 version handling</li>
<li><code>test_build_service_ports</code> - TCP/UDP port configuration</li>
<li><code>test_configmap_contains_all_files</code> - ConfigMap completeness</li>
<li><code>test_options_conf_with_recursion_enabled</code> - Recursion configuration</li>
<li><code>test_options_conf_with_multiple_acls</code> - Multiple ACL entries</li>
<li><code>test_labels_consistency</code> - Label validation</li>
<li><code>test_configmap_naming</code> - Naming conventions</li>
<li><code>test_deployment_selector_matches_labels</code> - Selector consistency</li>
<li><code>test_service_selector_matches_deployment</code> - Service selector matching</li>
<li><code>test_dnssec_config_enabled</code> - DNSSEC enable flag</li>
<li><code>test_dnssec_config_validation_only</code> - DNSSEC validation flag</li>
<li><code>test_options_conf_with_empty_transfer</code> - Empty transfer lists</li>
</ol>
<h3 id="crd_tests-module-17-tests"><a class="header" href="#crd_tests-module-17-tests">crd_tests Module (+17 tests)</a></h3>
<ol>
<li><code>test_condition_types</code> - All 5 condition types validation</li>
<li><code>test_condition_status_values</code> - All 3 status values validation</li>
<li><code>test_condition_with_all_fields</code> - Complete condition structure</li>
<li><code>test_multiple_conditions</code> - Multiple conditions support</li>
<li><code>test_dnszone_status_with_conditions</code> - DNSZone status</li>
<li><code>test_record_status_with_condition</code> - Record status</li>
<li><code>test_degraded_condition</code> - Degraded state handling</li>
<li><code>test_failed_condition</code> - Failed state handling</li>
<li><code>test_available_condition</code> - Available state</li>
<li><code>test_progressing_condition</code> - Progressing state</li>
<li><code>test_condition_serialization</code> - JSON serialization</li>
<li><code>test_status_with_no_conditions</code> - Empty conditions list</li>
<li><code>test_observed_generation_tracking</code> - Generation tracking</li>
<li><code>test_bind9_config</code> - BIND9 configuration structure</li>
<li><code>test_dnssec_config</code> - DNSSEC configuration</li>
<li><code>test_bind9instance_spec</code> - Instance specification</li>
<li><code>test_bind9instance_status_default</code> - Status defaults</li>
</ol>
<h2 id="next-steps-41"><a class="header" href="#next-steps-41">Next Steps</a></h2>
<h3 id="potential-test-additions"><a class="header" href="#potential-test-additions">Potential Test Additions</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Integration tests for actual BIND9 deployment</li>
<li><input disabled="" type="checkbox"/>
Integration tests for zone transfer between primary/secondary</li>
<li><input disabled="" type="checkbox"/>
Performance tests for large zone files</li>
<li><input disabled="" type="checkbox"/>
Stress tests with many concurrent updates</li>
<li><input disabled="" type="checkbox"/>
Property-based tests for configuration generation</li>
<li><input disabled="" type="checkbox"/>
Mock reconciler tests</li>
<li><input disabled="" type="checkbox"/>
Controller loop tests</li>
</ul>
<h3 id="test-infrastructure"><a class="header" href="#test-infrastructure">Test Infrastructure</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Add benchmarks for critical paths</li>
<li><input disabled="" type="checkbox"/>
Add mutation testing</li>
<li><input disabled="" type="checkbox"/>
Add fuzz testing for DNS record parsing</li>
<li><input disabled="" type="checkbox"/>
Set up continuous coverage tracking</li>
<li><input disabled="" type="checkbox"/>
Add test fixtures and helpers</li>
</ul>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<p>All tests run automatically in GitHub Actions:</p>
<ul>
<li><strong>PR Workflow</strong>: Runs on every pull request</li>
<li><strong>Main Workflow</strong>: Runs on pushes to main branch</li>
<li><strong>Coverage</strong>: Uploaded to Codecov after each run</li>
<li><strong>Integration</strong>: Runs in dedicated workflow with Kind cluster</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h1>
<p>Daily development workflow for Bindy contributors.</p>
<h2 id="development-cycle"><a class="header" href="#development-cycle">Development Cycle</a></h2>
<ol>
<li><strong>Create feature branch</strong></li>
</ol>
<pre><code class="language-bash">git checkout -b feature/my-feature
</code></pre>
<ol start="2">
<li><strong>Make changes</strong></li>
</ol>
<ul>
<li>Edit code in <code>src/</code></li>
<li>If modifying CRDs, edit Rust types in <code>src/crd.rs</code></li>
<li>Add tests</li>
<li>Update documentation</li>
</ul>
<ol start="3">
<li><strong>Regenerate CRDs (if modified)</strong></li>
</ol>
<pre><code class="language-bash"># If you modified src/crd.rs, regenerate YAML files
cargo run --bin crdgen
# or
make crds
</code></pre>
<ol start="4">
<li><strong>Test locally</strong></li>
</ol>
<pre><code class="language-bash">cargo test
cargo clippy -- -D warnings
cargo fmt
</code></pre>
<ol start="5">
<li><strong>Validate CRDs</strong></li>
</ol>
<pre><code class="language-bash"># Ensure generated CRDs are valid
kubectl apply --dry-run=client -f deploy/crds/
</code></pre>
<ol start="6">
<li><strong>Commit changes</strong></li>
</ol>
<pre><code class="language-bash">git add .
git commit -m "Add feature: description"
</code></pre>
<ol start="7">
<li><strong>Push and create PR</strong></li>
</ol>
<pre><code class="language-bash">git push origin feature/my-feature
# Create PR on GitHub
</code></pre>
<h2 id="crd-development"><a class="header" href="#crd-development">CRD Development</a></h2>
<p><strong>IMPORTANT:</strong> <code>src/crd.rs</code> is the source of truth. CRD YAML files in <code>deploy/crds/</code> are auto-generated.</p>
<h3 id="modifying-existing-crds"><a class="header" href="#modifying-existing-crds">Modifying Existing CRDs</a></h3>
<ol>
<li><strong>Edit the Rust type</strong> in <code>src/crd.rs</code>:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(CustomResource, Clone, Debug, Serialize, Deserialize, JsonSchema)]
#[kube(
    group = "bindy.firestoned.io",
    version = "v1alpha1",
    kind = "Bind9Cluster",
    namespaced
)]
#[serde(rename_all = "camelCase")]
pub struct Bind9ClusterSpec {
    pub version: Option&lt;String&gt;,
    // Add new fields here
    pub new_field: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Regenerate YAML files</strong>:</li>
</ol>
<pre><code class="language-bash">cargo run --bin crdgen
# or
make crds
</code></pre>
<ol start="3">
<li><strong>Verify the generated YAML</strong>:</li>
</ol>
<pre><code class="language-bash"># Check the generated file
cat deploy/crds/bind9clusters.crd.yaml

# Validate it
kubectl apply --dry-run=client -f deploy/crds/bind9clusters.crd.yaml
</code></pre>
<ol start="4">
<li><strong>Update documentation</strong> to describe the new field</li>
</ol>
<h3 id="adding-new-crds"><a class="header" href="#adding-new-crds">Adding New CRDs</a></h3>
<ol>
<li><strong>Define the CustomResource</strong> in <code>src/crd.rs</code></li>
<li><strong>Add to crdgen</strong> in <code>src/bin/crdgen.rs</code>:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>generate_crd::&lt;MyNewResource&gt;("mynewresources.crd.yaml", output_dir)?;
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Regenerate YAMLs</strong>: <code>make crds</code></li>
<li><strong>Export the type</strong> in <code>src/lib.rs</code> if needed</li>
</ol>
<h3 id="generated-yaml-format"><a class="header" href="#generated-yaml-format">Generated YAML Format</a></h3>
<p>All generated CRD files include:</p>
<ul>
<li>Copyright header</li>
<li>SPDX license identifier</li>
<li>Auto-generated warning</li>
</ul>
<p><strong>Never edit YAML files directly</strong> - they will be overwritten!</p>
<h2 id="local-testing"><a class="header" href="#local-testing">Local Testing</a></h2>
<pre><code class="language-bash"># Start kind cluster
kind create cluster --name bindy-dev

# Deploy CRDs (regenerate first if modified)
make crds
kubectl apply -k deploy/crds/

# Run controller locally
RUST_LOG=debug cargo run
</code></pre>
<h2 id="hot-reload"><a class="header" href="#hot-reload">Hot Reload</a></h2>
<pre><code class="language-bash"># Auto-rebuild on changes
cargo watch -x 'run --release'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-pages-setup-guide"><a class="header" href="#github-pages-setup-guide">GitHub Pages Setup Guide</a></h1>
<p>This guide explains how to enable GitHub Pages for the Bindy documentation.</p>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<ul>
<li>Repository must be pushed to GitHub</li>
<li>You must have admin access to the repository</li>
<li>The <code>.github/workflows/docs.yaml</code> workflow file must be present</li>
</ul>
<h2 id="setup-steps"><a class="header" href="#setup-steps">Setup Steps</a></h2>
<h3 id="1-enable-github-pages"><a class="header" href="#1-enable-github-pages">1. Enable GitHub Pages</a></h3>
<ol>
<li>Go to your repository on GitHub: https://github.com/firestoned/bindy</li>
<li>Click <strong>Settings</strong> (in the repository menu)</li>
<li>Scroll down to the <strong>Pages</strong> section in the left sidebar</li>
<li>Click on <strong>Pages</strong></li>
</ol>
<h3 id="2-configure-source"><a class="header" href="#2-configure-source">2. Configure Source</a></h3>
<p>Under "Build and deployment":</p>
<ol>
<li><strong>Source</strong>: Select "GitHub Actions"</li>
<li>This will use the workflow in <code>.github/workflows/docs.yaml</code></li>
</ol>
<p>That's it! GitHub will automatically use the workflow.</p>
<h3 id="3-trigger-the-first-build"><a class="header" href="#3-trigger-the-first-build">3. Trigger the First Build</a></h3>
<p>The documentation will be built and deployed automatically when you push to the <code>main</code> branch.</p>
<p>To trigger the first build:</p>
<ol>
<li>
<p>Push any change to <code>main</code>:</p>
<pre><code class="language-bash">git push origin main
</code></pre>
</li>
<li>
<p>Or manually trigger the workflow:</p>
<ul>
<li>Go to <strong>Actions</strong> tab</li>
<li>Click on "Documentation" workflow</li>
<li>Click "Run workflow"</li>
<li>Select <code>main</code> branch</li>
<li>Click "Run workflow"</li>
</ul>
</li>
</ol>
<h3 id="4-monitor-the-build"><a class="header" href="#4-monitor-the-build">4. Monitor the Build</a></h3>
<ol>
<li>Go to the <strong>Actions</strong> tab in your repository</li>
<li>Click on the "Documentation" workflow run</li>
<li>Watch the build progress</li>
<li>Once complete, the "deploy" job will show the URL</li>
</ol>
<h3 id="5-access-your-documentation"><a class="header" href="#5-access-your-documentation">5. Access Your Documentation</a></h3>
<p>Once deployed, your documentation will be available at:</p>
<p><strong>https://firestoned.github.io/bindy/</strong></p>
<h2 id="verification-3"><a class="header" href="#verification-3">Verification</a></h2>
<h3 id="check-deployment-status"><a class="header" href="#check-deployment-status">Check Deployment Status</a></h3>
<ol>
<li>Go to <strong>Settings</strong> → <strong>Pages</strong></li>
<li>You should see: "Your site is live at https://firestoned.github.io/bindy/"</li>
<li>Click "Visit site" to view the documentation</li>
</ol>
<h3 id="verify-documentation-structure"><a class="header" href="#verify-documentation-structure">Verify Documentation Structure</a></h3>
<p>Your deployed site should have:</p>
<ul>
<li>Main documentation (mdBook): https://firestoned.github.io/bindy/</li>
<li>API reference (rustdoc): https://firestoned.github.io/bindy/rustdoc/</li>
</ul>
<h2 id="troubleshooting-8"><a class="header" href="#troubleshooting-8">Troubleshooting</a></h2>
<h3 id="build-fails"><a class="header" href="#build-fails">Build Fails</a></h3>
<p><strong>Check workflow logs:</strong></p>
<ol>
<li>Go to <strong>Actions</strong> tab</li>
<li>Click on the failed workflow run</li>
<li>Expand the failed step to see the error</li>
<li>Common issues:
<ul>
<li>Rust compilation errors</li>
<li>mdBook build errors</li>
<li>Missing files</li>
</ul>
</li>
</ol>
<p><strong>Fix and retry:</strong></p>
<ol>
<li>Fix the issue locally</li>
<li>Test with <code>make docs</code></li>
<li>Push the fix to <code>main</code></li>
<li>GitHub Actions will automatically retry</li>
</ol>
<h3 id="pages-not-showing"><a class="header" href="#pages-not-showing">Pages Not Showing</a></h3>
<p><strong>Verify GitHub Pages is enabled:</strong></p>
<ol>
<li>Go to <strong>Settings</strong> → <strong>Pages</strong></li>
<li>Ensure source is set to "GitHub Actions"</li>
<li>Check that at least one successful deployment has completed</li>
</ol>
<p><strong>Check permissions:</strong></p>
<p>The workflow needs these permissions (already configured in <code>docs.yaml</code>):</p>
<pre><code class="language-yaml">permissions:
  contents: read
  pages: write
  id-token: write
</code></pre>
<h3 id="404-errors-on-subpages"><a class="header" href="#404-errors-on-subpages">404 Errors on Subpages</a></h3>
<p><strong>Check base URL configuration:</strong></p>
<p>The <code>book.toml</code> has:</p>
<pre><code class="language-toml">site-url = "/bindy/"
</code></pre>
<p>This must match your repository name. If your repository is named differently, update this value.</p>
<h3 id="custom-domain-optional"><a class="header" href="#custom-domain-optional">Custom Domain (Optional)</a></h3>
<p>To use a custom domain:</p>
<ol>
<li>Go to <strong>Settings</strong> → <strong>Pages</strong></li>
<li>Under "Custom domain", enter your domain</li>
<li>Update the <code>CNAME</code> field in <code>book.toml</code>:
<pre><code class="language-toml">cname = "docs.yourdomain.com"
</code></pre>
</li>
<li>Configure DNS:
<ul>
<li>Add a CNAME record pointing to <code>firestoned.github.io</code></li>
<li>Or A records pointing to GitHub Pages IPs</li>
</ul>
</li>
</ol>
<h2 id="updating-documentation"><a class="header" href="#updating-documentation">Updating Documentation</a></h2>
<p>Documentation is automatically deployed on every push to <code>main</code>:</p>
<pre><code class="language-bash"># Make changes to documentation
vim docs/src/introduction.md

# Commit and push
git add docs/src/introduction.md
git commit -m "Update introduction"
git push origin main

# GitHub Actions will automatically build and deploy
</code></pre>
<h2 id="local-preview"><a class="header" href="#local-preview">Local Preview</a></h2>
<p>Before pushing, preview your changes locally:</p>
<pre><code class="language-bash"># Build and serve documentation
make docs-serve

# Or watch for changes
make docs-watch

# Open http://localhost:3000 in your browser
</code></pre>
<h2 id="workflow-details"><a class="header" href="#workflow-details">Workflow Details</a></h2>
<p>The GitHub Actions workflow (<code>.github/workflows/docs.yaml</code>):</p>
<ol>
<li>
<p><strong>Build</strong> job:</p>
<ul>
<li>Checks out the repository</li>
<li>Sets up Rust toolchain</li>
<li>Installs mdBook</li>
<li>Builds rustdoc API documentation</li>
<li>Builds mdBook user documentation</li>
<li>Combines both into a single site</li>
<li>Uploads artifact to GitHub Pages</li>
</ul>
</li>
<li>
<p><strong>Deploy</strong> job (only on <code>main</code>):</p>
<ul>
<li>Deploys the artifact to GitHub Pages</li>
<li>Updates the live site</li>
</ul>
</li>
</ol>
<h2 id="branch-protection-recommended"><a class="header" href="#branch-protection-recommended">Branch Protection (Recommended)</a></h2>
<p>To ensure documentation quality:</p>
<ol>
<li>Go to <strong>Settings</strong> → <strong>Branches</strong></li>
<li>Add a branch protection rule for <code>main</code>:
<ul>
<li>Require pull request reviews</li>
<li>Require status checks (include "Documentation / Build Documentation")</li>
<li>This ensures the documentation builds before merging</li>
</ul>
</li>
</ol>
<h2 id="additional-configuration"><a class="header" href="#additional-configuration">Additional Configuration</a></h2>
<h3 id="custom-theme"><a class="header" href="#custom-theme">Custom Theme</a></h3>
<p>The documentation uses a custom theme defined in:</p>
<ul>
<li><code>docs/theme/custom.css</code> - Custom styling</li>
</ul>
<p>To customize:</p>
<ol>
<li>Edit the CSS file</li>
<li>Test locally with <code>make docs-watch</code></li>
<li>Push to <code>main</code></li>
</ol>
<h3 id="search-configuration"><a class="header" href="#search-configuration">Search Configuration</a></h3>
<p>Search is configured in <code>book.toml</code>:</p>
<pre><code class="language-toml">[output.html.search]
enable = true
limit-results = 30
</code></pre>
<p>Adjust as needed for your use case.</p>
<h2 id="support-1"><a class="header" href="#support-1">Support</a></h2>
<p>For issues with GitHub Pages deployment:</p>
<ul>
<li><strong>GitHub Pages Status</strong>: https://www.githubstatus.com/</li>
<li><strong>GitHub Actions Documentation</strong>: https://docs.github.com/en/actions</li>
<li><strong>GitHub Pages Documentation</strong>: https://docs.github.com/en/pages</li>
</ul>
<p>For issues with the documentation content:</p>
<ul>
<li>Create an issue: https://github.com/firestoned/bindy/issues</li>
<li>Start a discussion: https://github.com/firestoned/bindy/discussions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-deep-dive"><a class="header" href="#architecture-deep-dive">Architecture Deep Dive</a></h1>
<p>Technical architecture of the Bindy DNS operator.</p>
<h2 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h2>
<pre><code>┌─────────────────────────────────────┐
│     Kubernetes API Server           │
└──────────────┬──────────────────────┘
               │ Watch/Update
     ┌─────────▼────────────┐
     │  Bindy Controller    │
     │  ┌────────────────┐  │
     │  │ Reconcilers    │  │
     │  │  - Bind9Inst   │  │
     │  │  - DNSZone     │  │
     │  │  - Records     │  │
     │  └────────────────┘  │
     └──────┬───────────────┘
            │ Manages
     ┌──────▼────────────────┐
     │  BIND9 Pods           │
     │  ┌──────────────────┐ │
     │  │ ConfigMaps       │ │
     │  │ Deployments      │ │
     │  │ Services         │ │
     │  └──────────────────┘ │
     └───────────────────────┘
</code></pre>
<h2 id="components-1"><a class="header" href="#components-1">Components</a></h2>
<h3 id="controller"><a class="header" href="#controller">Controller</a></h3>
<ul>
<li>Watches CRD resources</li>
<li>Reconciles desired vs actual state</li>
<li>Manages Kubernetes resources</li>
</ul>
<h3 id="reconcilers"><a class="header" href="#reconcilers">Reconcilers</a></h3>
<ul>
<li>Per-resource reconciliation logic</li>
<li>Idempotent operations</li>
<li>Error handling and retries</li>
</ul>
<h3 id="bind9-integration"><a class="header" href="#bind9-integration">BIND9 Integration</a></h3>
<ul>
<li>Configuration generation</li>
<li>Zone file management</li>
<li>BIND9 lifecycle management</li>
</ul>
<p>See detailed docs:</p>
<ul>
<li><a href="development/./controller-design.html">Controller Design</a></li>
<li><a href="development/./reconciliation.html">Reconciliation Logic</a></li>
<li><a href="development/./bind9-integration.html">BIND9 Integration</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controller-design"><a class="header" href="#controller-design">Controller Design</a></h1>
<p>Design and implementation of the Bindy controller.</p>
<h2 id="controller-pattern"><a class="header" href="#controller-pattern">Controller Pattern</a></h2>
<p>Bindy implements the Kubernetes controller pattern:</p>
<ol>
<li><strong>Watch</strong> - Monitor CRD resources</li>
<li><strong>Reconcile</strong> - Ensure actual state matches desired</li>
<li><strong>Update</strong> - Apply changes to Kubernetes resources</li>
</ol>
<h2 id="reconciliation-loop-1"><a class="header" href="#reconciliation-loop-1">Reconciliation Loop</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    // Get resource from work queue
    let resource = queue.pop();
    
    // Reconcile
    match reconcile(resource).await {
        Ok(_) =&gt; {
            // Success - requeue with normal delay
            queue.requeue(resource, Duration::from_secs(300));
        }
        Err(e) =&gt; {
            // Error - retry with backoff
            queue.requeue_with_backoff(resource, e);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="state-management-1"><a class="header" href="#state-management-1">State Management</a></h2>
<p>Controller maintains no local state - all state in Kubernetes:</p>
<ul>
<li>CRD resources (desired state)</li>
<li>Deployments, Services, ConfigMaps (actual state)</li>
<li>Status fields (observed state)</li>
</ul>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<ul>
<li>Transient errors: Retry with exponential backoff</li>
<li>Permanent errors: Update status, log, requeue</li>
<li>Resource conflicts: Retry with latest version</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reconciliation-logic"><a class="header" href="#reconciliation-logic">Reconciliation Logic</a></h1>
<p>Detailed reconciliation logic for each resource type.</p>
<h2 id="bind9instance-reconciliation"><a class="header" href="#bind9instance-reconciliation">Bind9Instance Reconciliation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn reconcile_bind9instance(instance: Bind9Instance) -&gt; Result&lt;()&gt; {
    // 1. Build desired resources
    let configmap = build_configmap(&amp;instance);
    let deployment = build_deployment(&amp;instance);
    let service = build_service(&amp;instance);
    
    // 2. Apply or update ConfigMap
    apply_configmap(configmap).await?;
    
    // 3. Apply or update Deployment
    apply_deployment(deployment).await?;
    
    // 4. Apply or update Service
    apply_service(service).await?;
    
    // 5. Update status
    update_status(&amp;instance, "Ready").await?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dnszone-reconciliation"><a class="header" href="#dnszone-reconciliation">DNSZone Reconciliation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn reconcile_dnszone(zone: DNSZone) -&gt; Result&lt;()&gt; {
    // 1. Find matching Bind9Instances
    let instances = find_instances(&amp;zone.spec.instance_selector).await?;
    
    // 2. Generate zone file content
    let zone_content = generate_zone_file(&amp;zone)?;
    
    // 3. Update zone on each instance
    for instance in instances {
        update_zone_on_instance(&amp;instance, &amp;zone_content).await?;
    }
    
    // 4. Update status
    update_zone_status(&amp;zone, instances.len()).await?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="record-reconciliation"><a class="header" href="#record-reconciliation">Record Reconciliation</a></h2>
<p>All record types follow similar pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn reconcile_record(record: Record) -&gt; Result&lt;()&gt; {
    // 1. Get zone
    let zone = get_zone(&amp;record.spec.zone).await?;
    
    // 2. Add record to zone
    zone_manager.add_record(&amp;zone, &amp;record)?;
    
    // 3. Update status
    update_record_status(&amp;record, "Ready").await?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bind9-integration-1"><a class="header" href="#bind9-integration-1">BIND9 Integration</a></h1>
<p>How Bindy integrates with BIND9 DNS server.</p>
<h2 id="configuration-generation"><a class="header" href="#configuration-generation">Configuration Generation</a></h2>
<p>Bindy generates BIND9 configuration from Bind9Instance specs:</p>
<h3 id="namedconf"><a class="header" href="#namedconf">named.conf</a></h3>
<pre><code>options {
    directory "/var/lib/bind";
    recursion no;
    allow-query { 0.0.0.0/0; };
};

zone "example.com" {
    type master;
    file "/var/lib/bind/zones/example.com.zone";
};
</code></pre>
<h3 id="zone-files"><a class="header" href="#zone-files">Zone Files</a></h3>
<pre><code>$TTL 3600
@   IN  SOA ns1.example.com. admin.example.com. (
        2024010101  ; serial
        3600        ; refresh
        600         ; retry
        604800      ; expire
        86400 )     ; negative TTL
    IN  NS  ns1.example.com.
www IN  A   192.0.2.1
</code></pre>
<h2 id="zone-file-management"><a class="header" href="#zone-file-management">Zone File Management</a></h2>
<p>Operations:</p>
<ul>
<li>Create new zones</li>
<li>Add/update records</li>
<li>Increment serial numbers</li>
<li>Reload BIND9 configuration</li>
</ul>
<h2 id="bind9-lifecycle"><a class="header" href="#bind9-lifecycle">BIND9 Lifecycle</a></h2>
<ol>
<li><strong>ConfigMap</strong> - Contains configuration files</li>
<li><strong>Volume Mount</strong> - Mount ConfigMap to BIND9 pod</li>
<li><strong>Init</strong> - BIND9 starts with configuration</li>
<li><strong>Reload</strong> - <code>rndc reload</code> when configuration changes</li>
</ol>
<h2 id="future-enhancements-1"><a class="header" href="#future-enhancements-1">Future Enhancements</a></h2>
<ul>
<li>Dynamic DNS updates (nsupdate)</li>
<li>TSIG key management</li>
<li>Zone transfer monitoring</li>
<li>Query statistics collection</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Thank you for contributing to Bindy!</p>
<h2 id="ways-to-contribute"><a class="header" href="#ways-to-contribute">Ways to Contribute</a></h2>
<ul>
<li>Report bugs</li>
<li>Suggest features</li>
<li>Improve documentation</li>
<li>Submit code changes</li>
<li>Review pull requests</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<ol>
<li><a href="development/./setup.html">Set up development environment</a></li>
<li>Read <a href="development/./code-style.html">Code Style</a></li>
<li>Check <a href="development/./testing-guidelines.html">Testing Guidelines</a></li>
<li>Follow <a href="development/./pr-process.html">PR Process</a></li>
</ol>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>Be respectful, inclusive, and professional.</p>
<h2 id="reporting-issues"><a class="header" href="#reporting-issues">Reporting Issues</a></h2>
<p>Use GitHub issues with:</p>
<ul>
<li>Clear description</li>
<li>Steps to reproduce</li>
<li>Expected vs actual behavior</li>
<li>Environment details</li>
</ul>
<h2 id="feature-requests"><a class="header" href="#feature-requests">Feature Requests</a></h2>
<p>Open an issue describing:</p>
<ul>
<li>Use case</li>
<li>Proposed solution</li>
<li>Alternatives considered</li>
</ul>
<h2 id="questions"><a class="header" href="#questions">Questions</a></h2>
<p>Ask questions in:</p>
<ul>
<li>GitHub Discussions</li>
<li>Issues (tagged as question)</li>
</ul>
<h2 id="license-1"><a class="header" href="#license-1">License</a></h2>
<h3 id="contributor-license-agreement"><a class="header" href="#contributor-license-agreement">Contributor License Agreement</a></h3>
<p>By contributing to Bindy, you agree that:</p>
<ol>
<li><strong>Your contributions will be licensed under the MIT License</strong> - The same license that covers the project</li>
<li><strong>You have the right to submit the work</strong> - You own the copyright or have permission from the copyright holder</li>
<li><strong>You grant a perpetual license</strong> - The project maintainers receive a perpetual, worldwide, non-exclusive, royalty-free, irrevocable license to use, modify, and distribute your contributions</li>
</ol>
<h3 id="what-this-means"><a class="header" href="#what-this-means">What This Means</a></h3>
<p>When you submit a pull request or contribution to Bindy:</p>
<ul>
<li>✅ Your code will be licensed under the <strong>MIT License</strong></li>
<li>✅ You retain copyright to your contributions</li>
<li>✅ Others can use your contributions under the MIT License terms</li>
<li>✅ Your contributions can be used in both open source and commercial projects</li>
<li>✅ You grant irrevocable permission for the project to use your work</li>
</ul>
<h3 id="spdx-license-identifiers"><a class="header" href="#spdx-license-identifiers">SPDX License Identifiers</a></h3>
<p>All source code files in Bindy include SPDX license identifiers. When adding new files, please include the following header:</p>
<p><strong>For Rust files:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright (c) 2025 Erick Bourgeois, firestoned
// SPDX-License-Identifier: MIT
<span class="boring">}</span></code></pre></pre>
<p><strong>For shell scripts:</strong></p>
<pre><code class="language-bash">#!/usr/bin/env bash
# Copyright (c) 2025 Erick Bourgeois, firestoned
# SPDX-License-Identifier: MIT
</code></pre>
<p><strong>For YAML/configuration files:</strong></p>
<pre><code class="language-yaml"># Copyright (c) 2025 Erick Bourgeois, firestoned
# SPDX-License-Identifier: MIT
</code></pre>
<p><strong>For Makefiles and Dockerfiles:</strong></p>
<pre><code class="language-makefile"># Copyright (c) 2025 Erick Bourgeois, firestoned
# SPDX-License-Identifier: MIT
</code></pre>
<h3 id="why-spdx-identifiers"><a class="header" href="#why-spdx-identifiers">Why SPDX Identifiers?</a></h3>
<p>SPDX (Software Package Data Exchange) identifiers provide:</p>
<ul>
<li><strong>Machine-readable license information</strong> - Automated tools can scan and verify licenses</li>
<li><strong>SBOM generation</strong> - Software Bill of Materials can be automatically created</li>
<li><strong>License compliance</strong> - Makes it easier to track and verify licensing</li>
<li><strong>Industry standard</strong> - Widely adopted across open source projects</li>
</ul>
<p>Learn more: <a href="https://spdx.dev/">https://spdx.dev/</a></p>
<h3 id="third-party-code"><a class="header" href="#third-party-code">Third-Party Code</a></h3>
<p>If you're adding code from another source:</p>
<ol>
<li><strong>Ensure compatibility</strong> - The license must be compatible with MIT</li>
<li><strong>Preserve original copyright</strong> - Keep the original copyright notice</li>
<li><strong>Document the source</strong> - Note where the code came from</li>
<li><strong>Check license requirements</strong> - Some licenses require attribution or notices</li>
</ol>
<p>Compatible licenses include:</p>
<ul>
<li>✅ MIT License</li>
<li>✅ Apache License 2.0</li>
<li>✅ BSD licenses (2-clause, 3-clause)</li>
<li>✅ ISC License</li>
<li>✅ Public Domain (CC0, Unlicense)</li>
</ul>
<h3 id="license-questions"><a class="header" href="#license-questions">License Questions</a></h3>
<p>If you have questions about:</p>
<ul>
<li>Whether your contribution is compatible</li>
<li>License requirements for third-party code</li>
<li>Copyright or attribution</li>
</ul>
<p>Please ask in your pull request or open a discussion before submitting.</p>
<h3 id="additional-resources-1"><a class="header" href="#additional-resources-1">Additional Resources</a></h3>
<ul>
<li><a href="development/../../LICENSE">Full Project License</a> - MIT License text</li>
<li><a href="development/../license.html">License Documentation</a> - Comprehensive licensing information</li>
<li><a href="https://spdx.org/licenses/">SPDX License List</a> - Standard license identifiers</li>
<li><a href="https://choosealicense.com/">Choose a License</a> - Help choosing licenses for new projects</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-style"><a class="header" href="#code-style">Code Style</a></h1>
<p>Code style guidelines for Bindy.</p>
<h2 id="rust-style"><a class="header" href="#rust-style">Rust Style</a></h2>
<p>Follow official Rust style guide:</p>
<pre><code class="language-bash"># Format code
cargo fmt

# Check for issues
cargo clippy
</code></pre>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h2>
<ul>
<li><code>snake_case</code> for functions, variables</li>
<li><code>PascalCase</code> for types, traits</li>
<li><code>SCREAMING_SNAKE_CASE</code> for constants</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Document public APIs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Reconciles a Bind9Instance resource.
///
/// Creates or updates Kubernetes resources for BIND9.
///
/// # Arguments
///
/// * `instance` - The Bind9Instance to reconcile
///
/// # Returns
///
/// Ok(()) on success, Err on failure
pub async fn reconcile(instance: Bind9Instance) -&gt; Result&lt;()&gt; {
    // Implementation
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>Use <code>anyhow::Result</code> for errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::{Context, Result};

fn do_thing() -&gt; Result&lt;()&gt; {
    some_operation()
        .context("Failed to do thing")?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Write tests for all public functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_function() {
        assert_eq!(function(), expected);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-guidelines"><a class="header" href="#testing-guidelines">Testing Guidelines</a></h1>
<p>Guidelines for writing tests in Bindy.</p>
<h2 id="test-structure-1"><a class="header" href="#test-structure-1">Test Structure</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_name() {
        // Arrange
        let input = create_input();
        
        // Act
        let result = function_under_test(input);
        
        // Assert
        assert_eq!(result, expected);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="unit-tests-4"><a class="header" href="#unit-tests-4">Unit Tests</a></h2>
<p>Test individual functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_build_configmap() {
    let instance = create_test_instance();
    let configmap = build_configmap(&amp;instance);
    
    assert_eq!(configmap.metadata.name, Some("test".to_string()));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tests-5"><a class="header" href="#integration-tests-5">Integration Tests</a></h2>
<p>Test with Kubernetes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
#[ignore]  // Requires cluster
async fn test_full_reconciliation() {
    let client = Client::try_default().await.unwrap();
    // Test logic
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-coverage-2"><a class="header" href="#test-coverage-2">Test Coverage</a></h2>
<p>Aim for &gt;80% coverage on new code.</p>
<h2 id="ci-tests"><a class="header" href="#ci-tests">CI Tests</a></h2>
<p>All tests run on:</p>
<ul>
<li>Pull requests</li>
<li>Main branch commits</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pull-request-process"><a class="header" href="#pull-request-process">Pull Request Process</a></h1>
<p>Process for submitting and reviewing pull requests.</p>
<h2 id="before-submitting"><a class="header" href="#before-submitting">Before Submitting</a></h2>
<ol>
<li><strong>Create issue</strong> (for non-trivial changes)</li>
<li><strong>Create branch</strong> from main</li>
<li><strong>Make changes</strong> with tests</li>
<li><strong>Run checks</strong> locally:</li>
</ol>
<pre><code class="language-bash">cargo test
cargo clippy
cargo fmt
</code></pre>
<h2 id="pr-requirements"><a class="header" href="#pr-requirements">PR Requirements</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Tests pass</li>
<li><input disabled="" type="checkbox"/>
Code formatted</li>
<li><input disabled="" type="checkbox"/>
Documentation updated</li>
<li><input disabled="" type="checkbox"/>
Commit messages clear</li>
<li><input disabled="" type="checkbox"/>
PR description complete</li>
</ul>
<h2 id="pr-template"><a class="header" href="#pr-template">PR Template</a></h2>
<pre><code class="language-markdown">## Description
Brief description of changes

## Related Issue
Fixes #123

## Changes
- Added feature X
- Fixed bug Y

## Testing
How changes were tested

## Checklist
- [ ] Tests added/updated
- [ ] Documentation updated
- [ ] Changelog updated (if needed)
</code></pre>
<h2 id="review-process"><a class="header" href="#review-process">Review Process</a></h2>
<ol>
<li><strong>Automated checks</strong> must pass</li>
<li><strong>Maintainer review</strong> required</li>
<li><strong>Address feedback</strong></li>
<li><strong>Merge</strong> when approved</li>
</ol>
<h2 id="after-merge"><a class="header" href="#after-merge">After Merge</a></h2>
<p>Changes included in next release.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>Complete reference for Bindy's Kubernetes Custom Resources.</p>
<h2 id="custom-resource-definitions-1"><a class="header" href="#custom-resource-definitions-1">Custom Resource Definitions</a></h2>
<p>Bindy provides the following CRDs:</p>
<h3 id="core-resources-1"><a class="header" href="#core-resources-1">Core Resources</a></h3>
<h4 id="bind9instance-4"><a class="header" href="#bind9instance-4">Bind9Instance</a></h4>
<p>Manages BIND9 DNS server instances.</p>
<ul>
<li><strong>Group</strong>: bindy.firestoned.io</li>
<li><strong>Version</strong>: v1alpha1</li>
<li><strong>Kind</strong>: Bind9Instance</li>
<li><strong>Plural</strong>: bind9instances</li>
<li><strong>Scope</strong>: Namespaced</li>
</ul>
<p><a href="reference/./bind9instance-spec.html">Full specification →</a></p>
<h4 id="dnszone-3"><a class="header" href="#dnszone-3">DNSZone</a></h4>
<p>Defines DNS zones to be served by Bind9Instances.</p>
<ul>
<li><strong>Group</strong>: bindy.firestoned.io</li>
<li><strong>Version</strong>: v1alpha1</li>
<li><strong>Kind</strong>: DNSZone</li>
<li><strong>Plural</strong>: dnszones</li>
<li><strong>Scope</strong>: Namespaced</li>
</ul>
<p><a href="reference/./dnszone-spec.html">Full specification →</a></p>
<h3 id="dns-record-resources"><a class="header" href="#dns-record-resources">DNS Record Resources</a></h3>
<p>All record resources share:</p>
<ul>
<li><strong>Group</strong>: bindy.firestoned.io</li>
<li><strong>Version</strong>: v1alpha1</li>
<li><strong>Scope</strong>: Namespaced</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Kind</th><th>Purpose</th></tr></thead><tbody>
<tr><td>arecords</td><td>ARecord</td><td>IPv4 address records</td></tr>
<tr><td>aaaarecords</td><td>AAAARecord</td><td>IPv6 address records</td></tr>
<tr><td>cnamerecords</td><td>CNAMERecord</td><td>Canonical name (alias) records</td></tr>
<tr><td>mxrecords</td><td>MXRecord</td><td>Mail exchange records</td></tr>
<tr><td>txtrecords</td><td>TXTRecord</td><td>Text records</td></tr>
<tr><td>nsrecords</td><td>NSRecord</td><td>Name server records</td></tr>
<tr><td>srvrecords</td><td>SRVRecord</td><td>Service location records</td></tr>
<tr><td>caarecords</td><td>CAARecord</td><td>Certificate authority authorization</td></tr>
</tbody></table>
</div>
<p><a href="reference/./record-specs.html">Full record specifications →</a></p>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="labels-and-selectors-1"><a class="header" href="#labels-and-selectors-1">Labels and Selectors</a></h3>
<p>All resources support standard Kubernetes labels and selectors:</p>
<pre><code class="language-yaml">metadata:
  labels:
    app: my-app
    environment: production
</code></pre>
<p>DNSZone uses label selectors to target Bind9Instances:</p>
<pre><code class="language-yaml">spec:
  instanceSelector:
    matchLabels:
      dns-role: primary
</code></pre>
<h3 id="status-conditions-2"><a class="header" href="#status-conditions-2">Status Conditions</a></h3>
<p>All resources implement standard status conditions:</p>
<ul>
<li><strong>Ready</strong>: Resource is ready for use</li>
<li><strong>Available</strong>: Resource is available and serving traffic</li>
<li><strong>Progressing</strong>: Resource is being reconciled</li>
<li><strong>Degraded</strong>: Resource is partially functional</li>
<li><strong>Failed</strong>: Resource reconciliation failed</li>
</ul>
<p>Example status:</p>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      lastTransitionTime: "2024-01-15T10:30:00Z"
      reason: ReconcileSuccess
      message: "Resource reconciled successfully"
</code></pre>
<h3 id="owner-references"><a class="header" href="#owner-references">Owner References</a></h3>
<p>Bindy automatically sets owner references for resource cleanup:</p>
<pre><code class="language-yaml">metadata:
  ownerReferences:
    - apiVersion: bindy.firestoned.io/v1alpha1
      kind: DNSZone
      name: example-zone
      uid: abc123
      controller: true
</code></pre>
<h2 id="api-versions"><a class="header" href="#api-versions">API Versions</a></h2>
<h3 id="v1alpha1-current"><a class="header" href="#v1alpha1-current">v1alpha1 (Current)</a></h3>
<p>Current development version. API may change between releases.</p>
<p><strong>Stability</strong>: Alpha - Breaking changes possible</p>
<p><strong>Deprecation Policy</strong>: None yet established</p>
<h3 id="future-versions"><a class="header" href="#future-versions">Future Versions</a></h3>
<ul>
<li><strong>v1beta1</strong>: Planned when API stabilizes</li>
<li><strong>v1</strong>: Planned for 1.0 release</li>
</ul>
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<h3 id="schema-validation"><a class="header" href="#schema-validation">Schema Validation</a></h3>
<p>All CRDs include OpenAPI v3 schema validation:</p>
<ul>
<li>Required fields enforced</li>
<li>Field types validated</li>
<li>Pattern matching for strings</li>
<li>Range validation for numbers</li>
</ul>
<h3 id="webhook-validation"><a class="header" href="#webhook-validation">Webhook Validation</a></h3>
<p>Planned for future releases:</p>
<ul>
<li>Cross-field validation</li>
<li>Business logic validation</li>
<li>Default value injection</li>
</ul>
<h2 id="api-conventions"><a class="header" href="#api-conventions">API Conventions</a></h2>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<ul>
<li>Use DNS-compatible names (lowercase, numbers, hyphens)</li>
<li>Maximum 253 characters for resource names</li>
<li>Maximum 63 characters for DNS labels</li>
</ul>
<h3 id="ttl-values"><a class="header" href="#ttl-values">TTL Values</a></h3>
<p>TTL (Time To Live) values in seconds:</p>
<ul>
<li>Minimum: 60 (1 minute)</li>
<li>Maximum: 86400 (24 hours)</li>
<li>Default: 3600 (1 hour)</li>
</ul>
<h3 id="ip-addresses"><a class="header" href="#ip-addresses">IP Addresses</a></h3>
<ul>
<li>IPv4: Dotted decimal notation (192.0.2.1)</li>
<li>IPv6: Colon-separated hexadecimal (2001:db8::1)</li>
<li>CIDR notation supported for ACLs (10.0.0.0/8)</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>See the <a href="reference/./examples.html">Examples</a> section for complete configuration examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bind9instance-specification"><a class="header" href="#bind9instance-specification">Bind9Instance Specification</a></h1>
<p>Complete specification for the Bind9Instance Custom Resource Definition.</p>
<h2 id="resource-definition"><a class="header" href="#resource-definition">Resource Definition</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: string
  namespace: string
  labels:
    key: value
spec:
  clusterRef: string          # References Bind9Cluster
  role: primary|secondary     # Server role
  replicas: integer
  version: string             # Optional, overrides cluster version
  image:                      # Optional, overrides cluster image
    image: string
    imagePullPolicy: string
    imagePullSecrets: [string]
  configMapRefs:              # Optional, custom config files
    namedConf: string
    namedConfOptions: string
  config:                     # Optional, overrides cluster config
    recursion: boolean
    allowQuery: [string]
    allowTransfer: [string]
    dnssec:
      enabled: boolean
      validation: boolean
    forwarders: [string]
    listenOn: [string]
    listenOnV6: [string]
  primaryServers: [string]    # Required for secondary role
</code></pre>
<h2 id="spec-fields"><a class="header" href="#spec-fields">Spec Fields</a></h2>
<h3 id="clusterref"><a class="header" href="#clusterref">clusterRef</a></h3>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Name of the Bind9Cluster that this instance belongs to. The instance inherits cluster-level configuration (version, shared config, TSIG keys, ACLs) from the referenced cluster.</p>
<pre><code class="language-yaml">spec:
  clusterRef: production-dns  # References Bind9Cluster named "production-dns"
</code></pre>
<p><strong>How It Works</strong>:</p>
<ul>
<li>Instance inherits <code>version</code> from cluster unless overridden</li>
<li>Instance inherits <code>config</code> from cluster unless overridden</li>
<li>Controller uses cluster TSIG keys for zone transfers</li>
<li>Instance can override cluster settings with its own spec</li>
</ul>
<h3 id="replicas-1"><a class="header" href="#replicas-1">replicas</a></h3>
<p><strong>Type</strong>: integer
<strong>Required</strong>: No
<strong>Default</strong>: 1</p>
<p>Number of BIND9 pod replicas to run.</p>
<pre><code class="language-yaml">spec:
  replicas: 3
</code></pre>
<p><strong>Best Practices</strong>:</p>
<ul>
<li>Use 2+ replicas for high availability</li>
<li>Use odd numbers (3, 5) for consensus-based systems</li>
<li>Consider resource constraints when scaling</li>
</ul>
<h3 id="version"><a class="header" href="#version">version</a></h3>
<p><strong>Type</strong>: string
<strong>Required</strong>: No
<strong>Default</strong>: "9.18"</p>
<p>BIND9 version to deploy. Must match available Docker image tags.</p>
<pre><code class="language-yaml">spec:
  version: "9.18"
</code></pre>
<p><strong>Supported Versions</strong>:</p>
<ul>
<li>"9.16" - Older stable</li>
<li>"9.18" - Current stable (recommended)</li>
<li>"9.19" - Development</li>
</ul>
<h3 id="image"><a class="header" href="#image">image</a></h3>
<p><strong>Type</strong>: object
<strong>Required</strong>: No</p>
<p>Container image configuration for the BIND9 instance. Overrides cluster-level image configuration.</p>
<pre><code class="language-yaml">spec:
  image:
    image: "my-registry.example.com/bind9:custom"
    imagePullPolicy: "Always"
    imagePullSecrets:
      - my-registry-secret
</code></pre>
<p><strong>How It Works</strong>:</p>
<ul>
<li>If not specified, inherits from <code>Bind9Cluster.spec.image</code></li>
<li>If cluster doesn't specify, uses default image <code>internetsystemsconsortium/bind9:9.18</code></li>
<li>Instance-level configuration takes precedence over cluster configuration</li>
</ul>
<h4 id="imageimage"><a class="header" href="#imageimage">image.image</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: No
<strong>Default</strong>: "internetsystemsconsortium/bind9:9.18"</p>
<p>Full container image reference including registry, repository, and tag.</p>
<pre><code class="language-yaml">spec:
  image:
    image: "docker.io/internetsystemsconsortium/bind9:9.18"
</code></pre>
<p><strong>Examples</strong>:</p>
<ul>
<li>Public registry: <code>"internetsystemsconsortium/bind9:9.18"</code></li>
<li>Private registry: <code>"my-registry.example.com/dns/bind9:custom"</code></li>
<li>With digest: <code>"bind9@sha256:abc123..."</code></li>
</ul>
<h4 id="imageimagepullpolicy"><a class="header" href="#imageimagepullpolicy">image.imagePullPolicy</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: No
<strong>Default</strong>: "IfNotPresent"</p>
<p>Kubernetes image pull policy.</p>
<pre><code class="language-yaml">spec:
  image:
    imagePullPolicy: "Always"
</code></pre>
<p><strong>Valid Values</strong>:</p>
<ul>
<li><code>"Always"</code> - Always pull the image</li>
<li><code>"IfNotPresent"</code> - Pull only if not present locally (recommended)</li>
<li><code>"Never"</code> - Never pull, use local image only</li>
</ul>
<h4 id="imageimagepullsecrets"><a class="header" href="#imageimagepullsecrets">image.imagePullSecrets</a></h4>
<p><strong>Type</strong>: array of strings
<strong>Required</strong>: No
<strong>Default</strong>: []</p>
<p>List of Kubernetes secret names for authenticating with private container registries.</p>
<pre><code class="language-yaml">spec:
  image:
    imagePullSecrets:
      - docker-registry-secret
      - gcr-pull-secret
</code></pre>
<p><strong>Setup</strong>:</p>
<ol>
<li>Create a docker-registry secret:
<pre><code class="language-bash">kubectl create secret docker-registry my-registry-secret \
  --docker-server=my-registry.example.com \
  --docker-username=user \
  --docker-password=pass \
  --docker-email=email@example.com
</code></pre>
</li>
<li>Reference the secret name in <code>imagePullSecrets</code></li>
</ol>
<h3 id="configmaprefs"><a class="header" href="#configmaprefs">configMapRefs</a></h3>
<p><strong>Type</strong>: object
<strong>Required</strong>: No</p>
<p>References to custom ConfigMaps containing BIND9 configuration files. Overrides cluster-level ConfigMap references.</p>
<pre><code class="language-yaml">spec:
  configMapRefs:
    namedConf: "my-custom-named-conf"
    namedConfOptions: "my-custom-options"
</code></pre>
<p><strong>How It Works</strong>:</p>
<ul>
<li>If specified, Bindy uses your custom ConfigMaps instead of auto-generating configuration</li>
<li>If not specified, Bindy auto-generates ConfigMaps from the <code>config</code> block</li>
<li>Instance-level references override cluster-level references</li>
<li>You can specify one or both ConfigMaps</li>
</ul>
<p><strong>Default Behavior</strong>:</p>
<ul>
<li>If <code>configMapRefs</code> is not set, Bindy creates a ConfigMap named <code>&lt;instance-name&gt;-config</code></li>
<li>Auto-generated ConfigMap includes both <code>named.conf</code> and <code>named.conf.options</code></li>
<li>Configuration is built from the <code>config</code> block in the spec</li>
</ul>
<h4 id="configmaprefsnamedconf"><a class="header" href="#configmaprefsnamedconf">configMapRefs.namedConf</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: No</p>
<p>Name of ConfigMap containing the main <code>named.conf</code> file.</p>
<pre><code class="language-yaml">spec:
  configMapRefs:
    namedConf: "my-named-conf"
</code></pre>
<p><strong>ConfigMap Format</strong>:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: my-named-conf
  namespace: dns-system
data:
  named.conf: |
    // Custom BIND9 configuration
    include "/etc/bind/named.conf.options";
    include "/etc/bind/zones/named.conf.zones";

    logging {
      channel custom_log {
        file "/var/log/named/queries.log" versions 3 size 5m;
        severity info;
      };
      category queries { custom_log; };
    };
</code></pre>
<p><strong>File Location</strong>: The ConfigMap data must have a key <code>named.conf</code> which will be mounted at <code>/etc/bind/named.conf</code></p>
<h4 id="configmaprefsnamedconfoptions"><a class="header" href="#configmaprefsnamedconfoptions">configMapRefs.namedConfOptions</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: No</p>
<p>Name of ConfigMap containing the <code>named.conf.options</code> file.</p>
<pre><code class="language-yaml">spec:
  configMapRefs:
    namedConfOptions: "my-options"
</code></pre>
<p><strong>ConfigMap Format</strong>:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: my-options
  namespace: dns-system
data:
  named.conf.options: |
    options {
      directory "/var/cache/bind";
      recursion no;
      allow-query { any; };
      dnssec-validation auto;
    };
</code></pre>
<p><strong>File Location</strong>: The ConfigMap data must have a key <code>named.conf.options</code> which will be mounted at <code>/etc/bind/named.conf.options</code></p>
<p><strong>Examples</strong>:</p>
<p>Using separate ConfigMaps for fine-grained control:</p>
<pre><code class="language-yaml">spec:
  configMapRefs:
    namedConf: "prod-named-conf"
    namedConfOptions: "prod-options"
</code></pre>
<p>Using only custom options, auto-generating main config:</p>
<pre><code class="language-yaml">spec:
  configMapRefs:
    namedConfOptions: "my-custom-options"
  # namedConf not specified - will be auto-generated
</code></pre>
<h3 id="config"><a class="header" href="#config">config</a></h3>
<p><strong>Type</strong>: object
<strong>Required</strong>: No</p>
<p>BIND9 configuration options.</p>
<h4 id="configrecursion"><a class="header" href="#configrecursion">config.recursion</a></h4>
<p><strong>Type</strong>: boolean
<strong>Required</strong>: No
<strong>Default</strong>: false</p>
<p>Enable recursive DNS queries. Should be <code>false</code> for authoritative servers.</p>
<pre><code class="language-yaml">spec:
  config:
    recursion: false
</code></pre>
<p><strong>Warning</strong>: Enabling recursion on public-facing authoritative servers is a security risk.</p>
<h4 id="configallowquery"><a class="header" href="#configallowquery">config.allowQuery</a></h4>
<p><strong>Type</strong>: array of strings
<strong>Required</strong>: No
<strong>Default</strong>: ["0.0.0.0/0"]</p>
<p>IP addresses or CIDR blocks allowed to query this server.</p>
<pre><code class="language-yaml">spec:
  config:
    allowQuery:
      - "0.0.0.0/0"        # Allow all (public DNS)
      - "10.0.0.0/8"       # Private network
      - "192.168.1.0/24"   # Specific subnet
</code></pre>
<h4 id="configallowtransfer"><a class="header" href="#configallowtransfer">config.allowTransfer</a></h4>
<p><strong>Type</strong>: array of strings
<strong>Required</strong>: No
<strong>Default</strong>: []</p>
<p>IP addresses or CIDR blocks allowed to perform zone transfers (AXFR/IXFR).</p>
<pre><code class="language-yaml">spec:
  config:
    allowTransfer:
      - "10.0.1.10"        # Specific secondary server
      - "10.0.1.11"        # Another secondary
</code></pre>
<p><strong>Security Note</strong>: Restrict zone transfers to trusted secondary servers only.</p>
<h4 id="configdnssec"><a class="header" href="#configdnssec">config.dnssec</a></h4>
<p><strong>Type</strong>: object
<strong>Required</strong>: No</p>
<p>DNSSEC configuration for signing zones and validating responses.</p>
<h5 id="configdnssecenabled"><a class="header" href="#configdnssecenabled">config.dnssec.enabled</a></h5>
<p><strong>Type</strong>: boolean
<strong>Required</strong>: No
<strong>Default</strong>: false</p>
<p>Enable DNSSEC signing for zones.</p>
<pre><code class="language-yaml">spec:
  config:
    dnssec:
      enabled: true
</code></pre>
<h5 id="configdnssecvalidation"><a class="header" href="#configdnssecvalidation">config.dnssec.validation</a></h5>
<p><strong>Type</strong>: boolean
<strong>Required</strong>: No
<strong>Default</strong>: false</p>
<p>Enable DNSSEC validation for recursive queries.</p>
<pre><code class="language-yaml">spec:
  config:
    dnssec:
      enabled: true
      validation: true
</code></pre>
<h4 id="configforwarders"><a class="header" href="#configforwarders">config.forwarders</a></h4>
<p><strong>Type</strong>: array of strings
<strong>Required</strong>: No
<strong>Default</strong>: []</p>
<p>DNS servers to forward queries to (for recursive mode).</p>
<pre><code class="language-yaml">spec:
  config:
    recursion: true
    forwarders:
      - "8.8.8.8"
      - "8.8.4.4"
</code></pre>
<h4 id="configlistenon"><a class="header" href="#configlistenon">config.listenOn</a></h4>
<p><strong>Type</strong>: array of strings
<strong>Required</strong>: No
<strong>Default</strong>: ["any"]</p>
<p>IPv4 addresses to listen on.</p>
<pre><code class="language-yaml">spec:
  config:
    listenOn:
      - "any"              # All IPv4 interfaces
      - "10.0.1.10"        # Specific IP
</code></pre>
<h4 id="configlistenonv6"><a class="header" href="#configlistenonv6">config.listenOnV6</a></h4>
<p><strong>Type</strong>: array of strings
<strong>Required</strong>: No
<strong>Default</strong>: ["any"]</p>
<p>IPv6 addresses to listen on.</p>
<pre><code class="language-yaml">spec:
  config:
    listenOnV6:
      - "any"              # All IPv6 interfaces
      - "2001:db8::1"      # Specific IPv6
</code></pre>
<h2 id="status-fields"><a class="header" href="#status-fields">Status Fields</a></h2>
<h3 id="conditions"><a class="header" href="#conditions">conditions</a></h3>
<p><strong>Type</strong>: array of objects</p>
<p>Standard Kubernetes conditions indicating resource state.</p>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      reason: ReconcileSuccess
      message: "Instance is ready"
      lastTransitionTime: "2024-01-15T10:30:00Z"
</code></pre>
<p><strong>Condition Types</strong>:</p>
<ul>
<li>Ready - Instance is ready for use</li>
<li>Available - Instance is serving DNS queries</li>
<li>Progressing - Instance is being reconciled</li>
<li>Degraded - Instance is partially functional</li>
<li>Failed - Instance reconciliation failed</li>
</ul>
<h3 id="observedgeneration"><a class="header" href="#observedgeneration">observedGeneration</a></h3>
<p><strong>Type</strong>: integer</p>
<p>The generation of the resource that was last reconciled.</p>
<pre><code class="language-yaml">status:
  observedGeneration: 5
</code></pre>
<h3 id="replicas-2"><a class="header" href="#replicas-2">replicas</a></h3>
<p><strong>Type</strong>: integer</p>
<p>Total number of replicas configured.</p>
<pre><code class="language-yaml">status:
  replicas: 3
</code></pre>
<h3 id="readyreplicas"><a class="header" href="#readyreplicas">readyReplicas</a></h3>
<p><strong>Type</strong>: integer</p>
<p>Number of replicas that are ready and serving traffic.</p>
<pre><code class="language-yaml">status:
  readyReplicas: 3
</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<h3 id="primary-dns-instance-1"><a class="header" href="#primary-dns-instance-1">Primary DNS Instance</a></h3>
<pre><code class="language-yaml"># First create the Bind9Cluster
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: production-dns
  namespace: dns-system
spec:
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.2.0/24"
    dnssec:
      enabled: true

---
# Then create the Bind9Instance referencing the cluster
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  namespace: dns-system
  labels:
    dns-role: primary
    environment: production
spec:
  clusterRef: production-dns  # References cluster above
  replicas: 2
  # Inherits version and config from cluster
</code></pre>
<h3 id="secondary-dns-instance-1"><a class="header" href="#secondary-dns-instance-1">Secondary DNS Instance</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-dns
  namespace: dns-system
  labels:
    dns-role: secondary
    environment: production
spec:
  clusterRef: production-dns  # References same cluster as primary
  replicas: 2
  # Override config for secondary role
  config:
    allowTransfer: []  # No zone transfers from secondary
    dnssec:
      enabled: false
      validation: true
</code></pre>
<h3 id="recursive-resolver"><a class="header" href="#recursive-resolver">Recursive Resolver</a></h3>
<pre><code class="language-yaml"># Separate cluster for resolvers
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: resolver-cluster
  namespace: dns-system
spec:
  version: "9.18"
  config:
    recursion: true
    allowQuery:
      - "10.0.0.0/8"  # Internal network only
    forwarders:
      - "8.8.8.8"
      - "1.1.1.1"
    dnssec:
      enabled: false
      validation: true

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: resolver
  namespace: dns-system
  labels:
    dns-role: resolver
spec:
  clusterRef: resolver-cluster
  replicas: 3
  # Inherits recursive config from cluster
</code></pre>
<h2 id="related-resources"><a class="header" href="#related-resources">Related Resources</a></h2>
<ul>
<li><a href="reference/./dnszone-spec.html">DNSZone Specification</a></li>
<li><a href="reference/./examples.html">Examples</a></li>
<li><a href="reference/../operations/configuration.html">Configuration Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dnszone-specification"><a class="header" href="#dnszone-specification">DNSZone Specification</a></h1>
<p>Complete specification for the DNSZone Custom Resource Definition.</p>
<h2 id="resource-definition-1"><a class="header" href="#resource-definition-1">Resource Definition</a></h2>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: string
  namespace: string
spec:
  zoneName: string
  clusterRef: string        # References Bind9Instance
  soaRecord:
    primaryNS: string
    adminEmail: string
    serial: integer
    refresh: integer
    retry: integer
    expire: integer
    negativeTTL: integer
  ttl: integer
</code></pre>
<h2 id="spec-fields-1"><a class="header" href="#spec-fields-1">Spec Fields</a></h2>
<h3 id="zonename"><a class="header" href="#zonename">zoneName</a></h3>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>The DNS zone name (domain name).</p>
<pre><code class="language-yaml">spec:
  zoneName: "example.com"
</code></pre>
<p><strong>Requirements</strong>:</p>
<ul>
<li>Must be a valid DNS domain name</li>
<li>Maximum 253 characters</li>
<li>Can be forward or reverse zone</li>
</ul>
<p><strong>Examples</strong>:</p>
<ul>
<li>"example.com"</li>
<li>"subdomain.example.com"</li>
<li>"1.0.10.in-addr.arpa" (reverse zone)</li>
</ul>
<h3 id="clusterref-1"><a class="header" href="#clusterref-1">clusterRef</a></h3>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Name of the Bind9Instance that will host this zone.</p>
<pre><code class="language-yaml">spec:
  clusterRef: primary-dns  # References Bind9Instance named "primary-dns"
</code></pre>
<p><strong>How It Works</strong>:</p>
<ul>
<li>Controller finds Bind9Instance with this name</li>
<li>Discovers BIND9 pods with label <code>instance=primary-dns</code></li>
<li>Loads RNDC key from Secret <code>primary-dns-rndc-key</code></li>
<li>Connects to <code>primary-dns.{namespace}.svc.cluster.local:953</code></li>
<li>Creates zone using <code>rndc addzone</code> command</li>
</ul>
<p><strong>Validation</strong>:</p>
<ul>
<li>Referenced Bind9Instance must exist in same namespace</li>
<li>Controller validates reference at admission time</li>
</ul>
<h3 id="soarecord"><a class="header" href="#soarecord">soaRecord</a></h3>
<p><strong>Type</strong>: object
<strong>Required</strong>: Yes</p>
<p>Start of Authority record defining zone parameters.</p>
<pre><code class="language-yaml">spec:
  soaRecord:
    primaryNS: "ns1.example.com."
    adminEmail: "admin.example.com."  # Note: @ replaced with .
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
</code></pre>
<h4 id="soarecordprimaryns"><a class="header" href="#soarecordprimaryns">soaRecord.primaryNS</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Primary nameserver for the zone.</p>
<pre><code class="language-yaml">soaRecord:
  primaryNS: "ns1.example.com."
</code></pre>
<p><strong>Requirements</strong>:</p>
<ul>
<li>Must be a fully qualified domain name (FQDN)</li>
<li>Must end with a dot (.)</li>
<li>Pattern: <code>^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\.$</code></li>
</ul>
<h4 id="soarecordadminemail"><a class="header" href="#soarecordadminemail">soaRecord.adminEmail</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Email address of zone administrator in DNS format.</p>
<pre><code class="language-yaml">soaRecord:
  adminEmail: "admin.example.com."  # Represents admin@example.com
</code></pre>
<p><strong>Format</strong>:</p>
<ul>
<li>Replace @ with . in email address</li>
<li>Must end with a dot (.)</li>
<li>Example: admin@example.com → admin.example.com.</li>
<li>Pattern: <code>^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\.$</code></li>
</ul>
<h4 id="soarecordserial"><a class="header" href="#soarecordserial">soaRecord.serial</a></h4>
<p><strong>Type</strong>: integer (64-bit)
<strong>Required</strong>: Yes
<strong>Range</strong>: 0 to 4,294,967,295</p>
<p>Zone serial number for change tracking.</p>
<pre><code class="language-yaml">soaRecord:
  serial: 2024010101
</code></pre>
<p><strong>Best Practices</strong>:</p>
<ul>
<li>Use format: YYYYMMDDnn (year, month, day, revision)</li>
<li>Increment on every change</li>
<li>Secondaries use this to detect updates</li>
</ul>
<p><strong>Examples</strong>:</p>
<ul>
<li>2024010101 - January 1, 2024, first revision</li>
<li>2024010102 - January 1, 2024, second revision</li>
</ul>
<h4 id="soarecordrefresh"><a class="header" href="#soarecordrefresh">soaRecord.refresh</a></h4>
<p><strong>Type</strong>: integer (32-bit)
<strong>Required</strong>: Yes
<strong>Range</strong>: 1 to 2,147,483,647</p>
<p>How often (in seconds) secondary servers should check for updates.</p>
<pre><code class="language-yaml">soaRecord:
  refresh: 3600  # 1 hour
</code></pre>
<p><strong>Typical Values</strong>:</p>
<ul>
<li>3600 (1 hour) - Standard</li>
<li>7200 (2 hours) - Less frequent updates</li>
<li>900 (15 minutes) - Frequent updates</li>
</ul>
<h4 id="soarecordretry"><a class="header" href="#soarecordretry">soaRecord.retry</a></h4>
<p><strong>Type</strong>: integer (32-bit)
<strong>Required</strong>: Yes
<strong>Range</strong>: 1 to 2,147,483,647</p>
<p>How long (in seconds) to wait before retrying a failed refresh.</p>
<pre><code class="language-yaml">soaRecord:
  retry: 600  # 10 minutes
</code></pre>
<p><strong>Best Practice</strong>: Should be less than refresh value</p>
<h4 id="soarecordexpire"><a class="header" href="#soarecordexpire">soaRecord.expire</a></h4>
<p><strong>Type</strong>: integer (32-bit)
<strong>Required</strong>: Yes
<strong>Range</strong>: 1 to 2,147,483,647</p>
<p>How long (in seconds) secondary servers should keep serving zone data after primary becomes unreachable.</p>
<pre><code class="language-yaml">soaRecord:
  expire: 604800  # 1 week
</code></pre>
<p><strong>Typical Values</strong>:</p>
<ul>
<li>604800 (1 week) - Standard</li>
<li>1209600 (2 weeks) - Extended</li>
<li>86400 (1 day) - Short-lived zones</li>
</ul>
<h4 id="soarecordnegativettl"><a class="header" href="#soarecordnegativettl">soaRecord.negativeTTL</a></h4>
<p><strong>Type</strong>: integer (32-bit)
<strong>Required</strong>: Yes
<strong>Range</strong>: 0 to 2,147,483,647</p>
<p>How long (in seconds) to cache negative responses (NXDOMAIN).</p>
<pre><code class="language-yaml">soaRecord:
  negativeTTL: 86400  # 24 hours
</code></pre>
<p><strong>Typical Values</strong>:</p>
<ul>
<li>86400 (24 hours) - Standard</li>
<li>3600 (1 hour) - Shorter caching</li>
<li>300 (5 minutes) - Very short for dynamic zones</li>
</ul>
<h3 id="ttl"><a class="header" href="#ttl">ttl</a></h3>
<p><strong>Type</strong>: integer (32-bit)
<strong>Required</strong>: No
<strong>Default</strong>: 3600
<strong>Range</strong>: 0 to 2,147,483,647</p>
<p>Default Time To Live for records in this zone (in seconds).</p>
<pre><code class="language-yaml">spec:
  ttl: 3600  # 1 hour
</code></pre>
<p><strong>Common Values</strong>:</p>
<ul>
<li>3600 (1 hour) - Standard</li>
<li>300 (5 minutes) - Frequently changing zones</li>
<li>86400 (24 hours) - Stable zones</li>
</ul>
<h2 id="status-fields-1"><a class="header" href="#status-fields-1">Status Fields</a></h2>
<h3 id="conditions-1"><a class="header" href="#conditions-1">conditions</a></h3>
<p><strong>Type</strong>: array of objects</p>
<p>Standard Kubernetes conditions.</p>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      reason: Synchronized
      message: "Zone created for cluster: primary-dns"
      lastTransitionTime: "2024-01-15T10:30:00Z"
</code></pre>
<p><strong>Condition Types</strong>:</p>
<ul>
<li><strong>Ready</strong> - Zone is created and serving</li>
<li><strong>Synced</strong> - Zone is synchronized with BIND9</li>
<li><strong>Failed</strong> - Zone creation or update failed</li>
</ul>
<h3 id="observedgeneration-1"><a class="header" href="#observedgeneration-1">observedGeneration</a></h3>
<p><strong>Type</strong>: integer</p>
<p>The generation last reconciled.</p>
<pre><code class="language-yaml">status:
  observedGeneration: 3
</code></pre>
<h3 id="recordcount"><a class="header" href="#recordcount">recordCount</a></h3>
<p><strong>Type</strong>: integer</p>
<p>Number of DNS records in this zone.</p>
<pre><code class="language-yaml">status:
  recordCount: 42
</code></pre>
<h2 id="complete-examples"><a class="header" href="#complete-examples">Complete Examples</a></h2>
<h3 id="simple-primary-zone"><a class="header" href="#simple-primary-zone">Simple Primary Zone</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: primary-dns
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin.example.com.
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
  ttl: 3600
</code></pre>
<h3 id="production-zone-with-custom-ttl-1"><a class="header" href="#production-zone-with-custom-ttl-1">Production Zone with Custom TTL</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: api-example-com
  namespace: dns-system
spec:
  zoneName: api.example.com
  clusterRef: production-dns
  ttl: 300  # 5 minute default TTL for faster updates
  soaRecord:
    primaryNS: ns1.api.example.com.
    adminEmail: ops.example.com.
    serial: 2024010101
    refresh: 1800   # Check every 30 minutes
    retry: 300      # Retry after 5 minutes
    expire: 604800
    negativeTTL: 300  # Short negative cache
</code></pre>
<h3 id="reverse-dns-zone"><a class="header" href="#reverse-dns-zone">Reverse DNS Zone</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: reverse-zone
  namespace: dns-system
spec:
  zoneName: 1.0.10.in-addr.arpa
  clusterRef: primary-dns
  soaRecord:
    primaryNS: ns1.example.com.
    adminEmail: admin.example.com.
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
  ttl: 3600
</code></pre>
<h3 id="multi-region-setup-1"><a class="header" href="#multi-region-setup-1">Multi-Region Setup</a></h3>
<pre><code class="language-yaml"># East Region Zone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-east
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: dns-east  # References east instance
  soaRecord:
    primaryNS: ns1.east.example.com.
    adminEmail: admin.example.com.
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400

---
# West Region Zone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-west
  namespace: dns-system
spec:
  zoneName: example.com
  clusterRef: dns-west  # References west instance
  soaRecord:
    primaryNS: ns1.west.example.com.
    adminEmail: admin.example.com.
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTTL: 86400
</code></pre>
<h2 id="zone-creation-flow-1"><a class="header" href="#zone-creation-flow-1">Zone Creation Flow</a></h2>
<p>When you create a DNSZone resource:</p>
<ol>
<li><strong>Admission</strong> - Kubernetes validates the resource schema</li>
<li><strong>Controller watches</strong> - Bindy controller detects the new zone</li>
<li><strong>Instance lookup</strong> - Finds Bind9Instance referenced by <code>clusterRef</code></li>
<li><strong>Pod discovery</strong> - Finds BIND9 pods with label <code>instance={clusterRef}</code></li>
<li><strong>RNDC key load</strong> - Retrieves Secret <code>{clusterRef}-rndc-key</code></li>
<li><strong>RNDC connection</strong> - Connects to <code>{clusterRef}.{namespace}.svc.cluster.local:953</code></li>
<li><strong>Zone creation</strong> - Executes <code>rndc addzone {zoneName} ...</code></li>
<li><strong>Status update</strong> - Updates DNSZone status to Ready</li>
</ol>
<h2 id="related-resources-1"><a class="header" href="#related-resources-1">Related Resources</a></h2>
<ul>
<li><a href="reference/./bind9instance-spec.html">Bind9Instance Specification</a></li>
<li><a href="reference/./record-specs.html">Record Specifications</a></li>
<li><a href="reference/../guide/creating-zones.html">Creating Zones Guide</a></li>
<li><a href="reference/../concepts/architecture-rndc.html">RNDC-Based Architecture</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dns-record-specifications"><a class="header" href="#dns-record-specifications">DNS Record Specifications</a></h1>
<p>Complete specifications for all DNS record types.</p>
<h2 id="common-fields-2"><a class="header" href="#common-fields-2">Common Fields</a></h2>
<p>All DNS record types share these common fields:</p>
<h3 id="zone"><a class="header" href="#zone">zone</a></h3>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Reference to the DNSZone resource name (not the zone domain name).</p>
<pre><code class="language-yaml">spec:
  zone: "example-com"  # Name of DNSZone resource
</code></pre>
<h3 id="name"><a class="header" href="#name">name</a></h3>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>The record name within the zone.</p>
<pre><code class="language-yaml">spec:
  name: "www"  # Creates www.example.com
  name: "@"    # Creates record at zone apex (example.com)
</code></pre>
<h3 id="ttl-1"><a class="header" href="#ttl-1">ttl</a></h3>
<p><strong>Type</strong>: integer
<strong>Required</strong>: No
<strong>Default</strong>: Inherited from zone</p>
<p>Time To Live in seconds.</p>
<pre><code class="language-yaml">spec:
  ttl: 300  # 5 minutes
</code></pre>
<hr />
<h2 id="a-record-ipv4-address"><a class="header" href="#a-record-ipv4-address">A Record (IPv4 Address)</a></h2>
<p>Maps hostnames to IPv4 addresses.</p>
<h3 id="resource-definition-2"><a class="header" href="#resource-definition-2">Resource Definition</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-example-com
  namespace: dns-system
spec:
  zone: "example-com"
  name: "www"
  ipv4Address: "192.0.2.1"
  ttl: 300
</code></pre>
<h3 id="fields"><a class="header" href="#fields">Fields</a></h3>
<h4 id="ipv4address"><a class="header" href="#ipv4address">ipv4Address</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>IPv4 address in dotted decimal notation.</p>
<pre><code class="language-yaml">spec:
  ipv4Address: "192.0.2.1"
</code></pre>
<h3 id="example-multiple-a-records-round-robin"><a class="header" href="#example-multiple-a-records-round-robin">Example: Multiple A Records (Round Robin)</a></h3>
<pre><code class="language-yaml">---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-example-com-1
spec:
  zone: "example-com"
  name: "www"
  ipv4Address: "192.0.2.1"
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-example-com-2
spec:
  zone: "example-com"
  name: "www"
  ipv4Address: "192.0.2.2"
</code></pre>
<hr />
<h2 id="aaaa-record-ipv6-address"><a class="header" href="#aaaa-record-ipv6-address">AAAA Record (IPv6 Address)</a></h2>
<p>Maps hostnames to IPv6 addresses.</p>
<h3 id="resource-definition-3"><a class="header" href="#resource-definition-3">Resource Definition</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: AAAARecord
metadata:
  name: www-example-com-v6
  namespace: dns-system
spec:
  zone: "example-com"
  name: "www"
  ipv6Address: "2001:db8::1"
  ttl: 300
</code></pre>
<h3 id="fields-1"><a class="header" href="#fields-1">Fields</a></h3>
<h4 id="ipv6address"><a class="header" href="#ipv6address">ipv6Address</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>IPv6 address in colon-separated hexadecimal notation.</p>
<pre><code class="language-yaml">spec:
  ipv6Address: "2001:db8::1"
</code></pre>
<p><strong>Formats</strong>:</p>
<ul>
<li>Full: "2001:0db8:0000:0000:0000:0000:0000:0001"</li>
<li>Compressed: "2001:db8::1"</li>
</ul>
<h3 id="example-dual-stack-ipv4--ipv6"><a class="header" href="#example-dual-stack-ipv4--ipv6">Example: Dual Stack (IPv4 + IPv6)</a></h3>
<pre><code class="language-yaml">---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-v4
spec:
  zone: "example-com"
  name: "www"
  ipv4Address: "192.0.2.1"
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: AAAARecord
metadata:
  name: www-v6
spec:
  zone: "example-com"
  name: "www"
  ipv6Address: "2001:db8::1"
</code></pre>
<hr />
<h2 id="cname-record-canonical-name"><a class="header" href="#cname-record-canonical-name">CNAME Record (Canonical Name)</a></h2>
<p>Creates an alias from one hostname to another.</p>
<h3 id="resource-definition-4"><a class="header" href="#resource-definition-4">Resource Definition</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: CNAMERecord
metadata:
  name: www-alias
  namespace: dns-system
spec:
  zone: "example-com"
  name: "www"
  target: "server.example.com."
  ttl: 3600
</code></pre>
<h3 id="fields-2"><a class="header" href="#fields-2">Fields</a></h3>
<h4 id="target"><a class="header" href="#target">target</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Target hostname (FQDN recommended).</p>
<pre><code class="language-yaml">spec:
  target: "server.example.com."
</code></pre>
<h3 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h3>
<ul>
<li>Cannot be created at zone apex (@)</li>
<li>Cannot coexist with other record types for same name</li>
<li>Target should be fully qualified (end with dot)</li>
</ul>
<h3 id="example-cdn-alias"><a class="header" href="#example-cdn-alias">Example: CDN Alias</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: CNAMERecord
metadata:
  name: cdn-alias
spec:
  zone: "example-com"
  name: "cdn"
  target: "d123456.cloudfront.net."
</code></pre>
<hr />
<h2 id="mx-record-mail-exchange"><a class="header" href="#mx-record-mail-exchange">MX Record (Mail Exchange)</a></h2>
<p>Specifies mail servers for the domain.</p>
<h3 id="resource-definition-5"><a class="header" href="#resource-definition-5">Resource Definition</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: MXRecord
metadata:
  name: mail-primary
  namespace: dns-system
spec:
  zone: "example-com"
  name: "@"
  priority: 10
  mailServer: "mail.example.com."
  ttl: 3600
</code></pre>
<h3 id="fields-3"><a class="header" href="#fields-3">Fields</a></h3>
<h4 id="priority"><a class="header" href="#priority">priority</a></h4>
<p><strong>Type</strong>: integer
<strong>Required</strong>: Yes</p>
<p>Priority (preference) value. Lower values are preferred.</p>
<pre><code class="language-yaml">spec:
  priority: 10  # Primary mail server
  priority: 20  # Backup mail server
</code></pre>
<h4 id="mailserver"><a class="header" href="#mailserver">mailServer</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Hostname of mail server (FQDN recommended).</p>
<pre><code class="language-yaml">spec:
  mailServer: "mail.example.com."
</code></pre>
<h3 id="example-primary-and-backup-mail-servers"><a class="header" href="#example-primary-and-backup-mail-servers">Example: Primary and Backup Mail Servers</a></h3>
<pre><code class="language-yaml">---
apiVersion: bindy.firestoned.io/v1alpha1
kind: MXRecord
metadata:
  name: mail-primary
spec:
  zone: "example-com"
  name: "@"
  priority: 10
  mailServer: "mail1.example.com."
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: MXRecord
metadata:
  name: mail-backup
spec:
  zone: "example-com"
  name: "@"
  priority: 20
  mailServer: "mail2.example.com."
</code></pre>
<hr />
<h2 id="txt-record-text"><a class="header" href="#txt-record-text">TXT Record (Text)</a></h2>
<p>Stores arbitrary text data, commonly used for verification and policies.</p>
<h3 id="resource-definition-6"><a class="header" href="#resource-definition-6">Resource Definition</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: spf-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "@"
  text:
    - "v=spf1 mx -all"
  ttl: 3600
</code></pre>
<h3 id="fields-4"><a class="header" href="#fields-4">Fields</a></h3>
<h4 id="text"><a class="header" href="#text">text</a></h4>
<p><strong>Type</strong>: array of strings
<strong>Required</strong>: Yes</p>
<p>Text values. Multiple strings are concatenated.</p>
<pre><code class="language-yaml">spec:
  text:
    - "v=spf1 mx -all"
</code></pre>
<h3 id="example-spf-dkim-and-dmarc"><a class="header" href="#example-spf-dkim-and-dmarc">Example: SPF, DKIM, and DMARC</a></h3>
<pre><code class="language-yaml">---
# SPF Record
apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: spf
spec:
  zone: "example-com"
  name: "@"
  text:
    - "v=spf1 mx include:_spf.google.com ~all"
---
# DKIM Record
apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: dkim
spec:
  zone: "example-com"
  name: "default._domainkey"
  text:
    - "v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC..."
---
# DMARC Record
apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: dmarc
spec:
  zone: "example-com"
  name: "_dmarc"
  text:
    - "v=DMARC1; p=quarantine; rua=mailto:dmarc@example.com"
</code></pre>
<hr />
<h2 id="ns-record-name-server"><a class="header" href="#ns-record-name-server">NS Record (Name Server)</a></h2>
<p>Delegates a subdomain to different nameservers.</p>
<h3 id="resource-definition-7"><a class="header" href="#resource-definition-7">Resource Definition</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: NSRecord
metadata:
  name: subdomain-delegation
  namespace: dns-system
spec:
  zone: "example-com"
  name: "subdomain"
  nameserver: "ns1.subdomain.example.com."
  ttl: 3600
</code></pre>
<h3 id="fields-5"><a class="header" href="#fields-5">Fields</a></h3>
<h4 id="nameserver"><a class="header" href="#nameserver">nameserver</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Nameserver hostname (FQDN recommended).</p>
<pre><code class="language-yaml">spec:
  nameserver: "ns1.subdomain.example.com."
</code></pre>
<h3 id="example-subdomain-delegation"><a class="header" href="#example-subdomain-delegation">Example: Subdomain Delegation</a></h3>
<pre><code class="language-yaml">---
apiVersion: bindy.firestoned.io/v1alpha1
kind: NSRecord
metadata:
  name: sub-ns1
spec:
  zone: "example-com"
  name: "subdomain"
  nameserver: "ns1.subdomain.example.com."
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: NSRecord
metadata:
  name: sub-ns2
spec:
  zone: "example-com"
  name: "subdomain"
  nameserver: "ns2.subdomain.example.com."
</code></pre>
<hr />
<h2 id="srv-record-service"><a class="header" href="#srv-record-service">SRV Record (Service)</a></h2>
<p>Specifies location of services.</p>
<h3 id="resource-definition-8"><a class="header" href="#resource-definition-8">Resource Definition</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: SRVRecord
metadata:
  name: sip-service
  namespace: dns-system
spec:
  zone: "example-com"
  name: "_sip._tcp"
  priority: 10
  weight: 60
  port: 5060
  target: "sip.example.com."
  ttl: 3600
</code></pre>
<h3 id="fields-6"><a class="header" href="#fields-6">Fields</a></h3>
<h4 id="priority-1"><a class="header" href="#priority-1">priority</a></h4>
<p><strong>Type</strong>: integer
<strong>Required</strong>: Yes</p>
<p>Priority for target selection. Lower values are preferred.</p>
<pre><code class="language-yaml">spec:
  priority: 10
</code></pre>
<h4 id="weight"><a class="header" href="#weight">weight</a></h4>
<p><strong>Type</strong>: integer
<strong>Required</strong>: Yes</p>
<p>Relative weight for same-priority targets.</p>
<pre><code class="language-yaml">spec:
  weight: 60  # 60% of traffic
  weight: 40  # 40% of traffic
</code></pre>
<h4 id="port"><a class="header" href="#port">port</a></h4>
<p><strong>Type</strong>: integer
<strong>Required</strong>: Yes</p>
<p>Port number where service is available.</p>
<pre><code class="language-yaml">spec:
  port: 5060
</code></pre>
<h4 id="target-1"><a class="header" href="#target-1">target</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Hostname providing the service.</p>
<pre><code class="language-yaml">spec:
  target: "sip.example.com."
</code></pre>
<h3 id="example-load-balanced-service"><a class="header" href="#example-load-balanced-service">Example: Load Balanced Service</a></h3>
<pre><code class="language-yaml">---
apiVersion: bindy.firestoned.io/v1alpha1
kind: SRVRecord
metadata:
  name: srv-primary
spec:
  zone: "example-com"
  name: "_service._tcp"
  priority: 10
  weight: 60
  port: 8080
  target: "server1.example.com."
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: SRVRecord
metadata:
  name: srv-secondary
spec:
  zone: "example-com"
  name: "_service._tcp"
  priority: 10
  weight: 40
  port: 8080
  target: "server2.example.com."
</code></pre>
<hr />
<h2 id="caa-record-certificate-authority-authorization"><a class="header" href="#caa-record-certificate-authority-authorization">CAA Record (Certificate Authority Authorization)</a></h2>
<p>Restricts which CAs can issue certificates for the domain.</p>
<h3 id="resource-definition-9"><a class="header" href="#resource-definition-9">Resource Definition</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: CAARecord
metadata:
  name: caa-letsencrypt
  namespace: dns-system
spec:
  zone: "example-com"
  name: "@"
  flags: 0
  tag: "issue"
  value: "letsencrypt.org"
  ttl: 3600
</code></pre>
<h3 id="fields-7"><a class="header" href="#fields-7">Fields</a></h3>
<h4 id="flags"><a class="header" href="#flags">flags</a></h4>
<p><strong>Type</strong>: integer
<strong>Required</strong>: Yes</p>
<p>Flags byte. Typically 0 (non-critical) or 128 (critical).</p>
<pre><code class="language-yaml">spec:
  flags: 0
</code></pre>
<h4 id="tag"><a class="header" href="#tag">tag</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Property tag.</p>
<p><strong>Valid Tags</strong>:</p>
<ul>
<li>"issue" - Authorize CA to issue certificates</li>
<li>"issuewild" - Authorize CA to issue wildcard certificates</li>
<li>"iodef" - URL for violation reports</li>
</ul>
<pre><code class="language-yaml">spec:
  tag: "issue"
</code></pre>
<h4 id="value"><a class="header" href="#value">value</a></h4>
<p><strong>Type</strong>: string
<strong>Required</strong>: Yes</p>
<p>Property value (CA domain or URL).</p>
<pre><code class="language-yaml">spec:
  value: "letsencrypt.org"
</code></pre>
<h3 id="example-multiple-caa-records"><a class="header" href="#example-multiple-caa-records">Example: Multiple CAA Records</a></h3>
<pre><code class="language-yaml">---
# Allow Let's Encrypt for regular certs
apiVersion: bindy.firestoned.io/v1alpha1
kind: CAARecord
metadata:
  name: caa-issue
spec:
  zone: "example-com"
  name: "@"
  flags: 0
  tag: "issue"
  value: "letsencrypt.org"
---
# Allow Let's Encrypt for wildcard certs
apiVersion: bindy.firestoned.io/v1alpha1
kind: CAARecord
metadata:
  name: caa-issuewild
spec:
  zone: "example-com"
  name: "@"
  flags: 0
  tag: "issuewild"
  value: "letsencrypt.org"
---
# Violation reporting
apiVersion: bindy.firestoned.io/v1alpha1
kind: CAARecord
metadata:
  name: caa-iodef
spec:
  zone: "example-com"
  name: "@"
  flags: 0
  tag: "iodef"
  value: "mailto:security@example.com"
</code></pre>
<hr />
<h2 id="related-resources-2"><a class="header" href="#related-resources-2">Related Resources</a></h2>
<ul>
<li><a href="reference/./api.html">API Reference</a></li>
<li><a href="reference/./dnszone-spec.html">DNSZone Specification</a></li>
<li><a href="reference/./examples.html">Examples</a></li>
<li><a href="reference/../guide/records-guide.html">DNS Records Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="status-conditions-3"><a class="header" href="#status-conditions-3">Status Conditions</a></h1>
<p>This document describes the standardized status conditions used across all Bindy CRDs.</p>
<h2 id="condition-types-1"><a class="header" href="#condition-types-1">Condition Types</a></h2>
<p>All Bindy custom resources (Bind9Instance, DNSZone, and all DNS record types) use the following standardized condition types:</p>
<h3 id="ready-1"><a class="header" href="#ready-1">Ready</a></h3>
<ul>
<li><strong>Description</strong>: Indicates whether the resource is fully operational and ready to serve its intended purpose</li>
<li><strong>Common Use</strong>: Primary condition type used by all reconcilers</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource is ready and operational</li>
<li><code>False</code>: Resource is not ready (error or in progress)</li>
<li><code>Unknown</code>: Status cannot be determined</li>
</ul>
</li>
</ul>
<h3 id="available-1"><a class="header" href="#available-1">Available</a></h3>
<ul>
<li><strong>Description</strong>: Indicates whether the resource is available for use</li>
<li><strong>Common Use</strong>: Used to distinguish between "ready" and "available" when resources may be ready but not yet serving traffic</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource is available</li>
<li><code>False</code>: Resource is not available</li>
<li><code>Unknown</code>: Availability cannot be determined</li>
</ul>
</li>
</ul>
<h3 id="progressing-1"><a class="header" href="#progressing-1">Progressing</a></h3>
<ul>
<li><strong>Description</strong>: Indicates whether the resource is currently being worked on</li>
<li><strong>Common Use</strong>: During initial creation or updates</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource is being created or updated</li>
<li><code>False</code>: Resource is not currently progressing</li>
<li><code>Unknown</code>: Progress status cannot be determined</li>
</ul>
</li>
</ul>
<h3 id="degraded-1"><a class="header" href="#degraded-1">Degraded</a></h3>
<ul>
<li><strong>Description</strong>: Indicates that the resource is functioning but in a degraded state</li>
<li><strong>Common Use</strong>: When some replicas are down but service continues, or when non-critical features are unavailable</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource is degraded</li>
<li><code>False</code>: Resource is not degraded</li>
<li><code>Unknown</code>: Degradation status cannot be determined</li>
</ul>
</li>
</ul>
<h3 id="failed-1"><a class="header" href="#failed-1">Failed</a></h3>
<ul>
<li><strong>Description</strong>: Indicates that the resource has failed and cannot fulfill its purpose</li>
<li><strong>Common Use</strong>: Permanent failures that require intervention</li>
<li><strong>Status Values</strong>:
<ul>
<li><code>True</code>: Resource has failed</li>
<li><code>False</code>: Resource has not failed</li>
<li><code>Unknown</code>: Failure status cannot be determined</li>
</ul>
</li>
</ul>
<h2 id="condition-structure-1"><a class="header" href="#condition-structure-1">Condition Structure</a></h2>
<p>All conditions follow this structure:</p>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready              # One of: Ready, Available, Progressing, Degraded, Failed
      status: "True"           # One of: "True", "False", "Unknown"
      reason: Ready            # Machine-readable reason (typically same as type)
      message: "Bind9Instance configured with 2 replicas"  # Human-readable message
      lastTransitionTime: "2024-11-26T10:00:00Z"          # RFC3339 timestamp
  observedGeneration: 1        # Generation last observed by controller
  # Resource-specific fields (replicas, recordCount, etc.)
</code></pre>
<h2 id="current-usage-1"><a class="header" href="#current-usage-1">Current Usage</a></h2>
<h3 id="bind9instance-5"><a class="header" href="#bind9instance-5">Bind9Instance</a></h3>
<ul>
<li>Uses <code>Ready</code> condition type</li>
<li>Status <code>True</code> when Deployment, Service, and ConfigMap are successfully created</li>
<li>Status <code>False</code> when resource creation fails</li>
<li>Additional status fields:
<ul>
<li><code>replicas</code>: Total number of replicas</li>
<li><code>readyReplicas</code>: Number of ready replicas</li>
</ul>
</li>
</ul>
<h3 id="dnszone-4"><a class="header" href="#dnszone-4">DNSZone</a></h3>
<ul>
<li>Uses <code>Ready</code> condition type</li>
<li>Status <code>True</code> when zone file is created and instances are matched</li>
<li>Status <code>False</code> when zone creation fails</li>
<li>Additional status fields:
<ul>
<li><code>recordCount</code>: Number of records in the zone</li>
<li><code>observedGeneration</code>: Last observed generation</li>
</ul>
</li>
</ul>
<h3 id="dns-records-a-aaaa-cname-mx-txt-ns-srv-caa-1"><a class="header" href="#dns-records-a-aaaa-cname-mx-txt-ns-srv-caa-1">DNS Records (A, AAAA, CNAME, MX, TXT, NS, SRV, CAA)</a></h3>
<ul>
<li>All use <code>Ready</code> condition type</li>
<li>Status <code>True</code> when record is successfully added to zone</li>
<li>Status <code>False</code> when record creation fails</li>
<li>Additional status fields:
<ul>
<li><code>observedGeneration</code>: Last observed generation</li>
</ul>
</li>
</ul>
<h2 id="best-practices-17"><a class="header" href="#best-practices-17">Best Practices</a></h2>
<ol>
<li><strong>Always set the condition type</strong>: Use one of the five standardized types</li>
<li><strong>Include timestamps</strong>: Set <code>lastTransitionTime</code> when condition status changes</li>
<li><strong>Provide clear messages</strong>: The <code>message</code> field should be human-readable and actionable</li>
<li><strong>Use appropriate reasons</strong>: The <code>reason</code> field should be machine-readable and consistent</li>
<li><strong>Update observedGeneration</strong>: Always update to match the resource's current generation</li>
<li><strong>Multiple conditions</strong>: Resources can have multiple conditions simultaneously (e.g., <code>Ready: True</code> and <code>Degraded: True</code>)</li>
</ol>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="successful-bind9instance-1"><a class="header" href="#successful-bind9instance-1">Successful Bind9Instance</a></h3>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "True"
      reason: Ready
      message: "Bind9Instance configured with 2 replicas"
      lastTransitionTime: "2024-11-26T10:00:00Z"
  observedGeneration: 1
  replicas: 2
  readyReplicas: 2
</code></pre>
<h3 id="failed-dnszone-1"><a class="header" href="#failed-dnszone-1">Failed DNSZone</a></h3>
<pre><code class="language-yaml">status:
  conditions:
    - type: Ready
      status: "False"
      reason: Failed
      message: "No Bind9Instances matched selector"
      lastTransitionTime: "2024-11-26T10:00:00Z"
  observedGeneration: 1
  recordCount: 0
</code></pre>
<h3 id="progressing-deployment-1"><a class="header" href="#progressing-deployment-1">Progressing Deployment</a></h3>
<pre><code class="language-yaml">status:
  conditions:
    - type: Progressing
      status: "True"
      reason: Progressing
      message: "Deployment is rolling out"
      lastTransitionTime: "2024-11-26T10:00:00Z"
    - type: Ready
      status: "False"
      reason: Progressing
      message: "Waiting for deployment to complete"
      lastTransitionTime: "2024-11-26T10:00:00Z"
  observedGeneration: 2
  replicas: 2
  readyReplicas: 1
</code></pre>
<h2 id="validation-2"><a class="header" href="#validation-2">Validation</a></h2>
<p>All condition types are enforced via CRD validation. Attempting to use a condition type not in the enum will result in a validation error:</p>
<pre><code class="language-bash">$ kubectl apply -f invalid-condition.yaml
Error from server (Invalid): error when creating "invalid-condition.yaml":
Bind9Instance.bindy.firestoned.io "test" is invalid:
status.conditions[0].type: Unsupported value: "CustomType":
supported values: "Ready", "Available", "Progressing", "Degraded", "Failed"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-examples-1"><a class="header" href="#configuration-examples-1">Configuration Examples</a></h1>
<p>Complete configuration examples for common Bindy deployment scenarios.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>This section provides ready-to-use YAML configurations for various deployment scenarios:</p>
<ul>
<li><a href="reference/./examples-simple.html">Simple Setup</a> - Single instance, single zone</li>
<li><a href="reference/./examples-production.html">Production Setup</a> - HA, monitoring, backups</li>
<li><a href="reference/./examples-multi-region.html">Multi-Region Setup</a> - Geographic distribution</li>
</ul>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<h3 id="minimal-configuration"><a class="header" href="#minimal-configuration">Minimal Configuration</a></h3>
<p>Minimal viable configuration for testing:</p>
<pre><code class="language-yaml"># Bind9Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: dns
  namespace: dns-system
  labels:
    dns-role: primary
spec:
  replicas: 1
---
# DNSZone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
  namespace: dns-system
spec:
  zoneName: "example.com"
  instanceSelector:
    matchLabels:
      dns-role: primary
  soaRecord:
    primaryNs: "ns1.example.com."
    adminEmail: "admin@example.com"
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTtl: 86400
---
# A Record
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www
  namespace: dns-system
spec:
  zone: "example-com"
  name: "www"
  ipv4Address: "192.0.2.1"
</code></pre>
<h3 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h3>
<h4 id="primarysecondary-setup"><a class="header" href="#primarysecondary-setup">Primary/Secondary Setup</a></h4>
<pre><code class="language-yaml"># Primary
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary
  labels:
    dns-role: primary
spec:
  replicas: 2
  config:
    allowTransfer:
      - "10.0.2.0/24"  # Secondary network
---
# Secondary
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary
  labels:
    dns-role: secondary
spec:
  replicas: 2
---
# Zone on Primary
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-primary
spec:
  zoneName: "example.com"
  zoneType: "primary"
  instanceSelector:
    matchLabels:
      dns-role: primary
  soaRecord:
    primaryNs: "ns1.example.com."
    adminEmail: "admin@example.com"
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTtl: 86400
---
# Zone on Secondary
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-secondary
spec:
  zoneName: "example.com"
  zoneType: "secondary"
  instanceSelector:
    matchLabels:
      dns-role: secondary
  secondaryConfig:
    primaryServers:
      - "10.0.1.10"
      - "10.0.1.11"
</code></pre>
<h4 id="dnssec-enabled"><a class="header" href="#dnssec-enabled">DNSSEC Enabled</a></h4>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: dnssec-instance
spec:
  replicas: 2
  config:
    dnssec:
      enabled: true
      validation: true
</code></pre>
<h4 id="custom-container-image"><a class="header" href="#custom-container-image">Custom Container Image</a></h4>
<p>Using a custom or private container image:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: custom-image-cluster
  namespace: dns-system
spec:
  # Default image for all instances in this cluster
  image:
    image: "my-registry.example.com/bind9:custom-9.18"
    imagePullPolicy: "Always"
    imagePullSecrets:
      - my-registry-secret
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: custom-dns
  namespace: dns-system
spec:
  clusterRef: custom-image-cluster
  replicas: 2
  # Instance inherits custom image from cluster
</code></pre>
<h4 id="instance-specific-custom-image"><a class="header" href="#instance-specific-custom-image">Instance-Specific Custom Image</a></h4>
<p>Override cluster image for specific instance:</p>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: prod-cluster
  namespace: dns-system
spec:
  image:
    image: "internetsystemsconsortium/bind9:9.18"
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: canary-dns
  namespace: dns-system
spec:
  clusterRef: prod-cluster
  replicas: 1
  # Override cluster image for canary testing
  image:
    image: "internetsystemsconsortium/bind9:9.19"
    imagePullPolicy: "Always"
</code></pre>
<h4 id="custom-configuration-files-1"><a class="header" href="#custom-configuration-files-1">Custom Configuration Files</a></h4>
<p>Using custom ConfigMaps for BIND9 configuration:</p>
<pre><code class="language-yaml"># Create custom ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-custom-named-conf
  namespace: dns-system
data:
  named.conf: |
    // Custom BIND9 configuration
    include "/etc/bind/named.conf.options";
    include "/etc/bind/zones/named.conf.zones";

    logging {
      channel query_log {
        file "/var/log/named/queries.log" versions 5 size 10m;
        severity info;
        print-time yes;
        print-category yes;
      };
      category queries { query_log; };
      category lame-servers { null; };
    };
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-custom-options
  namespace: dns-system
data:
  named.conf.options: |
    options {
      directory "/var/cache/bind";
      recursion no;
      allow-query { any; };
      allow-transfer { 10.0.2.0/24; };
      dnssec-validation auto;
      listen-on { any; };
      listen-on-v6 { any; };
      max-cache-size 256M;
      max-cache-ttl 3600;
    };
---
# Reference custom ConfigMaps
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: custom-config-dns
  namespace: dns-system
spec:
  replicas: 2
  configMapRefs:
    namedConf: "my-custom-named-conf"
    namedConfOptions: "my-custom-options"
</code></pre>
<h4 id="cluster-level-custom-configmaps"><a class="header" href="#cluster-level-custom-configmaps">Cluster-Level Custom ConfigMaps</a></h4>
<p>Share custom configuration across all instances:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: shared-options
  namespace: dns-system
data:
  named.conf.options: |
    options {
      directory "/var/cache/bind";
      recursion no;
      allow-query { any; };
      dnssec-validation auto;
    };
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Cluster
metadata:
  name: shared-config-cluster
  namespace: dns-system
spec:
  configMapRefs:
    namedConfOptions: "shared-options"
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: instance-1
  namespace: dns-system
spec:
  clusterRef: shared-config-cluster
  replicas: 2
  # Inherits configMapRefs from cluster
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: instance-2
  namespace: dns-system
spec:
  clusterRef: shared-config-cluster
  replicas: 2
  # Also inherits same configMapRefs from cluster
</code></pre>
<h4 id="split-horizon-dns"><a class="header" href="#split-horizon-dns">Split Horizon DNS</a></h4>
<pre><code class="language-yaml"># Internal DNS
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: internal-dns
  labels:
    dns-view: internal
spec:
  config:
    allowQuery:
      - "10.0.0.0/8"
---
# External DNS
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: external-dns
  labels:
    dns-view: external
spec:
  config:
    allowQuery:
      - "0.0.0.0/0"
</code></pre>
<h2 id="resource-organization"><a class="header" href="#resource-organization">Resource Organization</a></h2>
<h3 id="namespace-structure"><a class="header" href="#namespace-structure">Namespace Structure</a></h3>
<p><strong>Recommended namespace organization</strong>:</p>
<pre><code class="language-yaml"># Separate namespaces by environment
dns-system-prod      # Production DNS
dns-system-staging   # Staging DNS
dns-system-dev       # Development DNS
</code></pre>
<h3 id="label-strategy"><a class="header" href="#label-strategy">Label Strategy</a></h3>
<p><strong>Recommended labels</strong>:</p>
<pre><code class="language-yaml">metadata:
  labels:
    # Core labels
    app.kubernetes.io/name: bindy
    app.kubernetes.io/component: dns-server
    app.kubernetes.io/part-of: dns-infrastructure

    # Custom labels
    dns-role: primary              # primary, secondary, resolver
    environment: production         # production, staging, dev
    region: us-east-1              # Geographic region
    zone-type: authoritative       # authoritative, recursive
</code></pre>
<h3 id="naming-conventions-1"><a class="header" href="#naming-conventions-1">Naming Conventions</a></h3>
<p><strong>Recommended naming</strong>:</p>
<pre><code class="language-yaml"># Bind9Instance: &lt;role&gt;-&lt;region&gt;
name: primary-us-east-1

# DNSZone: &lt;domain-with-dashes&gt;
name: example-com

# Records: &lt;name&gt;-&lt;type&gt;-&lt;identifier&gt;
name: www-a-record
name: mail-mx-primary
</code></pre>
<h2 id="testing-configurations"><a class="header" href="#testing-configurations">Testing Configurations</a></h2>
<h3 id="local-development-kindminikube"><a class="header" href="#local-development-kindminikube">Local Development (kind/minikube)</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: dev-dns
  namespace: dns-system
spec:
  replicas: 1
  config:
    recursion: true
    forwarders:
      - "8.8.8.8"
    allowQuery:
      - "0.0.0.0/0"
</code></pre>
<h3 id="cicd-testing"><a class="header" href="#cicd-testing">CI/CD Testing</a></h3>
<pre><code class="language-yaml">apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: ci-dns
  namespace: ci-testing
  labels:
    ci-test: "true"
spec:
  replicas: 1
  config:
    recursion: false
    allowQuery:
      - "10.0.0.0/8"
</code></pre>
<h2 id="troubleshooting-examples"><a class="header" href="#troubleshooting-examples">Troubleshooting Examples</a></h2>
<h3 id="debug-configuration"><a class="header" href="#debug-configuration">Debug Configuration</a></h3>
<p>Enable verbose logging:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: bindy-config
data:
  RUST_LOG: "debug"
  RECONCILE_INTERVAL: "60"
</code></pre>
<h3 id="dry-run-testing"><a class="header" href="#dry-run-testing">Dry Run Testing</a></h3>
<p>Test configuration without applying:</p>
<pre><code class="language-bash">kubectl apply --dry-run=client -f dns-config.yaml
kubectl apply --dry-run=server -f dns-config.yaml
</code></pre>
<h3 id="validation-3"><a class="header" href="#validation-3">Validation</a></h3>
<p>Validate resources:</p>
<pre><code class="language-bash"># Check instance status
kubectl get bind9instances -A

# Check zone status
kubectl get dnszones -A

# Check all DNS records
kubectl get arecords,aaaarecords,cnamerecords,mxrecords,txtrecords -A
</code></pre>
<h2 id="complete-examples-1"><a class="header" href="#complete-examples-1">Complete Examples</a></h2>
<p>For complete, production-ready configurations see:</p>
<ul>
<li><a href="reference/./examples-simple.html">Simple Setup</a> - Complete single-instance setup</li>
<li><a href="reference/./examples-production.html">Production Setup</a> - Full production configuration with HA</li>
<li><a href="reference/./examples-multi-region.html">Multi-Region Setup</a> - Multi-region deployment</li>
</ul>
<h2 id="related-resources-3"><a class="header" href="#related-resources-3">Related Resources</a></h2>
<ul>
<li><a href="reference/./api.html">API Reference</a></li>
<li><a href="reference/./bind9instance-spec.html">Bind9Instance Specification</a></li>
<li><a href="reference/./dnszone-spec.html">DNSZone Specification</a></li>
<li><a href="reference/./record-specs.html">Record Specifications</a></li>
<li><a href="reference/../installation/quickstart.html">Quick Start Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-setup-example"><a class="header" href="#simple-setup-example">Simple Setup Example</a></h1>
<p>Complete configuration for a basic single-instance DNS setup.</p>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>This example demonstrates:</p>
<ul>
<li>Single Bind9Instance</li>
<li>One DNS zone (example.com)</li>
<li>Common DNS records (A, AAAA, CNAME, MX, TXT)</li>
<li>Suitable for testing and development</li>
</ul>
<h2 id="prerequisites-6"><a class="header" href="#prerequisites-6">Prerequisites</a></h2>
<ul>
<li>Kubernetes cluster (kind, minikube, or cloud)</li>
<li>kubectl configured</li>
<li>Bindy operator installed</li>
</ul>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<h3 id="complete-yaml"><a class="header" href="#complete-yaml">Complete YAML</a></h3>
<p>Save as <code>simple-dns.yaml</code>:</p>
<pre><code class="language-yaml">---
# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: dns-system

---
# Bind9Instance - Single DNS Server
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: simple-dns
  namespace: dns-system
  labels:
    app: bindy
    dns-role: primary
    environment: development
spec:
  replicas: 1
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer: []
    listenOn:
      - "any"
    listenOnV6:
      - "any"

---
# DNSZone - example.com
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com
  namespace: dns-system
spec:
  zoneName: "example.com"
  zoneType: "primary"
  instanceSelector:
    matchLabels:
      dns-role: primary
  soaRecord:
    primaryNs: "ns1.example.com."
    adminEmail: "admin@example.com"
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTtl: 86400
  ttl: 3600

---
# A Record - Nameserver
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: ns1-a-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "ns1"
  ipv4Address: "192.0.2.1"
  ttl: 3600

---
# A Record - Web Server
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-a-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "www"
  ipv4Address: "192.0.2.10"
  ttl: 300

---
# AAAA Record - Web Server (IPv6)
apiVersion: bindy.firestoned.io/v1alpha1
kind: AAAARecord
metadata:
  name: www-aaaa-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "www"
  ipv6Address: "2001:db8::10"
  ttl: 300

---
# A Record - Mail Server
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: mail-a-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "mail"
  ipv4Address: "192.0.2.20"
  ttl: 3600

---
# MX Record - Mail Exchange
apiVersion: bindy.firestoned.io/v1alpha1
kind: MXRecord
metadata:
  name: mx-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "@"
  priority: 10
  mailServer: "mail.example.com."
  ttl: 3600

---
# TXT Record - SPF
apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: spf-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "@"
  text:
    - "v=spf1 mx -all"
  ttl: 3600

---
# TXT Record - DMARC
apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: dmarc-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "_dmarc"
  text:
    - "v=DMARC1; p=none; rua=mailto:dmarc@example.com"
  ttl: 3600

---
# CNAME Record - API Alias
apiVersion: bindy.firestoned.io/v1alpha1
kind: CNAMERecord
metadata:
  name: api-cname-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "api"
  target: "www.example.com."
  ttl: 3600
</code></pre>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<h3 id="1-install-crds"><a class="header" href="#1-install-crds">1. Install CRDs</a></h3>
<pre><code class="language-bash">kubectl apply -k deploy/crds/
</code></pre>
<h3 id="2-deploy-bindy-operator"><a class="header" href="#2-deploy-bindy-operator">2. Deploy Bindy Operator</a></h3>
<pre><code class="language-bash">kubectl apply -f deploy/operator.yaml
</code></pre>
<h3 id="3-apply-configuration"><a class="header" href="#3-apply-configuration">3. Apply Configuration</a></h3>
<pre><code class="language-bash">kubectl apply -f simple-dns.yaml
</code></pre>
<h3 id="4-verify-deployment"><a class="header" href="#4-verify-deployment">4. Verify Deployment</a></h3>
<pre><code class="language-bash"># Check Bind9Instance
kubectl get bind9instances -n dns-system
kubectl describe bind9instance simple-dns -n dns-system

# Check DNSZone
kubectl get dnszones -n dns-system
kubectl describe dnszone example-com -n dns-system

# Check DNS Records
kubectl get arecords,aaaarecords,cnamerecords,mxrecords,txtrecords -n dns-system

# Check pods
kubectl get pods -n dns-system

# Check logs
kubectl logs -n dns-system -l app=bindy
</code></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<h3 id="dns-queries"><a class="header" href="#dns-queries">DNS Queries</a></h3>
<p>Get the DNS service IP:</p>
<pre><code class="language-bash">DNS_IP=$(kubectl get svc -n dns-system simple-dns -o jsonpath='{.spec.clusterIP}')
</code></pre>
<p>Test DNS resolution:</p>
<pre><code class="language-bash"># A record
dig @${DNS_IP} www.example.com A

# AAAA record
dig @${DNS_IP} www.example.com AAAA

# MX record
dig @${DNS_IP} example.com MX

# TXT record
dig @${DNS_IP} example.com TXT

# CNAME record
dig @${DNS_IP} api.example.com CNAME
</code></pre>
<p>Expected responses:</p>
<pre><code>; www.example.com A
www.example.com.    300    IN    A    192.0.2.10

; www.example.com AAAA
www.example.com.    300    IN    AAAA    2001:db8::10

; example.com MX
example.com.        3600   IN    MX    10 mail.example.com.

; example.com TXT
example.com.        3600   IN    TXT   "v=spf1 mx -all"

; api.example.com CNAME
api.example.com.    3600   IN    CNAME www.example.com.
</code></pre>
<h3 id="port-forward-for-external-testing"><a class="header" href="#port-forward-for-external-testing">Port Forward for External Testing</a></h3>
<pre><code class="language-bash"># Forward DNS port to localhost
kubectl port-forward -n dns-system svc/simple-dns 5353:53

# Test from local machine
dig @localhost -p 5353 www.example.com
</code></pre>
<h2 id="monitoring-1"><a class="header" href="#monitoring-1">Monitoring</a></h2>
<h3 id="check-status"><a class="header" href="#check-status">Check Status</a></h3>
<pre><code class="language-bash"># Instance status
kubectl get bind9instance simple-dns -n dns-system -o yaml | grep -A 10 status

# Zone status
kubectl get dnszone example-com -n dns-system -o yaml | grep -A 10 status

# Record status
kubectl get arecord www-a-record -n dns-system -o yaml | grep -A 10 status
</code></pre>
<h3 id="view-logs"><a class="header" href="#view-logs">View Logs</a></h3>
<pre><code class="language-bash"># Controller logs
kubectl logs -n dns-system deployment/bindy

# BIND9 logs
kubectl logs -n dns-system -l app=bindy,dns-role=primary
</code></pre>
<h2 id="updating-configuration"><a class="header" href="#updating-configuration">Updating Configuration</a></h2>
<h3 id="add-new-record"><a class="header" href="#add-new-record">Add New Record</a></h3>
<pre><code class="language-bash">cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: app-a-record
  namespace: dns-system
spec:
  zone: "example-com"
  name: "app"
  ipv4Address: "192.0.2.30"
  ttl: 300
EOF
</code></pre>
<h3 id="update-soa-serial"><a class="header" href="#update-soa-serial">Update SOA Serial</a></h3>
<pre><code class="language-bash">kubectl edit dnszone example-com -n dns-system

# Update serial field:
# serial: 2024010102
</code></pre>
<h3 id="scale-instance"><a class="header" href="#scale-instance">Scale Instance</a></h3>
<pre><code class="language-bash">kubectl patch bind9instance simple-dns -n dns-system \
  --type merge \
  --patch '{"spec":{"replicas":2}}'
</code></pre>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<h3 id="remove-all-resources"><a class="header" href="#remove-all-resources">Remove All Resources</a></h3>
<pre><code class="language-bash">kubectl delete -f simple-dns.yaml
</code></pre>
<h3 id="remove-namespace"><a class="header" href="#remove-namespace">Remove Namespace</a></h3>
<pre><code class="language-bash">kubectl delete namespace dns-system
</code></pre>
<h2 id="next-steps-42"><a class="header" href="#next-steps-42">Next Steps</a></h2>
<ul>
<li><a href="reference/./examples-production.html">Production Setup</a> - Add HA and monitoring</li>
<li><a href="reference/./examples-multi-region.html">Multi-Region Setup</a> - Geographic distribution</li>
<li><a href="reference/../operations/monitoring.html">Operations Guide</a> - Monitoring and troubleshooting</li>
</ul>
<h2 id="troubleshooting-9"><a class="header" href="#troubleshooting-9">Troubleshooting</a></h2>
<h3 id="pods-not-starting-1"><a class="header" href="#pods-not-starting-1">Pods Not Starting</a></h3>
<pre><code class="language-bash"># Check pod events
kubectl describe pod -n dns-system -l app=bindy

# Check controller logs
kubectl logs -n dns-system deployment/bindy
</code></pre>
<h3 id="dns-not-resolving"><a class="header" href="#dns-not-resolving">DNS Not Resolving</a></h3>
<pre><code class="language-bash"># Check zone status
kubectl get dnszone example-com -n dns-system -o yaml

# Check BIND9 logs
kubectl logs -n dns-system -l app=bindy,dns-role=primary

# Verify zone file
kubectl exec -n dns-system -it &lt;pod-name&gt; -- cat /var/lib/bind/zones/example.com.zone
</code></pre>
<h3 id="record-not-appearing"><a class="header" href="#record-not-appearing">Record Not Appearing</a></h3>
<pre><code class="language-bash"># Check record status
kubectl get arecord www-a-record -n dns-system -o yaml

# Check zone record count
kubectl get dnszone example-com -n dns-system -o jsonpath='{.status.recordCount}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="production-setup-example"><a class="header" href="#production-setup-example">Production Setup Example</a></h1>
<p>Production-ready configuration with high availability, monitoring, and security.</p>
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<p>This example demonstrates:</p>
<ul>
<li>Primary/Secondary HA setup</li>
<li>Multiple replicas with pod anti-affinity</li>
<li>Resource limits and requests</li>
<li>PodDisruptionBudgets</li>
<li>DNSSEC enabled</li>
<li>Monitoring and logging</li>
<li>Production-grade security</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                      Production DNS                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Primary Instances (2 replicas)                            │
│   ┌──────────────┐  ┌──────────────┐                       │
│   │   Primary-1  │  │   Primary-2  │                       │
│   │  (us-east-1a)│  │  (us-east-1b)│                       │
│   └──────┬───────┘  └──────┬───────┘                       │
│          │                  │                               │
│          └──────────┬───────┘                               │
│                     │ Zone Transfer (AXFR/IXFR)            │
│          ┌──────────┴───────┐                               │
│          │                  │                               │
│   ┌──────▼───────┐  ┌──────▼───────┐                       │
│   │ Secondary-1  │  │ Secondary-2  │                       │
│   │ (us-west-2a) │  │ (us-west-2b) │                       │
│   └──────────────┘  └──────────────┘                       │
│                                                              │
│   Secondary Instances (2 replicas)                          │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="complete-configuration"><a class="header" href="#complete-configuration">Complete Configuration</a></h2>
<p>Save as <code>production-dns.yaml</code>:</p>
<pre><code class="language-yaml">---
# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: dns-system-prod
  labels:
    environment: production

---
# ConfigMap for Controller Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: bindy-config
  namespace: dns-system-prod
data:
  RUST_LOG: "info"
  RECONCILE_INTERVAL: "300"

---
# Primary Bind9Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-dns
  namespace: dns-system-prod
  labels:
    app: bindy
    dns-role: primary
    environment: production
    component: dns-server
spec:
  replicas: 2
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.0.2.0/24"  # Secondary instance subnet
    dnssec:
      enabled: true
      validation: false
    listenOn:
      - "any"
    listenOnV6:
      - "any"

---
# Secondary Bind9Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-dns
  namespace: dns-system-prod
  labels:
    app: bindy
    dns-role: secondary
    environment: production
    component: dns-server
spec:
  replicas: 2
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    dnssec:
      enabled: false
      validation: true
    listenOn:
      - "any"
    listenOnV6:
      - "any"

---
# PodDisruptionBudget for Primary
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: primary-dns-pdb
  namespace: dns-system-prod
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: bindy
      dns-role: primary

---
# PodDisruptionBudget for Secondary
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: secondary-dns-pdb
  namespace: dns-system-prod
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: bindy
      dns-role: secondary

---
# DNSZone - Primary
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-primary
  namespace: dns-system-prod
spec:
  zoneName: "example.com"
  zoneType: "primary"
  instanceSelector:
    matchLabels:
      dns-role: primary
  soaRecord:
    primaryNs: "ns1.example.com."
    adminEmail: "dns-admin@example.com"
    serial: 2024010101
    refresh: 900       # 15 minutes - production refresh
    retry: 300         # 5 minutes
    expire: 604800     # 1 week
    negativeTtl: 300   # 5 minutes
  ttl: 300  # 5 minutes default TTL

---
# DNSZone - Secondary
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-secondary
  namespace: dns-system-prod
spec:
  zoneName: "example.com"
  zoneType: "secondary"
  instanceSelector:
    matchLabels:
      dns-role: secondary
  secondaryConfig:
    primaryServers:
      - "10.0.1.10"
      - "10.0.1.11"
  ttl: 300

---
# Production DNS Records
# Nameservers
---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: ns1-primary
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "ns1"
  ipv4Address: "192.0.2.1"
  ttl: 86400  # 24 hours for NS records

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: ns2-secondary
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "ns2"
  ipv4Address: "192.0.2.2"
  ttl: 86400

---
# Load Balanced Web Servers (Round Robin)
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-lb-1
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "www"
  ipv4Address: "192.0.2.10"
  ttl: 60  # 1 minute for load balanced IPs

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-lb-2
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "www"
  ipv4Address: "192.0.2.11"
  ttl: 60

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-lb-3
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "www"
  ipv4Address: "192.0.2.12"
  ttl: 60

---
# Dual Stack for www
apiVersion: bindy.firestoned.io/v1alpha1
kind: AAAARecord
metadata:
  name: www-v6-1
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "www"
  ipv6Address: "2001:db8::10"
  ttl: 60

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: AAAARecord
metadata:
  name: www-v6-2
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "www"
  ipv6Address: "2001:db8::11"
  ttl: 60

---
# Mail Infrastructure
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: mail1
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "mail1"
  ipv4Address: "192.0.2.20"
  ttl: 3600

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: mail2
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "mail2"
  ipv4Address: "192.0.2.21"
  ttl: 3600

---
# MX Records - Primary and Backup
apiVersion: bindy.firestoned.io/v1alpha1
kind: MXRecord
metadata:
  name: mx-primary
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "@"
  priority: 10
  mailServer: "mail1.example.com."
  ttl: 3600

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: MXRecord
metadata:
  name: mx-backup
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "@"
  priority: 20
  mailServer: "mail2.example.com."
  ttl: 3600

---
# SPF Record
apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: spf
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "@"
  text:
    - "v=spf1 mx ip4:192.0.2.20/32 ip4:192.0.2.21/32 -all"
  ttl: 3600

---
# DKIM Record
apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: dkim
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "default._domainkey"
  text:
    - "v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC..."
  ttl: 3600

---
# DMARC Record
apiVersion: bindy.firestoned.io/v1alpha1
kind: TXTRecord
metadata:
  name: dmarc
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "_dmarc"
  text:
    - "v=DMARC1; p=quarantine; pct=100; rua=mailto:dmarc-reports@example.com; ruf=mailto:dmarc-forensics@example.com"
  ttl: 3600

---
# CAA Records
apiVersion: bindy.firestoned.io/v1alpha1
kind: CAARecord
metadata:
  name: caa-issue
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "@"
  flags: 0
  tag: "issue"
  value: "letsencrypt.org"
  ttl: 86400

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: CAARecord
metadata:
  name: caa-issuewild
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "@"
  flags: 0
  tag: "issuewild"
  value: "letsencrypt.org"
  ttl: 86400

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: CAARecord
metadata:
  name: caa-iodef
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "@"
  flags: 0
  tag: "iodef"
  value: "mailto:security@example.com"
  ttl: 86400

---
# Service Records
apiVersion: bindy.firestoned.io/v1alpha1
kind: SRVRecord
metadata:
  name: srv-sip-tcp
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "_sip._tcp"
  priority: 10
  weight: 60
  port: 5060
  target: "sip1.example.com."
  ttl: 3600

---
# CDN CNAME
apiVersion: bindy.firestoned.io/v1alpha1
kind: CNAMERecord
metadata:
  name: cdn
  namespace: dns-system-prod
spec:
  zone: "example-com-primary"
  name: "cdn"
  target: "d123456.cloudfront.net."
  ttl: 3600
</code></pre>
<h2 id="deployment-1"><a class="header" href="#deployment-1">Deployment</a></h2>
<h3 id="1-prerequisites"><a class="header" href="#1-prerequisites">1. Prerequisites</a></h3>
<pre><code class="language-bash"># Create namespace
kubectl create namespace dns-system-prod

# Label nodes for DNS pods (optional but recommended)
kubectl label nodes node1 dns-zone=primary
kubectl label nodes node2 dns-zone=primary
kubectl label nodes node3 dns-zone=secondary
kubectl label nodes node4 dns-zone=secondary
</code></pre>
<h3 id="2-deploy"><a class="header" href="#2-deploy">2. Deploy</a></h3>
<pre><code class="language-bash">kubectl apply -f production-dns.yaml
</code></pre>
<h3 id="3-verify"><a class="header" href="#3-verify">3. Verify</a></h3>
<pre><code class="language-bash"># Check all instances
kubectl get bind9instances -n dns-system-prod
kubectl get dnszones -n dns-system-prod
kubectl get pods -n dns-system-prod -o wide

# Check PodDisruptionBudgets
kubectl get pdb -n dns-system-prod

# Verify HA distribution
kubectl get pods -n dns-system-prod -o custom-columns=\
NAME:.metadata.name,\
NODE:.spec.nodeName,\
ROLE:.metadata.labels.dns-role
</code></pre>
<h2 id="monitoring-2"><a class="header" href="#monitoring-2">Monitoring</a></h2>
<h3 id="prometheus-metrics"><a class="header" href="#prometheus-metrics">Prometheus Metrics</a></h3>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: bindy-metrics
  namespace: dns-system-prod
  labels:
    app: bindy
spec:
  ports:
    - name: metrics
      port: 9090
      targetPort: 9090
  selector:
    app: bindy
</code></pre>
<h3 id="servicemonitor-for-prometheus-operator"><a class="header" href="#servicemonitor-for-prometheus-operator">ServiceMonitor (for Prometheus Operator)</a></h3>
<pre><code class="language-yaml">apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: bindy-dns
  namespace: dns-system-prod
spec:
  selector:
    matchLabels:
      app: bindy
  endpoints:
    - port: metrics
      interval: 30s
</code></pre>
<h2 id="backup-and-disaster-recovery"><a class="header" href="#backup-and-disaster-recovery">Backup and Disaster Recovery</a></h2>
<h3 id="backup-zones"><a class="header" href="#backup-zones">Backup Zones</a></h3>
<pre><code class="language-bash">#!/bin/bash
# backup-zones.sh

NAMESPACE="dns-system-prod"
BACKUP_DIR="./dns-backups/$(date +%Y%m%d)"

mkdir -p "$BACKUP_DIR"

# Backup all zones
kubectl get dnszones -n $NAMESPACE -o yaml &gt; "$BACKUP_DIR/zones.yaml"

# Backup all records
kubectl get arecords,aaaarecords,cnamerecords,mxrecords,txtrecords,nsrecords,srvrecords,caarecords \
  -n $NAMESPACE -o yaml &gt; "$BACKUP_DIR/records.yaml"

echo "Backup completed: $BACKUP_DIR"
</code></pre>
<h3 id="restore"><a class="header" href="#restore">Restore</a></h3>
<pre><code class="language-bash">kubectl apply -f dns-backups/20240115/zones.yaml
kubectl apply -f dns-backups/20240115/records.yaml
</code></pre>
<h2 id="security-hardening"><a class="header" href="#security-hardening">Security Hardening</a></h2>
<h3 id="network-policies-2"><a class="header" href="#network-policies-2">Network Policies</a></h3>
<pre><code class="language-yaml">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: dns-allow-queries
  namespace: dns-system-prod
spec:
  podSelector:
    matchLabels:
      app: bindy
  policyTypes:
    - Ingress
  ingress:
    - ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
</code></pre>
<h3 id="pod-security-standards"><a class="header" href="#pod-security-standards">Pod Security Standards</a></h3>
<pre><code class="language-yaml">apiVersion: v1
kind: Namespace
metadata:
  name: dns-system-prod
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
</code></pre>
<h2 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h2>
<h3 id="resource-limits-4"><a class="header" href="#resource-limits-4">Resource Limits</a></h3>
<pre><code class="language-yaml">spec:
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "1Gi"
      cpu: "1000m"
</code></pre>
<h3 id="horizontalpodautoscaler"><a class="header" href="#horizontalpodautoscaler">HorizontalPodAutoscaler</a></h3>
<pre><code class="language-yaml">apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: primary-dns-hpa
  namespace: dns-system-prod
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: primary-dns
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
</code></pre>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<h3 id="load-testing-2"><a class="header" href="#load-testing-2">Load Testing</a></h3>
<pre><code class="language-bash"># Using dnsperf
dnsperf -s &lt;DNS_IP&gt; -d queries.txt -c 100 -l 60

# queries.txt format:
# www.example.com A
# mail1.example.com A
# example.com MX
</code></pre>
<h3 id="failover-testing"><a class="header" href="#failover-testing">Failover Testing</a></h3>
<pre><code class="language-bash"># Delete primary pod to test failover
kubectl delete pod -n dns-system-prod -l dns-role=primary --force

# Monitor DNS continues to serve
dig @&lt;DNS_IP&gt; www.example.com
</code></pre>
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="reference/../advanced/ha.html">High Availability Guide</a></li>
<li><a href="reference/../operations/monitoring.html">Monitoring Guide</a></li>
<li><a href="reference/../advanced/security.html">Security Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-region-setup-example"><a class="header" href="#multi-region-setup-example">Multi-Region Setup Example</a></h1>
<p>Geographic distribution for global DNS resilience and performance.</p>
<h2 id="overview-12"><a class="header" href="#overview-12">Overview</a></h2>
<p>This example demonstrates:</p>
<ul>
<li>Primary instances in multiple regions</li>
<li>Secondary instances for redundancy</li>
<li>Zone replication across regions</li>
<li>Anycast for geographic load balancing</li>
<li>Cross-region monitoring</li>
</ul>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<pre><code>┌────────────────────────────────────────────────────────────────────┐
│                        Global DNS Infrastructure                    │
└────────────────────────────────────────────────────────────────────┘

  Region 1: us-east-1           Region 2: us-west-2         Region 3: eu-west-1
┌─────────────────────┐      ┌─────────────────────┐     ┌─────────────────────┐
│  Primary Instances  │      │ Secondary Instances │     │ Secondary Instances │
│                     │      │                     │     │                     │
│  ┌────┐  ┌────┐   │◄─────┤  ┌────┐  ┌────┐    │◄────┤  ┌────┐  ┌────┐    │
│  │Pod1│  │Pod2│   │ AXFR │  │Pod1│  │Pod2│    │AXFR │  │Pod1│  │Pod2│    │
│  └────┘  └────┘   │      │  └────┘  └────┘    │     │  └────┘  └────┘    │
│                     │      │                     │     │                     │
│  DNSSEC: Enabled    │      │  DNSSEC: Verify    │     │  DNSSEC: Verify    │
│  Replicas: 2        │      │  Replicas: 2        │     │  Replicas: 2        │
└─────────────────────┘      └─────────────────────┘     └─────────────────────┘
         │                            │                            │
         └────────────────────────────┴────────────────────────────┘
                                      │
                              Anycast IP: 192.0.2.1
                        (Routes to nearest region)
</code></pre>
<h2 id="region-1-us-east-1-primary"><a class="header" href="#region-1-us-east-1-primary">Region 1: us-east-1 (Primary)</a></h2>
<p>Save as <code>region-us-east-1.yaml</code>:</p>
<pre><code class="language-yaml">---
# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: dns-system
  labels:
    region: us-east-1
    role: primary

---
# Primary Bind9Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: primary-us-east-1
  namespace: dns-system
  labels:
    app: bindy
    dns-role: primary
    region: us-east-1
    environment: production
spec:
  replicas: 2
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    allowTransfer:
      - "10.1.0.0/16"  # us-west-2 CIDR
      - "10.2.0.0/16"  # eu-west-1 CIDR
    dnssec:
      enabled: true
      validation: false
    listenOn:
      - "any"
    listenOnV6:
      - "any"

---
# PodDisruptionBudget
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: primary-dns-pdb
  namespace: dns-system
spec:
  minAvailable: 1
  selector:
    matchLabels:
      dns-role: primary
      region: us-east-1

---
# Primary DNSZone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-primary
  namespace: dns-system
spec:
  zoneName: "example.com"
  zoneType: "primary"
  instanceSelector:
    matchLabels:
      dns-role: primary
      region: us-east-1
  soaRecord:
    primaryNs: "ns1.us-east-1.example.com."
    adminEmail: "dns-admin@example.com"
    serial: 2024010101
    refresh: 900
    retry: 300
    expire: 604800
    negativeTtl: 300
  ttl: 300

---
# Nameserver Records
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: ns1-us-east-1
  namespace: dns-system
spec:
  zone: "example-com-primary"
  name: "ns1.us-east-1"
  ipv4Address: "192.0.2.1"
  ttl: 86400

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: ns2-us-west-2
  namespace: dns-system
spec:
  zone: "example-com-primary"
  name: "ns2.us-west-2"
  ipv4Address: "192.0.2.2"
  ttl: 86400

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: ns3-eu-west-1
  namespace: dns-system
spec:
  zone: "example-com-primary"
  name: "ns3.eu-west-1"
  ipv4Address: "192.0.2.3"
  ttl: 86400

---
# Regional Web Servers
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-us-east-1
  namespace: dns-system
spec:
  zone: "example-com-primary"
  name: "www.us-east-1"
  ipv4Address: "192.0.2.10"
  ttl: 60

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-us-west-2
  namespace: dns-system
spec:
  zone: "example-com-primary"
  name: "www.us-west-2"
  ipv4Address: "192.0.2.20"
  ttl: 60

---
apiVersion: bindy.firestoned.io/v1alpha1
kind: ARecord
metadata:
  name: www-eu-west-1
  namespace: dns-system
spec:
  zone: "example-com-primary"
  name: "www.eu-west-1"
  ipv4Address: "192.0.2.30"
  ttl: 60

---
# GeoDNS using SRV records for service discovery
apiVersion: bindy.firestoned.io/v1alpha1
kind: SRVRecord
metadata:
  name: srv-web-us-east
  namespace: dns-system
spec:
  zone: "example-com-primary"
  name: "_http._tcp.us-east-1"
  priority: 10
  weight: 100
  port: 80
  target: "www.us-east-1.example.com."
  ttl: 300
</code></pre>
<h2 id="region-2-us-west-2-secondary"><a class="header" href="#region-2-us-west-2-secondary">Region 2: us-west-2 (Secondary)</a></h2>
<p>Save as <code>region-us-west-2.yaml</code>:</p>
<pre><code class="language-yaml">---
# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: dns-system
  labels:
    region: us-west-2
    role: secondary

---
# Secondary Bind9Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-us-west-2
  namespace: dns-system
  labels:
    app: bindy
    dns-role: secondary
    region: us-west-2
    environment: production
spec:
  replicas: 2
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    dnssec:
      enabled: false
      validation: true
    listenOn:
      - "any"
    listenOnV6:
      - "any"

---
# PodDisruptionBudget
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: secondary-dns-pdb
  namespace: dns-system
spec:
  minAvailable: 1
  selector:
    matchLabels:
      dns-role: secondary
      region: us-west-2

---
# Secondary DNSZone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-secondary
  namespace: dns-system
spec:
  zoneName: "example.com"
  zoneType: "secondary"
  instanceSelector:
    matchLabels:
      dns-role: secondary
      region: us-west-2
  secondaryConfig:
    primaryServers:
      - "192.0.2.1"   # Primary in us-east-1
      - "192.0.2.2"
  ttl: 300
</code></pre>
<h2 id="region-3-eu-west-1-secondary"><a class="header" href="#region-3-eu-west-1-secondary">Region 3: eu-west-1 (Secondary)</a></h2>
<p>Save as <code>region-eu-west-1.yaml</code>:</p>
<pre><code class="language-yaml">---
# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: dns-system
  labels:
    region: eu-west-1
    role: secondary

---
# Secondary Bind9Instance
apiVersion: bindy.firestoned.io/v1alpha1
kind: Bind9Instance
metadata:
  name: secondary-eu-west-1
  namespace: dns-system
  labels:
    app: bindy
    dns-role: secondary
    region: eu-west-1
    environment: production
spec:
  replicas: 2
  version: "9.18"
  config:
    recursion: false
    allowQuery:
      - "0.0.0.0/0"
    dnssec:
      enabled: false
      validation: true
    listenOn:
      - "any"
    listenOnV6:
      - "any"

---
# PodDisruptionBudget
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: secondary-dns-pdb
  namespace: dns-system
spec:
  minAvailable: 1
  selector:
    matchLabels:
      dns-role: secondary
      region: eu-west-1

---
# Secondary DNSZone
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: example-com-secondary
  namespace: dns-system
spec:
  zoneName: "example.com"
  zoneType: "secondary"
  instanceSelector:
    matchLabels:
      dns-role: secondary
      region: eu-west-1
  secondaryConfig:
    primaryServers:
      - "192.0.2.1"   # Primary in us-east-1
      - "192.0.2.2"
  ttl: 300
</code></pre>
<h2 id="deployment-2"><a class="header" href="#deployment-2">Deployment</a></h2>
<h3 id="1-deploy-to-each-region"><a class="header" href="#1-deploy-to-each-region">1. Deploy to Each Region</a></h3>
<pre><code class="language-bash"># us-east-1
kubectl apply -f region-us-east-1.yaml --context us-east-1

# us-west-2
kubectl apply -f region-us-west-2.yaml --context us-west-2

# eu-west-1
kubectl apply -f region-eu-west-1.yaml --context eu-west-1
</code></pre>
<h3 id="2-verify-replication"><a class="header" href="#2-verify-replication">2. Verify Replication</a></h3>
<pre><code class="language-bash"># Check zone transfer from primary
kubectl exec -n dns-system -it &lt;primary-pod&gt; -- \
  dig @localhost example.com AXFR

# Verify secondary received zone
kubectl exec -n dns-system -it &lt;secondary-pod&gt; -- \
  dig @localhost example.com SOA
</code></pre>
<h3 id="3-configure-anycast-infrastructure-level"><a class="header" href="#3-configure-anycast-infrastructure-level">3. Configure Anycast (Infrastructure Level)</a></h3>
<p>This requires network infrastructure support:</p>
<pre><code class="language-bash"># Example using MetalLB for on-premises
apiVersion: v1
kind: Service
metadata:
  name: dns-anycast
  namespace: dns-system
  annotations:
    metallb.universe.tf/address-pool: anycast-pool
spec:
  type: LoadBalancer
  loadBalancerIP: 192.0.2.1  # Same IP in all regions
  selector:
    app: bindy
  ports:
    - protocol: UDP
      port: 53
      targetPort: 53
</code></pre>
<h2 id="cross-region-monitoring"><a class="header" href="#cross-region-monitoring">Cross-Region Monitoring</a></h2>
<h3 id="prometheus-federation"><a class="header" href="#prometheus-federation">Prometheus Federation</a></h3>
<pre><code class="language-yaml"># Global Prometheus Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
data:
  prometheus.yml: |
    global:
      scrape_interval: 30s
    
    scrape_configs:
      # us-east-1
      - job_name: 'dns-us-east-1'
        static_configs:
          - targets: ['prometheus.us-east-1.example.com:9090']
        metric_relabel_configs:
          - source_labels: [__name__]
            regex: 'dns_.*'
            action: keep
      
      # us-west-2
      - job_name: 'dns-us-west-2'
        static_configs:
          - targets: ['prometheus.us-west-2.example.com:9090']
        metric_relabel_configs:
          - source_labels: [__name__]
            regex: 'dns_.*'
            action: keep
      
      # eu-west-1
      - job_name: 'dns-eu-west-1'
        static_configs:
          - targets: ['prometheus.eu-west-1.example.com:9090']
        metric_relabel_configs:
          - source_labels: [__name__]
            regex: 'dns_.*'
            action: keep
</code></pre>
<h3 id="health-checks-1"><a class="header" href="#health-checks-1">Health Checks</a></h3>
<pre><code class="language-bash">#!/bin/bash
# health-check-multi-region.sh

REGIONS=("us-east-1" "us-west-2" "eu-west-1")
QUERY="www.example.com"

for region in "${REGIONS[@]}"; do
  echo "Checking $region..."
  
  # Get DNS service IP
  DNS_IP=$(kubectl get svc -n dns-system --context $region \
    -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}')
  
  # Test query
  if dig @$DNS_IP $QUERY +short &gt; /dev/null; then
    echo "✓ $region: OK"
  else
    echo "✗ $region: FAILED"
  fi
done
</code></pre>
<h2 id="disaster-recovery-1"><a class="header" href="#disaster-recovery-1">Disaster Recovery</a></h2>
<h3 id="regional-failover-1"><a class="header" href="#regional-failover-1">Regional Failover</a></h3>
<pre><code class="language-bash"># Promote secondary in us-west-2 to primary
kubectl patch bind9instance secondary-us-west-2 \
  -n dns-system --context us-west-2 \
  --type merge \
  --patch '{"metadata":{"labels":{"dns-role":"primary"}}}'

# Update zone to primary
kubectl patch dnszone example-com-secondary \
  -n dns-system --context us-west-2 \
  --type merge \
  --patch '{"spec":{"zoneType":"primary"}}'
</code></pre>
<h3 id="backup-strategy-1"><a class="header" href="#backup-strategy-1">Backup Strategy</a></h3>
<pre><code class="language-bash">#!/bin/bash
# backup-all-regions.sh

REGIONS=("us-east-1" "us-west-2" "eu-west-1")
BACKUP_DIR="./multi-region-backups/$(date +%Y%m%d)"

mkdir -p "$BACKUP_DIR"

for region in "${REGIONS[@]}"; do
  echo "Backing up $region..."
  
  kubectl get dnszones,arecords,aaaarecords,cnamerecords,mxrecords,txtrecords \
    -n dns-system --context $region -o yaml \
    &gt; "$BACKUP_DIR/$region.yaml"
done

echo "Backup completed: $BACKUP_DIR"
</code></pre>
<h2 id="performance-testing-2"><a class="header" href="#performance-testing-2">Performance Testing</a></h2>
<h3 id="global-latency-test"><a class="header" href="#global-latency-test">Global Latency Test</a></h3>
<pre><code class="language-bash">#!/bin/bash
# test-global-latency.sh

REGIONS=(
  "us-east-1:192.0.2.1"
  "us-west-2:192.0.2.2"
  "eu-west-1:192.0.2.3"
)

for region_ip in "${REGIONS[@]}"; do
  region="${region_ip%%:*}"
  ip="${region_ip##*:}"
  
  echo "Testing $region ($ip)..."
  
  # Measure query time
  time dig @$ip www.example.com +short
done
</code></pre>
<h3 id="load-distribution"><a class="header" href="#load-distribution">Load Distribution</a></h3>
<pre><code class="language-bash"># Using dnsperf across regions
for region in us-east-1 us-west-2 eu-west-1; do
  dnsperf -s $DNS_IP -d queries.txt -c 50 -l 30 -Q 1000 | \
    tee results-$region.txt
done
</code></pre>
<h2 id="cost-optimization"><a class="header" href="#cost-optimization">Cost Optimization</a></h2>
<h3 id="regional-scaling"><a class="header" href="#regional-scaling">Regional Scaling</a></h3>
<pre><code class="language-yaml"># HPA for each region based on local load
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: dns-hpa-us-east-1
  namespace: dns-system
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: primary-us-east-1
  minReplicas: 2
  maxReplicas: 5
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
</code></pre>
<h2 id="compliance-and-data-residency"><a class="header" href="#compliance-and-data-residency">Compliance and Data Residency</a></h2>
<h3 id="regional-data-isolation"><a class="header" href="#regional-data-isolation">Regional Data Isolation</a></h3>
<pre><code class="language-yaml"># EU-specific zone for GDPR compliance
apiVersion: bindy.firestoned.io/v1alpha1
kind: DNSZone
metadata:
  name: eu-example-com
  namespace: dns-system
  labels:
    compliance: gdpr
spec:
  zoneName: "eu.example.com"
  zoneType: "primary"
  instanceSelector:
    matchLabels:
      region: eu-west-1
  soaRecord:
    primaryNs: "ns1.eu-west-1.example.com."
    adminEmail: "dpo@example.com"
    serial: 2024010101
    refresh: 900
    retry: 300
    expire: 604800
    negativeTtl: 300
</code></pre>
<h2 id="related-documentation-1"><a class="header" href="#related-documentation-1">Related Documentation</a></h2>
<ul>
<li><a href="reference/../guide/multi-region.html">Multi-Region Deployment Guide</a></li>
<li><a href="reference/../advanced/replication.html">Replication Strategies</a></li>
<li><a href="reference/../advanced/ha.html">High Availability</a></li>
<li><a href="reference/../advanced/zone-transfers.html">Zone Transfers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-documentation-rustdoc"><a class="header" href="#api-documentation-rustdoc">API Documentation (rustdoc)</a></h1>
<p>The complete API documentation is generated from Rust source code and is available separately.</p>
<h2 id="viewing-api-documentation"><a class="header" href="#viewing-api-documentation">Viewing API Documentation</a></h2>
<h3 id="online"><a class="header" href="#online">Online</a></h3>
<p>Visit the <a href="rustdoc/bindy/index.html">API Reference</a> section of the documentation site.</p>
<h3 id="locally"><a class="header" href="#locally">Locally</a></h3>
<p>Build and view the API documentation:</p>
<pre><code class="language-bash"># Build API docs
cargo doc --no-deps --all-features

# Open in browser
cargo doc --no-deps --all-features --open
</code></pre>
<p>Or build the complete documentation (user guide + API):</p>
<pre><code class="language-bash">make docs-serve
# Navigate to http://localhost:3000/rustdoc/bindy/index.html
</code></pre>
<h2 id="whats-in-the-api-documentation"><a class="header" href="#whats-in-the-api-documentation">What's in the API Documentation</a></h2>
<p>The rustdoc API documentation includes:</p>
<ul>
<li><strong>Module Documentation</strong> - All public modules and their organization</li>
<li><strong>Struct Definitions</strong> - Complete CRD type definitions (Bind9Instance, DNSZone, etc.)</li>
<li><strong>Function Signatures</strong> - All public functions with parameter types and return values</li>
<li><strong>Examples</strong> - Code examples showing how to use the API</li>
<li><strong>Type Documentation</strong> - Detailed information about all public types</li>
<li><strong>Trait Implementations</strong> - All trait implementations for types</li>
</ul>
<h2 id="key-modules"><a class="header" href="#key-modules">Key Modules</a></h2>
<ul>
<li><code>bindy::crd</code> - Custom Resource Definitions</li>
<li><code>bindy::reconcilers</code> - Controller reconciliation logic</li>
<li><code>bindy::bind9</code> - BIND9 zone file management</li>
<li><code>bindy::bind9_resources</code> - Kubernetes resource builders</li>
</ul>
<h2 id="direct-links"><a class="header" href="#direct-links">Direct Links</a></h2>
<p>When the documentation is built, you can access:</p>
<ul>
<li><strong>Main API Index</strong>: <code>rustdoc/bindy/index.html</code></li>
<li><strong>CRD Module</strong>: <code>rustdoc/bindy/crd/index.html</code></li>
<li><strong>Reconcilers</strong>: <code>rustdoc/bindy/reconcilers/index.html</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to Bindy will be documented in this file.</p>
<p>The format is based on <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>,
and this project adheres to <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2 id="unreleased"><a class="header" href="#unreleased">[Unreleased]</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>Comprehensive documentation with mdBook and rustdoc</li>
<li>GitHub Pages deployment workflow</li>
</ul>
<h2 id="010---2024-01-01"><a class="header" href="#010---2024-01-01">[0.1.0] - 2024-01-01</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>Initial release of Bindy</li>
<li>Bind9Instance CRD for managing BIND9 DNS server instances</li>
<li>DNSZone CRD with label selector support</li>
<li>DNS record CRDs: A, AAAA, CNAME, MX, TXT, NS, SRV, CAA</li>
<li>Reconciliation controllers for all resource types</li>
<li>BIND9 zone file generation</li>
<li>Status subresources for all CRDs</li>
<li>RBAC configuration</li>
<li>Docker container support</li>
<li>Comprehensive test suite</li>
<li>CI/CD with GitHub Actions</li>
<li>Integration tests with Kind</li>
</ul>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<ul>
<li>High-performance Rust implementation</li>
<li>Async/await with Tokio runtime</li>
<li>Label-based instance targeting</li>
<li>Primary and secondary DNS support</li>
<li>Multi-region deployment support</li>
<li>Full status reporting</li>
<li>Kubernetes 1.24+ support</li>
</ul>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://github.com/firestoned/bindy">GitHub Repository</a></li>
<li><a href="https://firestoned.github.io/bindy/">Documentation</a></li>
<li><a href="https://github.com/firestoned/bindy/issues">Issue Tracker</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license-2"><a class="header" href="#license-2">License</a></h1>
<p>Bindy is licensed under the MIT License.</p>
<p><strong>SPDX-License-Identifier:</strong> MIT</p>
<p><strong>Copyright (c) 2025 Erick Bourgeois, firestoned</strong></p>
<h2 id="mit-license"><a class="header" href="#mit-license">MIT License</a></h2>
<p>Copyright (c) 2025 Erick Bourgeois, firestoned</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<h2 id="what-this-means-for-you"><a class="header" href="#what-this-means-for-you">What This Means for You</a></h2>
<p>The MIT License is one of the most permissive open source licenses. Here's what it allows:</p>
<h3 id="-you-can"><a class="header" href="#-you-can">✅ You Can</a></h3>
<ul>
<li><strong>Use commercially</strong> - Use Bindy in your commercial products and services</li>
<li><strong>Modify</strong> - Change the code to fit your needs</li>
<li><strong>Distribute</strong> - Share the original or your modified version</li>
<li><strong>Sublicense</strong> - Include Bindy in proprietary software</li>
<li><strong>Private use</strong> - Use Bindy for private/internal purposes without releasing your modifications</li>
</ul>
<h3 id="-requirements"><a class="header" href="#-requirements">⚠️ Requirements</a></h3>
<ul>
<li><strong>Include the license</strong> - Include the copyright notice and license text in substantial portions of the software</li>
<li><strong>State changes</strong> - Document any modifications you make (recommended best practice)</li>
</ul>
<h3 id="-limitations"><a class="header" href="#-limitations">❌ Limitations</a></h3>
<ul>
<li><strong>No warranty</strong> - The software is provided "as is" without warranty of any kind</li>
<li><strong>No liability</strong> - The authors are not liable for any damages arising from the use of the software</li>
</ul>
<h2 id="spdx-license-identifiers-1"><a class="header" href="#spdx-license-identifiers-1">SPDX License Identifiers</a></h2>
<p>All source code files in this project include SPDX license identifiers for machine-readable license information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright (c) 2025 Erick Bourgeois, firestoned
// SPDX-License-Identifier: MIT
<span class="boring">}</span></code></pre></pre>
<p>This makes it easy for automated tools to:</p>
<ul>
<li>Scan the codebase for license compliance</li>
<li>Generate Software Bill of Materials (SBOM)</li>
<li>Verify license compatibility</li>
</ul>
<p>Learn more about SPDX at <a href="https://spdx.dev/">https://spdx.dev/</a></p>
<h2 id="software-bill-of-materials-sbom"><a class="header" href="#software-bill-of-materials-sbom">Software Bill of Materials (SBOM)</a></h2>
<p>Bindy provides SBOM files in CycloneDX format with every release. These include:</p>
<ul>
<li>Binary SBOMs for each platform (Linux, macOS, Windows)</li>
<li>Docker image SBOM</li>
<li>Complete dependency tree with license information</li>
</ul>
<p>SBOMs are available as release assets and can be used for:</p>
<ul>
<li>Supply chain security</li>
<li>Vulnerability scanning</li>
<li>License compliance auditing</li>
<li>Dependency tracking</li>
</ul>
<h2 id="third-party-licenses"><a class="header" href="#third-party-licenses">Third-Party Licenses</a></h2>
<p>Bindy depends on various open-source libraries. All dependencies are permissively licensed and compatible with the MIT License.</p>
<h3 id="key-dependencies"><a class="header" href="#key-dependencies">Key Dependencies</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Library</th><th>License</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>kube-rs</strong></td><td>Apache 2.0 / MIT</td><td>Kubernetes client library</td></tr>
<tr><td><strong>tokio</strong></td><td>MIT</td><td>Async runtime</td></tr>
<tr><td><strong>serde</strong></td><td>Apache 2.0 / MIT</td><td>Serialization framework</td></tr>
<tr><td><strong>tracing</strong></td><td>MIT</td><td>Structured logging</td></tr>
<tr><td><strong>anyhow</strong></td><td>Apache 2.0 / MIT</td><td>Error handling</td></tr>
<tr><td><strong>thiserror</strong></td><td>Apache 2.0 / MIT</td><td>Error derivation</td></tr>
</tbody></table>
</div>
<h3 id="generating-license-reports"><a class="header" href="#generating-license-reports">Generating License Reports</a></h3>
<p>For a complete list of all dependencies and their licenses:</p>
<pre><code class="language-bash"># Install cargo-license tool
cargo install cargo-license

# Generate license report
cargo license

# Generate detailed license report with full license text
cargo license --json &gt; licenses.json
</code></pre>
<p>You can also use <a href="https://github.com/EmbarkStudios/cargo-about">cargo-about</a> for more detailed license auditing:</p>
<pre><code class="language-bash">cargo install cargo-about
cargo about generate about.hbs &gt; licenses.html
</code></pre>
<h2 id="container-image-licenses"><a class="header" href="#container-image-licenses">Container Image Licenses</a></h2>
<p>The Docker images for Bindy include:</p>
<ul>
<li><strong>Base Image</strong>: Alpine Linux (MIT License)</li>
<li><strong>BIND9</strong>: ISC License (permissive, BSD-style)</li>
<li><strong>Bindy Binary</strong>: MIT License</li>
</ul>
<p>All components are open source and permissively licensed.</p>
<h2 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h2>
<p>By contributing to Bindy, you agree that:</p>
<ol>
<li>Your contributions will be licensed under the MIT License</li>
<li>You have the right to submit the contributions</li>
<li>You grant the project maintainers a perpetual, worldwide, non-exclusive, royalty-free license to use your contributions</li>
</ol>
<p>See the <a href="./development/contributing.html">Contributing Guidelines</a> for more information on how to contribute.</p>
<h2 id="license-compatibility"><a class="header" href="#license-compatibility">License Compatibility</a></h2>
<p>The MIT License is compatible with most other open source licenses, including:</p>
<ul>
<li>✅ Apache License 2.0</li>
<li>✅ BSD licenses (2-clause, 3-clause)</li>
<li>✅ GPL v2 and v3 (one-way compatible - MIT code can be included in GPL projects)</li>
<li>✅ ISC License</li>
<li>✅ Other MIT-licensed code</li>
</ul>
<p>This makes Bindy easy to integrate into various projects and environments.</p>
<h2 id="questions-about-licensing"><a class="header" href="#questions-about-licensing">Questions About Licensing</a></h2>
<p>If you have questions about:</p>
<ul>
<li>Using Bindy in your project</li>
<li>License compliance</li>
<li>Contributing to Bindy</li>
<li>Third-party dependencies</li>
</ul>
<p>Please open a <a href="https://github.com/firestoned/bindy/discussions">GitHub Discussion</a> or contact the maintainers.</p>
<h2 id="additional-resources-2"><a class="header" href="#additional-resources-2">Additional Resources</a></h2>
<ul>
<li><a href="../../LICENSE">Full License Text</a></li>
<li><a href="https://opensource.org/licenses/MIT">MIT License on OSI</a></li>
<li><a href="https://spdx.org/licenses/MIT.html">SPDX MIT License</a></li>
<li><a href="https://choosealicense.com/licenses/mit/">GitHub's Choose a License - MIT</a></li>
<li><a href="https://spdx.github.io/spdx-spec/">SPDX Specification</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
