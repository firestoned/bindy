# Copyright (c) 2025 Erick Bourgeois, firestoned
# SPDX-License-Identifier: MIT

# This Dockerfile uses cargo-chef for optimal caching of Rust dependencies
# First build: ~5 minutes, subsequent builds: ~30 seconds (if only src/ changes)
#
# To use this Dockerfile:
#   docker build -f Dockerfile.chef -t bindy:latest .
#
# IMPORTANT: This requires cargo-chef to be installed in the base image.
# The rust:1.91.0 image doesn't include it by default, so we install it in a separate stage.

# Stage 1: Prepare cargo-chef
FROM rust:1.91.0 as chef
RUN cargo install cargo-chef
WORKDIR /workspace

# Stage 2: Generate recipe file (this layer is cached unless Cargo.toml/Cargo.lock change)
FROM chef as planner
COPY Cargo.toml Cargo.lock ./
COPY src ./src
RUN cargo chef prepare --recipe-path recipe.json

# Stage 3: Build dependencies (this layer is cached unless recipe changes)
FROM chef as builder

# Accept version as build argument
ARG VERSION=0.1.0

# Install musl target and cross-compilation tools for static linking
RUN rustup target add aarch64-unknown-linux-musl x86_64-unknown-linux-musl && \
    apt-get update && \
    apt-get install -y musl-tools && \
    rm -rf /var/lib/apt/lists/*

# Determine the musl target based on architecture
RUN ARCH=$(uname -m) && \
    if [ "$ARCH" = "aarch64" ]; then \
        echo "aarch64-unknown-linux-musl" > /tmp/target; \
    else \
        echo "x86_64-unknown-linux-musl" > /tmp/target; \
    fi

# Copy recipe and build dependencies
COPY --from=planner /workspace/recipe.json recipe.json
RUN TARGET=$(cat /tmp/target) && \
    cargo chef cook --release --target $TARGET --recipe-path recipe.json

# Copy source code and build the actual binary
COPY Cargo.toml Cargo.lock ./
COPY src ./src
COPY templates ./templates

# Update version in Cargo.toml using the VERSION build argument
RUN sed -i "s/^version = \".*\"/version = \"${VERSION}\"/" Cargo.toml

# Build the actual controller with musl for static linking
RUN TARGET=$(cat /tmp/target) && \
    cargo build --release --target $TARGET && \
    cp target/$TARGET/release/bindy target/release/bindy

# Runtime stage
FROM alpine:3.20

LABEL org.opencontainers.image.source="https://github.com/firestoned/bindy"
LABEL org.opencontainers.image.description="BIND9 DNS Controller for Kubernetes"
LABEL org.opencontainers.image.licenses="MIT"

# Install BIND9 and required libraries
# Binary is statically linked with musl, so no glibc needed
RUN apk add --no-cache \
    bind \
    bind-tools \
    ca-certificates \
    curl

# Create bindy user and directories
RUN addgroup -S bindy && adduser -S -G bindy bindy && \
    mkdir -p /etc/bind/zones && \
    mkdir -p /var/cache/bind && \
    mkdir -p /var/lib/bind && \
    mkdir -p /run/named && \
    chown -R bindy:bindy /etc/bind /var/cache/bind /var/lib/bind /run/named

# Copy the built controller from builder
COPY --from=builder /workspace/target/release/bindy /usr/local/bin/

# Set permissions
RUN chmod +x /usr/local/bin/bindy

# Run as bind user
USER bindy

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Start the controller
ENTRYPOINT ["/usr/local/bin/bindy"]
