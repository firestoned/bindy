# Complete Bindy DNS Setup Example
#
# This example demonstrates the correct relationship between:
# - Bind9Cluster (defines shared configuration)
# - Bind9Instance (actual DNS server pods)
# - DNSZone (DNS zones to serve, discovers records via label selectors)
# - DNS Records (A, CNAME, MX, etc. - associated via labels)
#
# IMPORTANT: The clusterRef must match across resources:
#   DNSZone.spec.clusterRef → Bind9Cluster.metadata.name
#   Bind9Instance.spec.clusterRef → Bind9Cluster.metadata.name
#
# IMPORTANT: Records are discovered via label selectors:
#   DNSZone.spec.recordsFrom[].selector matches record labels

---
# Step 1: Create the Bind9Cluster
# This defines shared configuration for all instances in the cluster
apiVersion: bindy.firestoned.io/v1beta1
kind: Bind9Cluster
metadata:
  name: production-dns  # ← This is the cluster name referenced by others
  namespace: dns-system
  labels:
    environment: production
spec:
  version: "9.18"
  # Primary instance configuration
  primary:
    # Default number of replicas for primary instances (can be overridden per instance)
    replicas: 2
  # Secondary instance configuration
  secondary:
    # Default number of replicas for secondary instances (can be overridden per instance)
    replicas: 1
  global:
    recursion: false
    allowQuery:
      - "any"
    allowTransfer:
      - "10.0.0.0/8"
    bindcarConfig:
      image: "ghcr.io/firestoned/bindcar:v0.3.0"
      imagePullPolicy: IfNotPresent
      logLevel: debug
    dnssec:
      validation: true

---
# Step 2: Create DNS Zones
# These define which zones the cluster will serve
# Records are discovered via label selectors

apiVersion: bindy.firestoned.io/v1beta1
kind: DNSZone
metadata:
  name: example-com  # ← Zone resource name (can be anything)
  namespace: dns-system
spec:
  zoneName: example.com  # ← Actual DNS zone name
  clusterRef: production-dns  # ← Must match Bind9Cluster name (NOT instance name!)
  soaRecord:
    primaryNs: ns1.example.com.
    adminEmail: admin.example.com.
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTtl: 86400
  ttl: 3600
  # Discover records with matching labels
  recordsFrom:
    - selector:
        matchLabels:
          zone: example.com

---
apiVersion: bindy.firestoned.io/v1beta1
kind: DNSZone
metadata:
  name: internal-local
  namespace: dns-system
spec:
  zoneName: internal.local
  clusterRef: production-dns  # ← Must match Bind9Cluster name
  soaRecord:
    primaryNs: ns1.internal.local.
    adminEmail: admin.internal.local.
    serial: 2024010101
    refresh: 3600
    retry: 600
    expire: 604800
    negativeTtl: 86400
  ttl: 3600
  # Discover records with matching labels
  recordsFrom:
    - selector:
        matchLabels:
          zone: internal.local

---
# Step 3: Create DNS Records
# Records are associated with zones via labels
# The DNSZone's recordsFrom selector will discover these records

apiVersion: bindy.firestoned.io/v1beta1
kind: ARecord
metadata:
  name: www-example-com
  namespace: dns-system
  labels:
    zone: example.com  # ← Matches DNSZone's recordsFrom selector
spec:
  name: www  # Creates www.example.com
  ipv4Address: 192.168.1.10
  ttl: 300

---
apiVersion: bindy.firestoned.io/v1beta1
kind: ARecord
metadata:
  name: api-example-com
  namespace: dns-system
  labels:
    zone: example.com
spec:
  name: api  # Creates api.example.com
  ipv4Address: 192.168.1.20
  ttl: 300

---
apiVersion: bindy.firestoned.io/v1beta1
kind: CNAMERecord
metadata:
  name: blog-example-com
  namespace: dns-system
  labels:
    zone: example.com
spec:
  name: blog  # Creates blog.example.com
  target: www.example.com.  # Must end with .
  ttl: 300

---
apiVersion: bindy.firestoned.io/v1beta1
kind: MXRecord
metadata:
  name: mail-example-com
  namespace: dns-system
  labels:
    zone: example.com
spec:
  name: "@"  # @ means zone apex (example.com)
  priority: 10
  mailServer: mail.example.com.  # Must end with .
  ttl: 300

---
apiVersion: bindy.firestoned.io/v1beta1
kind: TXTRecord
metadata:
  name: spf-example-com
  namespace: dns-system
  labels:
    zone: example.com
spec:
  name: "@"
  text:
    - "v=spf1 mx -all"
  ttl: 300

---
# How the relationships work:
#
# 1. Bind9Cluster "production-dns"
#    ↓
# 2. Bind9Instance "primary-dns" (clusterRef: production-dns)
#    Bind9Instance "secondary-dns" (clusterRef: production-dns)
#    ↓
# 3. DNSZone "example-com" (clusterRef: production-dns)
#    DNSZone "internal-local" (clusterRef: production-dns)
#    ↓
# 4. DNSZone discovers records via label selectors:
#    - DNSZone.spec.recordsFrom[].selector.matchLabels.zone == "example.com"
#    - Finds: ARecord "www-example-com", ARecord "api-example-com",
#             CNAMERecord "blog-example-com", MXRecord "mail-example-com",
#             TXTRecord "spf-example-com"
#
# When a DNSZone is reconciled:
# - Controller queries all DNS record types in the namespace
# - Filters records using the recordsFrom label selectors
# - For each matching record, adds it to the primary BIND9 instances
# - Records with labels matching the selector are automatically included in the zone
